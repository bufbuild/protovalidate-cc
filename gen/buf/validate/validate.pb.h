// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: buf/validate/validate.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_buf_2fvalidate_2fvalidate_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_buf_2fvalidate_2fvalidate_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "buf/validate/expression.pb.h"
#include "buf/validate/priv/private.pb.h"
#include "google/protobuf/descriptor.pb.h"
#include "google/protobuf/duration.pb.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_buf_2fvalidate_2fvalidate_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_buf_2fvalidate_2fvalidate_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_buf_2fvalidate_2fvalidate_2eproto;
namespace buf {
namespace validate {
class AnyRules;
struct AnyRulesDefaultTypeInternal;
extern AnyRulesDefaultTypeInternal _AnyRules_default_instance_;
class BoolRules;
struct BoolRulesDefaultTypeInternal;
extern BoolRulesDefaultTypeInternal _BoolRules_default_instance_;
class BytesRules;
struct BytesRulesDefaultTypeInternal;
extern BytesRulesDefaultTypeInternal _BytesRules_default_instance_;
class DoubleRules;
struct DoubleRulesDefaultTypeInternal;
extern DoubleRulesDefaultTypeInternal _DoubleRules_default_instance_;
class DurationRules;
struct DurationRulesDefaultTypeInternal;
extern DurationRulesDefaultTypeInternal _DurationRules_default_instance_;
class EnumRules;
struct EnumRulesDefaultTypeInternal;
extern EnumRulesDefaultTypeInternal _EnumRules_default_instance_;
class FieldConstraints;
struct FieldConstraintsDefaultTypeInternal;
extern FieldConstraintsDefaultTypeInternal _FieldConstraints_default_instance_;
class Fixed32Rules;
struct Fixed32RulesDefaultTypeInternal;
extern Fixed32RulesDefaultTypeInternal _Fixed32Rules_default_instance_;
class Fixed64Rules;
struct Fixed64RulesDefaultTypeInternal;
extern Fixed64RulesDefaultTypeInternal _Fixed64Rules_default_instance_;
class FloatRules;
struct FloatRulesDefaultTypeInternal;
extern FloatRulesDefaultTypeInternal _FloatRules_default_instance_;
class Int32Rules;
struct Int32RulesDefaultTypeInternal;
extern Int32RulesDefaultTypeInternal _Int32Rules_default_instance_;
class Int64Rules;
struct Int64RulesDefaultTypeInternal;
extern Int64RulesDefaultTypeInternal _Int64Rules_default_instance_;
class MapRules;
struct MapRulesDefaultTypeInternal;
extern MapRulesDefaultTypeInternal _MapRules_default_instance_;
class MessageConstraints;
struct MessageConstraintsDefaultTypeInternal;
extern MessageConstraintsDefaultTypeInternal _MessageConstraints_default_instance_;
class OneofConstraints;
struct OneofConstraintsDefaultTypeInternal;
extern OneofConstraintsDefaultTypeInternal _OneofConstraints_default_instance_;
class RepeatedRules;
struct RepeatedRulesDefaultTypeInternal;
extern RepeatedRulesDefaultTypeInternal _RepeatedRules_default_instance_;
class SFixed32Rules;
struct SFixed32RulesDefaultTypeInternal;
extern SFixed32RulesDefaultTypeInternal _SFixed32Rules_default_instance_;
class SFixed64Rules;
struct SFixed64RulesDefaultTypeInternal;
extern SFixed64RulesDefaultTypeInternal _SFixed64Rules_default_instance_;
class SInt32Rules;
struct SInt32RulesDefaultTypeInternal;
extern SInt32RulesDefaultTypeInternal _SInt32Rules_default_instance_;
class SInt64Rules;
struct SInt64RulesDefaultTypeInternal;
extern SInt64RulesDefaultTypeInternal _SInt64Rules_default_instance_;
class StringRules;
struct StringRulesDefaultTypeInternal;
extern StringRulesDefaultTypeInternal _StringRules_default_instance_;
class TimestampRules;
struct TimestampRulesDefaultTypeInternal;
extern TimestampRulesDefaultTypeInternal _TimestampRules_default_instance_;
class UInt32Rules;
struct UInt32RulesDefaultTypeInternal;
extern UInt32RulesDefaultTypeInternal _UInt32Rules_default_instance_;
class UInt64Rules;
struct UInt64RulesDefaultTypeInternal;
extern UInt64RulesDefaultTypeInternal _UInt64Rules_default_instance_;
}  // namespace validate
}  // namespace buf
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace buf {
namespace validate {
enum KnownRegex : int {
  KNOWN_REGEX_UNSPECIFIED = 0,
  KNOWN_REGEX_HTTP_HEADER_NAME = 1,
  KNOWN_REGEX_HTTP_HEADER_VALUE = 2,
  KnownRegex_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  KnownRegex_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool KnownRegex_IsValid(int value);
constexpr KnownRegex KnownRegex_MIN = static_cast<KnownRegex>(0);
constexpr KnownRegex KnownRegex_MAX = static_cast<KnownRegex>(2);
constexpr int KnownRegex_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
KnownRegex_descriptor();
template <typename T>
const std::string& KnownRegex_Name(T value) {
  static_assert(std::is_same<T, KnownRegex>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to KnownRegex_Name().");
  return KnownRegex_Name(static_cast<KnownRegex>(value));
}
template <>
inline const std::string& KnownRegex_Name(KnownRegex value) {
  return ::google::protobuf::internal::NameOfDenseEnum<KnownRegex_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool KnownRegex_Parse(absl::string_view name, KnownRegex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KnownRegex>(
      KnownRegex_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class MessageConstraints final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.MessageConstraints) */ {
 public:
  inline MessageConstraints() : MessageConstraints(nullptr) {}
  ~MessageConstraints() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MessageConstraints(::google::protobuf::internal::ConstantInitialized);

  MessageConstraints(const MessageConstraints& from);
  MessageConstraints(MessageConstraints&& from) noexcept
    : MessageConstraints() {
    *this = ::std::move(from);
  }

  inline MessageConstraints& operator=(const MessageConstraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageConstraints& operator=(MessageConstraints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageConstraints& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageConstraints* internal_default_instance() {
    return reinterpret_cast<const MessageConstraints*>(
               &_MessageConstraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MessageConstraints& a, MessageConstraints& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageConstraints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageConstraints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageConstraints* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageConstraints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MessageConstraints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MessageConstraints& from) {
    MessageConstraints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageConstraints* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.MessageConstraints";
  }
  protected:
  explicit MessageConstraints(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCelFieldNumber = 3,
    kDisabledFieldNumber = 1,
  };
  // repeated .buf.validate.Constraint cel = 3 [json_name = "cel"];
  int cel_size() const;
  private:
  int _internal_cel_size() const;

  public:
  void clear_cel() ;
  ::buf::validate::Constraint* mutable_cel(int index);
  ::google::protobuf::RepeatedPtrField< ::buf::validate::Constraint >*
      mutable_cel();
  private:
  const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>& _internal_cel() const;
  ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>* _internal_mutable_cel();
  public:
  const ::buf::validate::Constraint& cel(int index) const;
  ::buf::validate::Constraint* add_cel();
  const ::google::protobuf::RepeatedPtrField< ::buf::validate::Constraint >&
      cel() const;
  // optional bool disabled = 1 [json_name = "disabled"];
  bool has_disabled() const;
  void clear_disabled() ;
  bool disabled() const;
  void set_disabled(bool value);

  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);

  public:
  // @@protoc_insertion_point(class_scope:buf.validate.MessageConstraints)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::buf::validate::Constraint > cel_;
    bool disabled_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class OneofConstraints final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.OneofConstraints) */ {
 public:
  inline OneofConstraints() : OneofConstraints(nullptr) {}
  ~OneofConstraints() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OneofConstraints(::google::protobuf::internal::ConstantInitialized);

  OneofConstraints(const OneofConstraints& from);
  OneofConstraints(OneofConstraints&& from) noexcept
    : OneofConstraints() {
    *this = ::std::move(from);
  }

  inline OneofConstraints& operator=(const OneofConstraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline OneofConstraints& operator=(OneofConstraints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OneofConstraints& default_instance() {
    return *internal_default_instance();
  }
  static inline const OneofConstraints* internal_default_instance() {
    return reinterpret_cast<const OneofConstraints*>(
               &_OneofConstraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(OneofConstraints& a, OneofConstraints& b) {
    a.Swap(&b);
  }
  inline void Swap(OneofConstraints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OneofConstraints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OneofConstraints* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OneofConstraints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OneofConstraints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OneofConstraints& from) {
    OneofConstraints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OneofConstraints* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.OneofConstraints";
  }
  protected:
  explicit OneofConstraints(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredFieldNumber = 1,
  };
  // optional bool required = 1 [json_name = "required"];
  bool has_required() const;
  void clear_required() ;
  bool required() const;
  void set_required(bool value);

  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);

  public:
  // @@protoc_insertion_point(class_scope:buf.validate.OneofConstraints)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool required_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class FieldConstraints final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.FieldConstraints) */ {
 public:
  inline FieldConstraints() : FieldConstraints(nullptr) {}
  ~FieldConstraints() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FieldConstraints(::google::protobuf::internal::ConstantInitialized);

  FieldConstraints(const FieldConstraints& from);
  FieldConstraints(FieldConstraints&& from) noexcept
    : FieldConstraints() {
    *this = ::std::move(from);
  }

  inline FieldConstraints& operator=(const FieldConstraints& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldConstraints& operator=(FieldConstraints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldConstraints& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kFloat = 1,
    kDouble = 2,
    kInt32 = 3,
    kInt64 = 4,
    kUint32 = 5,
    kUint64 = 6,
    kSint32 = 7,
    kSint64 = 8,
    kFixed32 = 9,
    kFixed64 = 10,
    kSfixed32 = 11,
    kSfixed64 = 12,
    kBool = 13,
    kString = 14,
    kBytes = 15,
    kEnum = 16,
    kRepeated = 18,
    kMap = 19,
    kAny = 20,
    kDuration = 21,
    kTimestamp = 22,
    TYPE_NOT_SET = 0,
  };

  static inline const FieldConstraints* internal_default_instance() {
    return reinterpret_cast<const FieldConstraints*>(
               &_FieldConstraints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FieldConstraints& a, FieldConstraints& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldConstraints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldConstraints* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldConstraints* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldConstraints>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FieldConstraints& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FieldConstraints& from) {
    FieldConstraints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldConstraints* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.FieldConstraints";
  }
  protected:
  explicit FieldConstraints(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCelFieldNumber = 23,
    kSkippedFieldNumber = 24,
    kRequiredFieldNumber = 25,
    kIgnoreEmptyFieldNumber = 26,
    kFloatFieldNumber = 1,
    kDoubleFieldNumber = 2,
    kInt32FieldNumber = 3,
    kInt64FieldNumber = 4,
    kUint32FieldNumber = 5,
    kUint64FieldNumber = 6,
    kSint32FieldNumber = 7,
    kSint64FieldNumber = 8,
    kFixed32FieldNumber = 9,
    kFixed64FieldNumber = 10,
    kSfixed32FieldNumber = 11,
    kSfixed64FieldNumber = 12,
    kBoolFieldNumber = 13,
    kStringFieldNumber = 14,
    kBytesFieldNumber = 15,
    kEnumFieldNumber = 16,
    kRepeatedFieldNumber = 18,
    kMapFieldNumber = 19,
    kAnyFieldNumber = 20,
    kDurationFieldNumber = 21,
    kTimestampFieldNumber = 22,
  };
  // repeated .buf.validate.Constraint cel = 23 [json_name = "cel"];
  int cel_size() const;
  private:
  int _internal_cel_size() const;

  public:
  void clear_cel() ;
  ::buf::validate::Constraint* mutable_cel(int index);
  ::google::protobuf::RepeatedPtrField< ::buf::validate::Constraint >*
      mutable_cel();
  private:
  const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>& _internal_cel() const;
  ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>* _internal_mutable_cel();
  public:
  const ::buf::validate::Constraint& cel(int index) const;
  ::buf::validate::Constraint* add_cel();
  const ::google::protobuf::RepeatedPtrField< ::buf::validate::Constraint >&
      cel() const;
  // bool skipped = 24 [json_name = "skipped"];
  void clear_skipped() ;
  bool skipped() const;
  void set_skipped(bool value);

  private:
  bool _internal_skipped() const;
  void _internal_set_skipped(bool value);

  public:
  // bool required = 25 [json_name = "required"];
  void clear_required() ;
  bool required() const;
  void set_required(bool value);

  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);

  public:
  // bool ignore_empty = 26 [json_name = "ignoreEmpty"];
  void clear_ignore_empty() ;
  bool ignore_empty() const;
  void set_ignore_empty(bool value);

  private:
  bool _internal_ignore_empty() const;
  void _internal_set_ignore_empty(bool value);

  public:
  // .buf.validate.FloatRules float = 1 [json_name = "float"];
  bool has_float_() const;
  private:
  bool _internal_has_float_() const;

  public:
  void clear_float_() ;
  const ::buf::validate::FloatRules& float_() const;
  PROTOBUF_NODISCARD ::buf::validate::FloatRules* release_float_();
  ::buf::validate::FloatRules* mutable_float_();
  void set_allocated_float_(::buf::validate::FloatRules* value);
  void unsafe_arena_set_allocated_float_(::buf::validate::FloatRules* value);
  ::buf::validate::FloatRules* unsafe_arena_release_float_();

  private:
  const ::buf::validate::FloatRules& _internal_float_() const;
  ::buf::validate::FloatRules* _internal_mutable_float_();

  public:
  // .buf.validate.DoubleRules double = 2 [json_name = "double"];
  bool has_double_() const;
  private:
  bool _internal_has_double_() const;

  public:
  void clear_double_() ;
  const ::buf::validate::DoubleRules& double_() const;
  PROTOBUF_NODISCARD ::buf::validate::DoubleRules* release_double_();
  ::buf::validate::DoubleRules* mutable_double_();
  void set_allocated_double_(::buf::validate::DoubleRules* value);
  void unsafe_arena_set_allocated_double_(::buf::validate::DoubleRules* value);
  ::buf::validate::DoubleRules* unsafe_arena_release_double_();

  private:
  const ::buf::validate::DoubleRules& _internal_double_() const;
  ::buf::validate::DoubleRules* _internal_mutable_double_();

  public:
  // .buf.validate.Int32Rules int32 = 3 [json_name = "int32"];
  bool has_int32() const;
  private:
  bool _internal_has_int32() const;

  public:
  void clear_int32() ;
  const ::buf::validate::Int32Rules& int32() const;
  PROTOBUF_NODISCARD ::buf::validate::Int32Rules* release_int32();
  ::buf::validate::Int32Rules* mutable_int32();
  void set_allocated_int32(::buf::validate::Int32Rules* value);
  void unsafe_arena_set_allocated_int32(::buf::validate::Int32Rules* value);
  ::buf::validate::Int32Rules* unsafe_arena_release_int32();

  private:
  const ::buf::validate::Int32Rules& _internal_int32() const;
  ::buf::validate::Int32Rules* _internal_mutable_int32();

  public:
  // .buf.validate.Int64Rules int64 = 4 [json_name = "int64"];
  bool has_int64() const;
  private:
  bool _internal_has_int64() const;

  public:
  void clear_int64() ;
  const ::buf::validate::Int64Rules& int64() const;
  PROTOBUF_NODISCARD ::buf::validate::Int64Rules* release_int64();
  ::buf::validate::Int64Rules* mutable_int64();
  void set_allocated_int64(::buf::validate::Int64Rules* value);
  void unsafe_arena_set_allocated_int64(::buf::validate::Int64Rules* value);
  ::buf::validate::Int64Rules* unsafe_arena_release_int64();

  private:
  const ::buf::validate::Int64Rules& _internal_int64() const;
  ::buf::validate::Int64Rules* _internal_mutable_int64();

  public:
  // .buf.validate.UInt32Rules uint32 = 5 [json_name = "uint32"];
  bool has_uint32() const;
  private:
  bool _internal_has_uint32() const;

  public:
  void clear_uint32() ;
  const ::buf::validate::UInt32Rules& uint32() const;
  PROTOBUF_NODISCARD ::buf::validate::UInt32Rules* release_uint32();
  ::buf::validate::UInt32Rules* mutable_uint32();
  void set_allocated_uint32(::buf::validate::UInt32Rules* value);
  void unsafe_arena_set_allocated_uint32(::buf::validate::UInt32Rules* value);
  ::buf::validate::UInt32Rules* unsafe_arena_release_uint32();

  private:
  const ::buf::validate::UInt32Rules& _internal_uint32() const;
  ::buf::validate::UInt32Rules* _internal_mutable_uint32();

  public:
  // .buf.validate.UInt64Rules uint64 = 6 [json_name = "uint64"];
  bool has_uint64() const;
  private:
  bool _internal_has_uint64() const;

  public:
  void clear_uint64() ;
  const ::buf::validate::UInt64Rules& uint64() const;
  PROTOBUF_NODISCARD ::buf::validate::UInt64Rules* release_uint64();
  ::buf::validate::UInt64Rules* mutable_uint64();
  void set_allocated_uint64(::buf::validate::UInt64Rules* value);
  void unsafe_arena_set_allocated_uint64(::buf::validate::UInt64Rules* value);
  ::buf::validate::UInt64Rules* unsafe_arena_release_uint64();

  private:
  const ::buf::validate::UInt64Rules& _internal_uint64() const;
  ::buf::validate::UInt64Rules* _internal_mutable_uint64();

  public:
  // .buf.validate.SInt32Rules sint32 = 7 [json_name = "sint32"];
  bool has_sint32() const;
  private:
  bool _internal_has_sint32() const;

  public:
  void clear_sint32() ;
  const ::buf::validate::SInt32Rules& sint32() const;
  PROTOBUF_NODISCARD ::buf::validate::SInt32Rules* release_sint32();
  ::buf::validate::SInt32Rules* mutable_sint32();
  void set_allocated_sint32(::buf::validate::SInt32Rules* value);
  void unsafe_arena_set_allocated_sint32(::buf::validate::SInt32Rules* value);
  ::buf::validate::SInt32Rules* unsafe_arena_release_sint32();

  private:
  const ::buf::validate::SInt32Rules& _internal_sint32() const;
  ::buf::validate::SInt32Rules* _internal_mutable_sint32();

  public:
  // .buf.validate.SInt64Rules sint64 = 8 [json_name = "sint64"];
  bool has_sint64() const;
  private:
  bool _internal_has_sint64() const;

  public:
  void clear_sint64() ;
  const ::buf::validate::SInt64Rules& sint64() const;
  PROTOBUF_NODISCARD ::buf::validate::SInt64Rules* release_sint64();
  ::buf::validate::SInt64Rules* mutable_sint64();
  void set_allocated_sint64(::buf::validate::SInt64Rules* value);
  void unsafe_arena_set_allocated_sint64(::buf::validate::SInt64Rules* value);
  ::buf::validate::SInt64Rules* unsafe_arena_release_sint64();

  private:
  const ::buf::validate::SInt64Rules& _internal_sint64() const;
  ::buf::validate::SInt64Rules* _internal_mutable_sint64();

  public:
  // .buf.validate.Fixed32Rules fixed32 = 9 [json_name = "fixed32"];
  bool has_fixed32() const;
  private:
  bool _internal_has_fixed32() const;

  public:
  void clear_fixed32() ;
  const ::buf::validate::Fixed32Rules& fixed32() const;
  PROTOBUF_NODISCARD ::buf::validate::Fixed32Rules* release_fixed32();
  ::buf::validate::Fixed32Rules* mutable_fixed32();
  void set_allocated_fixed32(::buf::validate::Fixed32Rules* value);
  void unsafe_arena_set_allocated_fixed32(::buf::validate::Fixed32Rules* value);
  ::buf::validate::Fixed32Rules* unsafe_arena_release_fixed32();

  private:
  const ::buf::validate::Fixed32Rules& _internal_fixed32() const;
  ::buf::validate::Fixed32Rules* _internal_mutable_fixed32();

  public:
  // .buf.validate.Fixed64Rules fixed64 = 10 [json_name = "fixed64"];
  bool has_fixed64() const;
  private:
  bool _internal_has_fixed64() const;

  public:
  void clear_fixed64() ;
  const ::buf::validate::Fixed64Rules& fixed64() const;
  PROTOBUF_NODISCARD ::buf::validate::Fixed64Rules* release_fixed64();
  ::buf::validate::Fixed64Rules* mutable_fixed64();
  void set_allocated_fixed64(::buf::validate::Fixed64Rules* value);
  void unsafe_arena_set_allocated_fixed64(::buf::validate::Fixed64Rules* value);
  ::buf::validate::Fixed64Rules* unsafe_arena_release_fixed64();

  private:
  const ::buf::validate::Fixed64Rules& _internal_fixed64() const;
  ::buf::validate::Fixed64Rules* _internal_mutable_fixed64();

  public:
  // .buf.validate.SFixed32Rules sfixed32 = 11 [json_name = "sfixed32"];
  bool has_sfixed32() const;
  private:
  bool _internal_has_sfixed32() const;

  public:
  void clear_sfixed32() ;
  const ::buf::validate::SFixed32Rules& sfixed32() const;
  PROTOBUF_NODISCARD ::buf::validate::SFixed32Rules* release_sfixed32();
  ::buf::validate::SFixed32Rules* mutable_sfixed32();
  void set_allocated_sfixed32(::buf::validate::SFixed32Rules* value);
  void unsafe_arena_set_allocated_sfixed32(::buf::validate::SFixed32Rules* value);
  ::buf::validate::SFixed32Rules* unsafe_arena_release_sfixed32();

  private:
  const ::buf::validate::SFixed32Rules& _internal_sfixed32() const;
  ::buf::validate::SFixed32Rules* _internal_mutable_sfixed32();

  public:
  // .buf.validate.SFixed64Rules sfixed64 = 12 [json_name = "sfixed64"];
  bool has_sfixed64() const;
  private:
  bool _internal_has_sfixed64() const;

  public:
  void clear_sfixed64() ;
  const ::buf::validate::SFixed64Rules& sfixed64() const;
  PROTOBUF_NODISCARD ::buf::validate::SFixed64Rules* release_sfixed64();
  ::buf::validate::SFixed64Rules* mutable_sfixed64();
  void set_allocated_sfixed64(::buf::validate::SFixed64Rules* value);
  void unsafe_arena_set_allocated_sfixed64(::buf::validate::SFixed64Rules* value);
  ::buf::validate::SFixed64Rules* unsafe_arena_release_sfixed64();

  private:
  const ::buf::validate::SFixed64Rules& _internal_sfixed64() const;
  ::buf::validate::SFixed64Rules* _internal_mutable_sfixed64();

  public:
  // .buf.validate.BoolRules bool = 13 [json_name = "bool"];
  bool has_bool_() const;
  private:
  bool _internal_has_bool_() const;

  public:
  void clear_bool_() ;
  const ::buf::validate::BoolRules& bool_() const;
  PROTOBUF_NODISCARD ::buf::validate::BoolRules* release_bool_();
  ::buf::validate::BoolRules* mutable_bool_();
  void set_allocated_bool_(::buf::validate::BoolRules* value);
  void unsafe_arena_set_allocated_bool_(::buf::validate::BoolRules* value);
  ::buf::validate::BoolRules* unsafe_arena_release_bool_();

  private:
  const ::buf::validate::BoolRules& _internal_bool_() const;
  ::buf::validate::BoolRules* _internal_mutable_bool_();

  public:
  // .buf.validate.StringRules string = 14 [json_name = "string"];
  bool has_string() const;
  private:
  bool _internal_has_string() const;

  public:
  void clear_string() ;
  const ::buf::validate::StringRules& string() const;
  PROTOBUF_NODISCARD ::buf::validate::StringRules* release_string();
  ::buf::validate::StringRules* mutable_string();
  void set_allocated_string(::buf::validate::StringRules* value);
  void unsafe_arena_set_allocated_string(::buf::validate::StringRules* value);
  ::buf::validate::StringRules* unsafe_arena_release_string();

  private:
  const ::buf::validate::StringRules& _internal_string() const;
  ::buf::validate::StringRules* _internal_mutable_string();

  public:
  // .buf.validate.BytesRules bytes = 15 [json_name = "bytes"];
  bool has_bytes() const;
  private:
  bool _internal_has_bytes() const;

  public:
  void clear_bytes() ;
  const ::buf::validate::BytesRules& bytes() const;
  PROTOBUF_NODISCARD ::buf::validate::BytesRules* release_bytes();
  ::buf::validate::BytesRules* mutable_bytes();
  void set_allocated_bytes(::buf::validate::BytesRules* value);
  void unsafe_arena_set_allocated_bytes(::buf::validate::BytesRules* value);
  ::buf::validate::BytesRules* unsafe_arena_release_bytes();

  private:
  const ::buf::validate::BytesRules& _internal_bytes() const;
  ::buf::validate::BytesRules* _internal_mutable_bytes();

  public:
  // .buf.validate.EnumRules enum = 16 [json_name = "enum"];
  bool has_enum_() const;
  private:
  bool _internal_has_enum_() const;

  public:
  void clear_enum_() ;
  const ::buf::validate::EnumRules& enum_() const;
  PROTOBUF_NODISCARD ::buf::validate::EnumRules* release_enum_();
  ::buf::validate::EnumRules* mutable_enum_();
  void set_allocated_enum_(::buf::validate::EnumRules* value);
  void unsafe_arena_set_allocated_enum_(::buf::validate::EnumRules* value);
  ::buf::validate::EnumRules* unsafe_arena_release_enum_();

  private:
  const ::buf::validate::EnumRules& _internal_enum_() const;
  ::buf::validate::EnumRules* _internal_mutable_enum_();

  public:
  // .buf.validate.RepeatedRules repeated = 18 [json_name = "repeated"];
  bool has_repeated() const;
  private:
  bool _internal_has_repeated() const;

  public:
  void clear_repeated() ;
  const ::buf::validate::RepeatedRules& repeated() const;
  PROTOBUF_NODISCARD ::buf::validate::RepeatedRules* release_repeated();
  ::buf::validate::RepeatedRules* mutable_repeated();
  void set_allocated_repeated(::buf::validate::RepeatedRules* value);
  void unsafe_arena_set_allocated_repeated(::buf::validate::RepeatedRules* value);
  ::buf::validate::RepeatedRules* unsafe_arena_release_repeated();

  private:
  const ::buf::validate::RepeatedRules& _internal_repeated() const;
  ::buf::validate::RepeatedRules* _internal_mutable_repeated();

  public:
  // .buf.validate.MapRules map = 19 [json_name = "map"];
  bool has_map() const;
  private:
  bool _internal_has_map() const;

  public:
  void clear_map() ;
  const ::buf::validate::MapRules& map() const;
  PROTOBUF_NODISCARD ::buf::validate::MapRules* release_map();
  ::buf::validate::MapRules* mutable_map();
  void set_allocated_map(::buf::validate::MapRules* value);
  void unsafe_arena_set_allocated_map(::buf::validate::MapRules* value);
  ::buf::validate::MapRules* unsafe_arena_release_map();

  private:
  const ::buf::validate::MapRules& _internal_map() const;
  ::buf::validate::MapRules* _internal_mutable_map();

  public:
  // .buf.validate.AnyRules any = 20 [json_name = "any"];
  bool has_any() const;
  private:
  bool _internal_has_any() const;

  public:
  void clear_any() ;
  const ::buf::validate::AnyRules& any() const;
  PROTOBUF_NODISCARD ::buf::validate::AnyRules* release_any();
  ::buf::validate::AnyRules* mutable_any();
  void set_allocated_any(::buf::validate::AnyRules* value);
  void unsafe_arena_set_allocated_any(::buf::validate::AnyRules* value);
  ::buf::validate::AnyRules* unsafe_arena_release_any();

  private:
  const ::buf::validate::AnyRules& _internal_any() const;
  ::buf::validate::AnyRules* _internal_mutable_any();

  public:
  // .buf.validate.DurationRules duration = 21 [json_name = "duration"];
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;

  public:
  void clear_duration() ;
  const ::buf::validate::DurationRules& duration() const;
  PROTOBUF_NODISCARD ::buf::validate::DurationRules* release_duration();
  ::buf::validate::DurationRules* mutable_duration();
  void set_allocated_duration(::buf::validate::DurationRules* value);
  void unsafe_arena_set_allocated_duration(::buf::validate::DurationRules* value);
  ::buf::validate::DurationRules* unsafe_arena_release_duration();

  private:
  const ::buf::validate::DurationRules& _internal_duration() const;
  ::buf::validate::DurationRules* _internal_mutable_duration();

  public:
  // .buf.validate.TimestampRules timestamp = 22 [json_name = "timestamp"];
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;

  public:
  void clear_timestamp() ;
  const ::buf::validate::TimestampRules& timestamp() const;
  PROTOBUF_NODISCARD ::buf::validate::TimestampRules* release_timestamp();
  ::buf::validate::TimestampRules* mutable_timestamp();
  void set_allocated_timestamp(::buf::validate::TimestampRules* value);
  void unsafe_arena_set_allocated_timestamp(::buf::validate::TimestampRules* value);
  ::buf::validate::TimestampRules* unsafe_arena_release_timestamp();

  private:
  const ::buf::validate::TimestampRules& _internal_timestamp() const;
  ::buf::validate::TimestampRules* _internal_mutable_timestamp();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.FieldConstraints)
 private:
  class _Internal;
  void set_has_float_();
  void set_has_double_();
  void set_has_int32();
  void set_has_int64();
  void set_has_uint32();
  void set_has_uint64();
  void set_has_sint32();
  void set_has_sint64();
  void set_has_fixed32();
  void set_has_fixed64();
  void set_has_sfixed32();
  void set_has_sfixed64();
  void set_has_bool_();
  void set_has_string();
  void set_has_bytes();
  void set_has_enum_();
  void set_has_repeated();
  void set_has_map();
  void set_has_any();
  void set_has_duration();
  void set_has_timestamp();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 25, 22, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::buf::validate::Constraint > cel_;
    bool skipped_;
    bool required_;
    bool ignore_empty_;
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::buf::validate::FloatRules* float__;
      ::buf::validate::DoubleRules* double__;
      ::buf::validate::Int32Rules* int32_;
      ::buf::validate::Int64Rules* int64_;
      ::buf::validate::UInt32Rules* uint32_;
      ::buf::validate::UInt64Rules* uint64_;
      ::buf::validate::SInt32Rules* sint32_;
      ::buf::validate::SInt64Rules* sint64_;
      ::buf::validate::Fixed32Rules* fixed32_;
      ::buf::validate::Fixed64Rules* fixed64_;
      ::buf::validate::SFixed32Rules* sfixed32_;
      ::buf::validate::SFixed64Rules* sfixed64_;
      ::buf::validate::BoolRules* bool__;
      ::buf::validate::StringRules* string_;
      ::buf::validate::BytesRules* bytes_;
      ::buf::validate::EnumRules* enum__;
      ::buf::validate::RepeatedRules* repeated_;
      ::buf::validate::MapRules* map_;
      ::buf::validate::AnyRules* any_;
      ::buf::validate::DurationRules* duration_;
      ::buf::validate::TimestampRules* timestamp_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class FloatRules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.FloatRules) */ {
 public:
  inline FloatRules() : FloatRules(nullptr) {}
  ~FloatRules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FloatRules(::google::protobuf::internal::ConstantInitialized);

  FloatRules(const FloatRules& from);
  FloatRules(FloatRules&& from) noexcept
    : FloatRules() {
    *this = ::std::move(from);
  }

  inline FloatRules& operator=(const FloatRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatRules& operator=(FloatRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatRules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const FloatRules* internal_default_instance() {
    return reinterpret_cast<const FloatRules*>(
               &_FloatRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FloatRules& a, FloatRules& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatRules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FloatRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FloatRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FloatRules& from) {
    FloatRules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatRules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.FloatRules";
  }
  protected:
  explicit FloatRules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kFiniteFieldNumber = 8,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated float in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  float in(int index) const;
  void set_in(int index, float value);
  void add_in(float value);
  const ::google::protobuf::RepeatedField<float>& in() const;
  ::google::protobuf::RepeatedField<float>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_in() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_in();

  public:
  // repeated float not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  float not_in(int index) const;
  void set_not_in(int index, float value);
  void add_not_in(float value);
  const ::google::protobuf::RepeatedField<float>& not_in() const;
  ::google::protobuf::RepeatedField<float>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_not_in();

  public:
  // optional float const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  float const_() const;
  void set_const_(float value);

  private:
  float _internal_const_() const;
  void _internal_set_const_(float value);

  public:
  // bool finite = 8 [json_name = "finite", (.buf.validate.priv.field) = {
  void clear_finite() ;
  bool finite() const;
  void set_finite(bool value);

  private:
  bool _internal_finite() const;
  void _internal_set_finite(bool value);

  public:
  // float lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  void clear_lt() ;
  float lt() const;
  void set_lt(float value);

  private:
  float _internal_lt() const;
  void _internal_set_lt(float value);

  public:
  // float lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  void clear_lte() ;
  float lte() const;
  void set_lte(float value);

  private:
  float _internal_lte() const;
  void _internal_set_lte(float value);

  public:
  // float gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  void clear_gt() ;
  float gt() const;
  void set_gt(float value);

  private:
  float _internal_gt() const;
  void _internal_set_gt(float value);

  public:
  // float gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  void clear_gte() ;
  float gte() const;
  void set_gte(float value);

  private:
  float _internal_gte() const;
  void _internal_set_gte(float value);

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.FloatRules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 8, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> in_;
    ::google::protobuf::RepeatedField<float> not_in_;
    float const__;
    bool finite_;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float lt_;
      float lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      float gt_;
      float gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class DoubleRules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.DoubleRules) */ {
 public:
  inline DoubleRules() : DoubleRules(nullptr) {}
  ~DoubleRules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DoubleRules(::google::protobuf::internal::ConstantInitialized);

  DoubleRules(const DoubleRules& from);
  DoubleRules(DoubleRules&& from) noexcept
    : DoubleRules() {
    *this = ::std::move(from);
  }

  inline DoubleRules& operator=(const DoubleRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleRules& operator=(DoubleRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleRules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const DoubleRules* internal_default_instance() {
    return reinterpret_cast<const DoubleRules*>(
               &_DoubleRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DoubleRules& a, DoubleRules& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleRules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DoubleRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DoubleRules& from) {
    DoubleRules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleRules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.DoubleRules";
  }
  protected:
  explicit DoubleRules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kFiniteFieldNumber = 8,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated double in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  double in(int index) const;
  void set_in(int index, double value);
  void add_in(double value);
  const ::google::protobuf::RepeatedField<double>& in() const;
  ::google::protobuf::RepeatedField<double>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_in() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_in();

  public:
  // repeated double not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  double not_in(int index) const;
  void set_not_in(int index, double value);
  void add_not_in(double value);
  const ::google::protobuf::RepeatedField<double>& not_in() const;
  ::google::protobuf::RepeatedField<double>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_not_in();

  public:
  // optional double const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  double const_() const;
  void set_const_(double value);

  private:
  double _internal_const_() const;
  void _internal_set_const_(double value);

  public:
  // bool finite = 8 [json_name = "finite", (.buf.validate.priv.field) = {
  void clear_finite() ;
  bool finite() const;
  void set_finite(bool value);

  private:
  bool _internal_finite() const;
  void _internal_set_finite(bool value);

  public:
  // double lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  void clear_lt() ;
  double lt() const;
  void set_lt(double value);

  private:
  double _internal_lt() const;
  void _internal_set_lt(double value);

  public:
  // double lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  void clear_lte() ;
  double lte() const;
  void set_lte(double value);

  private:
  double _internal_lte() const;
  void _internal_set_lte(double value);

  public:
  // double gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  void clear_gt() ;
  double gt() const;
  void set_gt(double value);

  private:
  double _internal_gt() const;
  void _internal_set_gt(double value);

  public:
  // double gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  void clear_gte() ;
  double gte() const;
  void set_gte(double value);

  private:
  double _internal_gte() const;
  void _internal_set_gte(double value);

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.DoubleRules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 8, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> in_;
    ::google::protobuf::RepeatedField<double> not_in_;
    double const__;
    bool finite_;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      double lt_;
      double lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      double gt_;
      double gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class Int32Rules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.Int32Rules) */ {
 public:
  inline Int32Rules() : Int32Rules(nullptr) {}
  ~Int32Rules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Int32Rules(::google::protobuf::internal::ConstantInitialized);

  Int32Rules(const Int32Rules& from);
  Int32Rules(Int32Rules&& from) noexcept
    : Int32Rules() {
    *this = ::std::move(from);
  }

  inline Int32Rules& operator=(const Int32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int32Rules& operator=(Int32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int32Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const Int32Rules* internal_default_instance() {
    return reinterpret_cast<const Int32Rules*>(
               &_Int32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Int32Rules& a, Int32Rules& b) {
    a.Swap(&b);
  }
  inline void Swap(Int32Rules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int32Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int32Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Int32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Int32Rules& from) {
    Int32Rules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int32Rules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.Int32Rules";
  }
  protected:
  explicit Int32Rules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated int32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int32_t in(int index) const;
  void set_in(int index, ::int32_t value);
  void add_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_in();

  public:
  // repeated int32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int32_t not_in(int index) const;
  void set_not_in(int index, ::int32_t value);
  void add_not_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_not_in();

  public:
  // optional int32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int32_t const_() const;
  void set_const_(::int32_t value);

  private:
  ::int32_t _internal_const_() const;
  void _internal_set_const_(::int32_t value);

  public:
  // int32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  void clear_lt() ;
  ::int32_t lt() const;
  void set_lt(::int32_t value);

  private:
  ::int32_t _internal_lt() const;
  void _internal_set_lt(::int32_t value);

  public:
  // int32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  void clear_lte() ;
  ::int32_t lte() const;
  void set_lte(::int32_t value);

  private:
  ::int32_t _internal_lte() const;
  void _internal_set_lte(::int32_t value);

  public:
  // int32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  void clear_gt() ;
  ::int32_t gt() const;
  void set_gt(::int32_t value);

  private:
  ::int32_t _internal_gt() const;
  void _internal_set_gt(::int32_t value);

  public:
  // int32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  void clear_gte() ;
  ::int32_t gte() const;
  void set_gte(::int32_t value);

  private:
  ::int32_t _internal_gte() const;
  void _internal_set_gte(::int32_t value);

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.Int32Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> in_;
    mutable ::google::protobuf::internal::CachedSize _in_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> not_in_;
    mutable ::google::protobuf::internal::CachedSize _not_in_cached_byte_size_;
    ::int32_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t lt_;
      ::int32_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t gt_;
      ::int32_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class Int64Rules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.Int64Rules) */ {
 public:
  inline Int64Rules() : Int64Rules(nullptr) {}
  ~Int64Rules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Int64Rules(::google::protobuf::internal::ConstantInitialized);

  Int64Rules(const Int64Rules& from);
  Int64Rules(Int64Rules&& from) noexcept
    : Int64Rules() {
    *this = ::std::move(from);
  }

  inline Int64Rules& operator=(const Int64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int64Rules& operator=(Int64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int64Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const Int64Rules* internal_default_instance() {
    return reinterpret_cast<const Int64Rules*>(
               &_Int64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Int64Rules& a, Int64Rules& b) {
    a.Swap(&b);
  }
  inline void Swap(Int64Rules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int64Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int64Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Int64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Int64Rules& from) {
    Int64Rules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int64Rules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.Int64Rules";
  }
  protected:
  explicit Int64Rules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated int64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int64_t in(int index) const;
  void set_in(int index, ::int64_t value);
  void add_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& in() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_in();

  public:
  // repeated int64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int64_t not_in(int index) const;
  void set_not_in(int index, ::int64_t value);
  void add_not_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_not_in();

  public:
  // optional int64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int64_t const_() const;
  void set_const_(::int64_t value);

  private:
  ::int64_t _internal_const_() const;
  void _internal_set_const_(::int64_t value);

  public:
  // int64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  void clear_lt() ;
  ::int64_t lt() const;
  void set_lt(::int64_t value);

  private:
  ::int64_t _internal_lt() const;
  void _internal_set_lt(::int64_t value);

  public:
  // int64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  void clear_lte() ;
  ::int64_t lte() const;
  void set_lte(::int64_t value);

  private:
  ::int64_t _internal_lte() const;
  void _internal_set_lte(::int64_t value);

  public:
  // int64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  void clear_gt() ;
  ::int64_t gt() const;
  void set_gt(::int64_t value);

  private:
  ::int64_t _internal_gt() const;
  void _internal_set_gt(::int64_t value);

  public:
  // int64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  void clear_gte() ;
  ::int64_t gte() const;
  void set_gte(::int64_t value);

  private:
  ::int64_t _internal_gte() const;
  void _internal_set_gte(::int64_t value);

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.Int64Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> in_;
    mutable ::google::protobuf::internal::CachedSize _in_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> not_in_;
    mutable ::google::protobuf::internal::CachedSize _not_in_cached_byte_size_;
    ::int64_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t lt_;
      ::int64_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t gt_;
      ::int64_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class UInt32Rules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.UInt32Rules) */ {
 public:
  inline UInt32Rules() : UInt32Rules(nullptr) {}
  ~UInt32Rules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UInt32Rules(::google::protobuf::internal::ConstantInitialized);

  UInt32Rules(const UInt32Rules& from);
  UInt32Rules(UInt32Rules&& from) noexcept
    : UInt32Rules() {
    *this = ::std::move(from);
  }

  inline UInt32Rules& operator=(const UInt32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline UInt32Rules& operator=(UInt32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UInt32Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const UInt32Rules* internal_default_instance() {
    return reinterpret_cast<const UInt32Rules*>(
               &_UInt32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UInt32Rules& a, UInt32Rules& b) {
    a.Swap(&b);
  }
  inline void Swap(UInt32Rules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UInt32Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UInt32Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UInt32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UInt32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UInt32Rules& from) {
    UInt32Rules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UInt32Rules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.UInt32Rules";
  }
  protected:
  explicit UInt32Rules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated uint32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::uint32_t in(int index) const;
  void set_in(int index, ::uint32_t value);
  void add_in(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_in();

  public:
  // repeated uint32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::uint32_t not_in(int index) const;
  void set_not_in(int index, ::uint32_t value);
  void add_not_in(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_not_in();

  public:
  // optional uint32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  ::uint32_t const_() const;
  void set_const_(::uint32_t value);

  private:
  ::uint32_t _internal_const_() const;
  void _internal_set_const_(::uint32_t value);

  public:
  // uint32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  void clear_lt() ;
  ::uint32_t lt() const;
  void set_lt(::uint32_t value);

  private:
  ::uint32_t _internal_lt() const;
  void _internal_set_lt(::uint32_t value);

  public:
  // uint32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  void clear_lte() ;
  ::uint32_t lte() const;
  void set_lte(::uint32_t value);

  private:
  ::uint32_t _internal_lte() const;
  void _internal_set_lte(::uint32_t value);

  public:
  // uint32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  void clear_gt() ;
  ::uint32_t gt() const;
  void set_gt(::uint32_t value);

  private:
  ::uint32_t _internal_gt() const;
  void _internal_set_gt(::uint32_t value);

  public:
  // uint32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  void clear_gte() ;
  ::uint32_t gte() const;
  void set_gte(::uint32_t value);

  private:
  ::uint32_t _internal_gte() const;
  void _internal_set_gte(::uint32_t value);

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.UInt32Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> in_;
    mutable ::google::protobuf::internal::CachedSize _in_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint32_t> not_in_;
    mutable ::google::protobuf::internal::CachedSize _not_in_cached_byte_size_;
    ::uint32_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t lt_;
      ::uint32_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t gt_;
      ::uint32_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class UInt64Rules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.UInt64Rules) */ {
 public:
  inline UInt64Rules() : UInt64Rules(nullptr) {}
  ~UInt64Rules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UInt64Rules(::google::protobuf::internal::ConstantInitialized);

  UInt64Rules(const UInt64Rules& from);
  UInt64Rules(UInt64Rules&& from) noexcept
    : UInt64Rules() {
    *this = ::std::move(from);
  }

  inline UInt64Rules& operator=(const UInt64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline UInt64Rules& operator=(UInt64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UInt64Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const UInt64Rules* internal_default_instance() {
    return reinterpret_cast<const UInt64Rules*>(
               &_UInt64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UInt64Rules& a, UInt64Rules& b) {
    a.Swap(&b);
  }
  inline void Swap(UInt64Rules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UInt64Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UInt64Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UInt64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UInt64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UInt64Rules& from) {
    UInt64Rules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UInt64Rules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.UInt64Rules";
  }
  protected:
  explicit UInt64Rules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated uint64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::uint64_t in(int index) const;
  void set_in(int index, ::uint64_t value);
  void add_in(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_in();

  public:
  // repeated uint64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::uint64_t not_in(int index) const;
  void set_not_in(int index, ::uint64_t value);
  void add_not_in(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_not_in();

  public:
  // optional uint64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  ::uint64_t const_() const;
  void set_const_(::uint64_t value);

  private:
  ::uint64_t _internal_const_() const;
  void _internal_set_const_(::uint64_t value);

  public:
  // uint64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  void clear_lt() ;
  ::uint64_t lt() const;
  void set_lt(::uint64_t value);

  private:
  ::uint64_t _internal_lt() const;
  void _internal_set_lt(::uint64_t value);

  public:
  // uint64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  void clear_lte() ;
  ::uint64_t lte() const;
  void set_lte(::uint64_t value);

  private:
  ::uint64_t _internal_lte() const;
  void _internal_set_lte(::uint64_t value);

  public:
  // uint64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  void clear_gt() ;
  ::uint64_t gt() const;
  void set_gt(::uint64_t value);

  private:
  ::uint64_t _internal_gt() const;
  void _internal_set_gt(::uint64_t value);

  public:
  // uint64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  void clear_gte() ;
  ::uint64_t gte() const;
  void set_gte(::uint64_t value);

  private:
  ::uint64_t _internal_gte() const;
  void _internal_set_gte(::uint64_t value);

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.UInt64Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint64_t> in_;
    mutable ::google::protobuf::internal::CachedSize _in_cached_byte_size_;
    ::google::protobuf::RepeatedField<::uint64_t> not_in_;
    mutable ::google::protobuf::internal::CachedSize _not_in_cached_byte_size_;
    ::uint64_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t lt_;
      ::uint64_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t gt_;
      ::uint64_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class SInt32Rules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.SInt32Rules) */ {
 public:
  inline SInt32Rules() : SInt32Rules(nullptr) {}
  ~SInt32Rules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SInt32Rules(::google::protobuf::internal::ConstantInitialized);

  SInt32Rules(const SInt32Rules& from);
  SInt32Rules(SInt32Rules&& from) noexcept
    : SInt32Rules() {
    *this = ::std::move(from);
  }

  inline SInt32Rules& operator=(const SInt32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline SInt32Rules& operator=(SInt32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SInt32Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const SInt32Rules* internal_default_instance() {
    return reinterpret_cast<const SInt32Rules*>(
               &_SInt32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SInt32Rules& a, SInt32Rules& b) {
    a.Swap(&b);
  }
  inline void Swap(SInt32Rules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SInt32Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SInt32Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SInt32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SInt32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SInt32Rules& from) {
    SInt32Rules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SInt32Rules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.SInt32Rules";
  }
  protected:
  explicit SInt32Rules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated sint32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int32_t in(int index) const;
  void set_in(int index, ::int32_t value);
  void add_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_in();

  public:
  // repeated sint32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int32_t not_in(int index) const;
  void set_not_in(int index, ::int32_t value);
  void add_not_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_not_in();

  public:
  // optional sint32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int32_t const_() const;
  void set_const_(::int32_t value);

  private:
  ::int32_t _internal_const_() const;
  void _internal_set_const_(::int32_t value);

  public:
  // sint32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  void clear_lt() ;
  ::int32_t lt() const;
  void set_lt(::int32_t value);

  private:
  ::int32_t _internal_lt() const;
  void _internal_set_lt(::int32_t value);

  public:
  // sint32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  void clear_lte() ;
  ::int32_t lte() const;
  void set_lte(::int32_t value);

  private:
  ::int32_t _internal_lte() const;
  void _internal_set_lte(::int32_t value);

  public:
  // sint32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  void clear_gt() ;
  ::int32_t gt() const;
  void set_gt(::int32_t value);

  private:
  ::int32_t _internal_gt() const;
  void _internal_set_gt(::int32_t value);

  public:
  // sint32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  void clear_gte() ;
  ::int32_t gte() const;
  void set_gte(::int32_t value);

  private:
  ::int32_t _internal_gte() const;
  void _internal_set_gte(::int32_t value);

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.SInt32Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> in_;
    mutable ::google::protobuf::internal::CachedSize _in_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> not_in_;
    mutable ::google::protobuf::internal::CachedSize _not_in_cached_byte_size_;
    ::int32_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t lt_;
      ::int32_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t gt_;
      ::int32_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class SInt64Rules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.SInt64Rules) */ {
 public:
  inline SInt64Rules() : SInt64Rules(nullptr) {}
  ~SInt64Rules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SInt64Rules(::google::protobuf::internal::ConstantInitialized);

  SInt64Rules(const SInt64Rules& from);
  SInt64Rules(SInt64Rules&& from) noexcept
    : SInt64Rules() {
    *this = ::std::move(from);
  }

  inline SInt64Rules& operator=(const SInt64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline SInt64Rules& operator=(SInt64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SInt64Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const SInt64Rules* internal_default_instance() {
    return reinterpret_cast<const SInt64Rules*>(
               &_SInt64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SInt64Rules& a, SInt64Rules& b) {
    a.Swap(&b);
  }
  inline void Swap(SInt64Rules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SInt64Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SInt64Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SInt64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SInt64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SInt64Rules& from) {
    SInt64Rules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SInt64Rules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.SInt64Rules";
  }
  protected:
  explicit SInt64Rules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated sint64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int64_t in(int index) const;
  void set_in(int index, ::int64_t value);
  void add_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& in() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_in();

  public:
  // repeated sint64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int64_t not_in(int index) const;
  void set_not_in(int index, ::int64_t value);
  void add_not_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_not_in();

  public:
  // optional sint64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int64_t const_() const;
  void set_const_(::int64_t value);

  private:
  ::int64_t _internal_const_() const;
  void _internal_set_const_(::int64_t value);

  public:
  // sint64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  void clear_lt() ;
  ::int64_t lt() const;
  void set_lt(::int64_t value);

  private:
  ::int64_t _internal_lt() const;
  void _internal_set_lt(::int64_t value);

  public:
  // sint64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  void clear_lte() ;
  ::int64_t lte() const;
  void set_lte(::int64_t value);

  private:
  ::int64_t _internal_lte() const;
  void _internal_set_lte(::int64_t value);

  public:
  // sint64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  void clear_gt() ;
  ::int64_t gt() const;
  void set_gt(::int64_t value);

  private:
  ::int64_t _internal_gt() const;
  void _internal_set_gt(::int64_t value);

  public:
  // sint64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  void clear_gte() ;
  ::int64_t gte() const;
  void set_gte(::int64_t value);

  private:
  ::int64_t _internal_gte() const;
  void _internal_set_gte(::int64_t value);

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.SInt64Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> in_;
    mutable ::google::protobuf::internal::CachedSize _in_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int64_t> not_in_;
    mutable ::google::protobuf::internal::CachedSize _not_in_cached_byte_size_;
    ::int64_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t lt_;
      ::int64_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t gt_;
      ::int64_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class Fixed32Rules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.Fixed32Rules) */ {
 public:
  inline Fixed32Rules() : Fixed32Rules(nullptr) {}
  ~Fixed32Rules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Fixed32Rules(::google::protobuf::internal::ConstantInitialized);

  Fixed32Rules(const Fixed32Rules& from);
  Fixed32Rules(Fixed32Rules&& from) noexcept
    : Fixed32Rules() {
    *this = ::std::move(from);
  }

  inline Fixed32Rules& operator=(const Fixed32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fixed32Rules& operator=(Fixed32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fixed32Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const Fixed32Rules* internal_default_instance() {
    return reinterpret_cast<const Fixed32Rules*>(
               &_Fixed32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Fixed32Rules& a, Fixed32Rules& b) {
    a.Swap(&b);
  }
  inline void Swap(Fixed32Rules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fixed32Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fixed32Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fixed32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Fixed32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Fixed32Rules& from) {
    Fixed32Rules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fixed32Rules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.Fixed32Rules";
  }
  protected:
  explicit Fixed32Rules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated fixed32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::uint32_t in(int index) const;
  void set_in(int index, ::uint32_t value);
  void add_in(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_in();

  public:
  // repeated fixed32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::uint32_t not_in(int index) const;
  void set_not_in(int index, ::uint32_t value);
  void add_not_in(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_not_in();

  public:
  // optional fixed32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  ::uint32_t const_() const;
  void set_const_(::uint32_t value);

  private:
  ::uint32_t _internal_const_() const;
  void _internal_set_const_(::uint32_t value);

  public:
  // fixed32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  void clear_lt() ;
  ::uint32_t lt() const;
  void set_lt(::uint32_t value);

  private:
  ::uint32_t _internal_lt() const;
  void _internal_set_lt(::uint32_t value);

  public:
  // fixed32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  void clear_lte() ;
  ::uint32_t lte() const;
  void set_lte(::uint32_t value);

  private:
  ::uint32_t _internal_lte() const;
  void _internal_set_lte(::uint32_t value);

  public:
  // fixed32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  void clear_gt() ;
  ::uint32_t gt() const;
  void set_gt(::uint32_t value);

  private:
  ::uint32_t _internal_gt() const;
  void _internal_set_gt(::uint32_t value);

  public:
  // fixed32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  void clear_gte() ;
  ::uint32_t gte() const;
  void set_gte(::uint32_t value);

  private:
  ::uint32_t _internal_gte() const;
  void _internal_set_gte(::uint32_t value);

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.Fixed32Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> in_;
    ::google::protobuf::RepeatedField<::uint32_t> not_in_;
    ::uint32_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t lt_;
      ::uint32_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint32_t gt_;
      ::uint32_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class Fixed64Rules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.Fixed64Rules) */ {
 public:
  inline Fixed64Rules() : Fixed64Rules(nullptr) {}
  ~Fixed64Rules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Fixed64Rules(::google::protobuf::internal::ConstantInitialized);

  Fixed64Rules(const Fixed64Rules& from);
  Fixed64Rules(Fixed64Rules&& from) noexcept
    : Fixed64Rules() {
    *this = ::std::move(from);
  }

  inline Fixed64Rules& operator=(const Fixed64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fixed64Rules& operator=(Fixed64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fixed64Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const Fixed64Rules* internal_default_instance() {
    return reinterpret_cast<const Fixed64Rules*>(
               &_Fixed64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Fixed64Rules& a, Fixed64Rules& b) {
    a.Swap(&b);
  }
  inline void Swap(Fixed64Rules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fixed64Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fixed64Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fixed64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Fixed64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Fixed64Rules& from) {
    Fixed64Rules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fixed64Rules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.Fixed64Rules";
  }
  protected:
  explicit Fixed64Rules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated fixed64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::uint64_t in(int index) const;
  void set_in(int index, ::uint64_t value);
  void add_in(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_in();

  public:
  // repeated fixed64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::uint64_t not_in(int index) const;
  void set_not_in(int index, ::uint64_t value);
  void add_not_in(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_not_in();

  public:
  // optional fixed64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  ::uint64_t const_() const;
  void set_const_(::uint64_t value);

  private:
  ::uint64_t _internal_const_() const;
  void _internal_set_const_(::uint64_t value);

  public:
  // fixed64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  void clear_lt() ;
  ::uint64_t lt() const;
  void set_lt(::uint64_t value);

  private:
  ::uint64_t _internal_lt() const;
  void _internal_set_lt(::uint64_t value);

  public:
  // fixed64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  void clear_lte() ;
  ::uint64_t lte() const;
  void set_lte(::uint64_t value);

  private:
  ::uint64_t _internal_lte() const;
  void _internal_set_lte(::uint64_t value);

  public:
  // fixed64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  void clear_gt() ;
  ::uint64_t gt() const;
  void set_gt(::uint64_t value);

  private:
  ::uint64_t _internal_gt() const;
  void _internal_set_gt(::uint64_t value);

  public:
  // fixed64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  void clear_gte() ;
  ::uint64_t gte() const;
  void set_gte(::uint64_t value);

  private:
  ::uint64_t _internal_gte() const;
  void _internal_set_gte(::uint64_t value);

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.Fixed64Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint64_t> in_;
    ::google::protobuf::RepeatedField<::uint64_t> not_in_;
    ::uint64_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t lt_;
      ::uint64_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::uint64_t gt_;
      ::uint64_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class SFixed32Rules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.SFixed32Rules) */ {
 public:
  inline SFixed32Rules() : SFixed32Rules(nullptr) {}
  ~SFixed32Rules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SFixed32Rules(::google::protobuf::internal::ConstantInitialized);

  SFixed32Rules(const SFixed32Rules& from);
  SFixed32Rules(SFixed32Rules&& from) noexcept
    : SFixed32Rules() {
    *this = ::std::move(from);
  }

  inline SFixed32Rules& operator=(const SFixed32Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline SFixed32Rules& operator=(SFixed32Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SFixed32Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const SFixed32Rules* internal_default_instance() {
    return reinterpret_cast<const SFixed32Rules*>(
               &_SFixed32Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SFixed32Rules& a, SFixed32Rules& b) {
    a.Swap(&b);
  }
  inline void Swap(SFixed32Rules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SFixed32Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SFixed32Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SFixed32Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SFixed32Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SFixed32Rules& from) {
    SFixed32Rules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SFixed32Rules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.SFixed32Rules";
  }
  protected:
  explicit SFixed32Rules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated sfixed32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int32_t in(int index) const;
  void set_in(int index, ::int32_t value);
  void add_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_in();

  public:
  // repeated sfixed32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int32_t not_in(int index) const;
  void set_not_in(int index, ::int32_t value);
  void add_not_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_not_in();

  public:
  // optional sfixed32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int32_t const_() const;
  void set_const_(::int32_t value);

  private:
  ::int32_t _internal_const_() const;
  void _internal_set_const_(::int32_t value);

  public:
  // sfixed32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  void clear_lt() ;
  ::int32_t lt() const;
  void set_lt(::int32_t value);

  private:
  ::int32_t _internal_lt() const;
  void _internal_set_lt(::int32_t value);

  public:
  // sfixed32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  void clear_lte() ;
  ::int32_t lte() const;
  void set_lte(::int32_t value);

  private:
  ::int32_t _internal_lte() const;
  void _internal_set_lte(::int32_t value);

  public:
  // sfixed32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  void clear_gt() ;
  ::int32_t gt() const;
  void set_gt(::int32_t value);

  private:
  ::int32_t _internal_gt() const;
  void _internal_set_gt(::int32_t value);

  public:
  // sfixed32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  void clear_gte() ;
  ::int32_t gte() const;
  void set_gte(::int32_t value);

  private:
  ::int32_t _internal_gte() const;
  void _internal_set_gte(::int32_t value);

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.SFixed32Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> in_;
    ::google::protobuf::RepeatedField<::int32_t> not_in_;
    ::int32_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t lt_;
      ::int32_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int32_t gt_;
      ::int32_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class SFixed64Rules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.SFixed64Rules) */ {
 public:
  inline SFixed64Rules() : SFixed64Rules(nullptr) {}
  ~SFixed64Rules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SFixed64Rules(::google::protobuf::internal::ConstantInitialized);

  SFixed64Rules(const SFixed64Rules& from);
  SFixed64Rules(SFixed64Rules&& from) noexcept
    : SFixed64Rules() {
    *this = ::std::move(from);
  }

  inline SFixed64Rules& operator=(const SFixed64Rules& from) {
    CopyFrom(from);
    return *this;
  }
  inline SFixed64Rules& operator=(SFixed64Rules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SFixed64Rules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 2,
    kLte = 3,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 4,
    kGte = 5,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const SFixed64Rules* internal_default_instance() {
    return reinterpret_cast<const SFixed64Rules*>(
               &_SFixed64Rules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SFixed64Rules& a, SFixed64Rules& b) {
    a.Swap(&b);
  }
  inline void Swap(SFixed64Rules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SFixed64Rules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SFixed64Rules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SFixed64Rules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SFixed64Rules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SFixed64Rules& from) {
    SFixed64Rules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SFixed64Rules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.SFixed64Rules";
  }
  protected:
  explicit SFixed64Rules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 6,
    kNotInFieldNumber = 7,
    kConstFieldNumber = 1,
    kLtFieldNumber = 2,
    kLteFieldNumber = 3,
    kGtFieldNumber = 4,
    kGteFieldNumber = 5,
  };
  // repeated sfixed64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int64_t in(int index) const;
  void set_in(int index, ::int64_t value);
  void add_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& in() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_in();

  public:
  // repeated sfixed64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int64_t not_in(int index) const;
  void set_not_in(int index, ::int64_t value);
  void add_not_in(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_not_in();

  public:
  // optional sfixed64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int64_t const_() const;
  void set_const_(::int64_t value);

  private:
  ::int64_t _internal_const_() const;
  void _internal_set_const_(::int64_t value);

  public:
  // sfixed64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  void clear_lt() ;
  ::int64_t lt() const;
  void set_lt(::int64_t value);

  private:
  ::int64_t _internal_lt() const;
  void _internal_set_lt(::int64_t value);

  public:
  // sfixed64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  void clear_lte() ;
  ::int64_t lte() const;
  void set_lte(::int64_t value);

  private:
  ::int64_t _internal_lte() const;
  void _internal_set_lte(::int64_t value);

  public:
  // sfixed64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  void clear_gt() ;
  ::int64_t gt() const;
  void set_gt(::int64_t value);

  private:
  ::int64_t _internal_gt() const;
  void _internal_set_gt(::int64_t value);

  public:
  // sfixed64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  void clear_gte() ;
  ::int64_t gte() const;
  void set_gte(::int64_t value);

  private:
  ::int64_t _internal_gte() const;
  void _internal_set_gte(::int64_t value);

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.SFixed64Rules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> in_;
    ::google::protobuf::RepeatedField<::int64_t> not_in_;
    ::int64_t const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t lt_;
      ::int64_t lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t gt_;
      ::int64_t gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class BoolRules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.BoolRules) */ {
 public:
  inline BoolRules() : BoolRules(nullptr) {}
  ~BoolRules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BoolRules(::google::protobuf::internal::ConstantInitialized);

  BoolRules(const BoolRules& from);
  BoolRules(BoolRules&& from) noexcept
    : BoolRules() {
    *this = ::std::move(from);
  }

  inline BoolRules& operator=(const BoolRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolRules& operator=(BoolRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolRules& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolRules* internal_default_instance() {
    return reinterpret_cast<const BoolRules*>(
               &_BoolRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BoolRules& a, BoolRules& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolRules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BoolRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BoolRules& from) {
    BoolRules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolRules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.BoolRules";
  }
  protected:
  explicit BoolRules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstFieldNumber = 1,
  };
  // optional bool const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  bool const_() const;
  void set_const_(bool value);

  private:
  bool _internal_const_() const;
  void _internal_set_const_(bool value);

  public:
  // @@protoc_insertion_point(class_scope:buf.validate.BoolRules)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool const__;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class StringRules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.StringRules) */ {
 public:
  inline StringRules() : StringRules(nullptr) {}
  ~StringRules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StringRules(::google::protobuf::internal::ConstantInitialized);

  StringRules(const StringRules& from);
  StringRules(StringRules&& from) noexcept
    : StringRules() {
    *this = ::std::move(from);
  }

  inline StringRules& operator=(const StringRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringRules& operator=(StringRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringRules& default_instance() {
    return *internal_default_instance();
  }
  enum WellKnownCase {
    kEmail = 12,
    kHostname = 13,
    kIp = 14,
    kIpv4 = 15,
    kIpv6 = 16,
    kUri = 17,
    kUriRef = 18,
    kAddress = 21,
    kUuid = 22,
    kWellKnownRegex = 24,
    WELL_KNOWN_NOT_SET = 0,
  };

  static inline const StringRules* internal_default_instance() {
    return reinterpret_cast<const StringRules*>(
               &_StringRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(StringRules& a, StringRules& b) {
    a.Swap(&b);
  }
  inline void Swap(StringRules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StringRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StringRules& from) {
    StringRules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringRules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.StringRules";
  }
  protected:
  explicit StringRules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 10,
    kNotInFieldNumber = 11,
    kConstFieldNumber = 1,
    kPatternFieldNumber = 6,
    kPrefixFieldNumber = 7,
    kSuffixFieldNumber = 8,
    kContainsFieldNumber = 9,
    kNotContainsFieldNumber = 23,
    kMinLenFieldNumber = 2,
    kMaxLenFieldNumber = 3,
    kMinBytesFieldNumber = 4,
    kMaxBytesFieldNumber = 5,
    kLenFieldNumber = 19,
    kLenBytesFieldNumber = 20,
    kStrictFieldNumber = 25,
    kEmailFieldNumber = 12,
    kHostnameFieldNumber = 13,
    kIpFieldNumber = 14,
    kIpv4FieldNumber = 15,
    kIpv6FieldNumber = 16,
    kUriFieldNumber = 17,
    kUriRefFieldNumber = 18,
    kAddressFieldNumber = 21,
    kUuidFieldNumber = 22,
    kWellKnownRegexFieldNumber = 24,
  };
  // repeated string in = 10 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  const std::string& in(int index) const;
  std::string* mutable_in(int index);
  void set_in(int index, const std::string& value);
  void set_in(int index, std::string&& value);
  void set_in(int index, const char* value);
  void set_in(int index, const char* value, std::size_t size);
  void set_in(int index, absl::string_view value);
  std::string* add_in();
  void add_in(const std::string& value);
  void add_in(std::string&& value);
  void add_in(const char* value);
  void add_in(const char* value, std::size_t size);
  void add_in(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_in();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_in();

  public:
  // repeated string not_in = 11 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  const std::string& not_in(int index) const;
  std::string* mutable_not_in(int index);
  void set_not_in(int index, const std::string& value);
  void set_not_in(int index, std::string&& value);
  void set_not_in(int index, const char* value);
  void set_not_in(int index, const char* value, std::size_t size);
  void set_not_in(int index, absl::string_view value);
  std::string* add_not_in();
  void add_not_in(const std::string& value);
  void add_not_in(std::string&& value);
  void add_not_in(const char* value);
  void add_not_in(const char* value, std::size_t size);
  void add_not_in(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_not_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_not_in();

  public:
  // optional string const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  const std::string& const_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_const_(Arg_&& arg, Args_... args);
  std::string* mutable_const_();
  PROTOBUF_NODISCARD std::string* release_const_();
  void set_allocated_const_(std::string* ptr);

  private:
  const std::string& _internal_const_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_const_(
      const std::string& value);
  std::string* _internal_mutable_const_();

  public:
  // optional string pattern = 6 [json_name = "pattern", (.buf.validate.priv.field) = {
  bool has_pattern() const;
  void clear_pattern() ;
  const std::string& pattern() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_pattern();
  PROTOBUF_NODISCARD std::string* release_pattern();
  void set_allocated_pattern(std::string* ptr);

  private:
  const std::string& _internal_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(
      const std::string& value);
  std::string* _internal_mutable_pattern();

  public:
  // optional string prefix = 7 [json_name = "prefix", (.buf.validate.priv.field) = {
  bool has_prefix() const;
  void clear_prefix() ;
  const std::string& prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* ptr);

  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(
      const std::string& value);
  std::string* _internal_mutable_prefix();

  public:
  // optional string suffix = 8 [json_name = "suffix", (.buf.validate.priv.field) = {
  bool has_suffix() const;
  void clear_suffix() ;
  const std::string& suffix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_suffix(Arg_&& arg, Args_... args);
  std::string* mutable_suffix();
  PROTOBUF_NODISCARD std::string* release_suffix();
  void set_allocated_suffix(std::string* ptr);

  private:
  const std::string& _internal_suffix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suffix(
      const std::string& value);
  std::string* _internal_mutable_suffix();

  public:
  // optional string contains = 9 [json_name = "contains", (.buf.validate.priv.field) = {
  bool has_contains() const;
  void clear_contains() ;
  const std::string& contains() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contains(Arg_&& arg, Args_... args);
  std::string* mutable_contains();
  PROTOBUF_NODISCARD std::string* release_contains();
  void set_allocated_contains(std::string* ptr);

  private:
  const std::string& _internal_contains() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contains(
      const std::string& value);
  std::string* _internal_mutable_contains();

  public:
  // optional string not_contains = 23 [json_name = "notContains", (.buf.validate.priv.field) = {
  bool has_not_contains() const;
  void clear_not_contains() ;
  const std::string& not_contains() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_not_contains(Arg_&& arg, Args_... args);
  std::string* mutable_not_contains();
  PROTOBUF_NODISCARD std::string* release_not_contains();
  void set_allocated_not_contains(std::string* ptr);

  private:
  const std::string& _internal_not_contains() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_not_contains(
      const std::string& value);
  std::string* _internal_mutable_not_contains();

  public:
  // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {
  bool has_min_len() const;
  void clear_min_len() ;
  ::uint64_t min_len() const;
  void set_min_len(::uint64_t value);

  private:
  ::uint64_t _internal_min_len() const;
  void _internal_set_min_len(::uint64_t value);

  public:
  // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {
  bool has_max_len() const;
  void clear_max_len() ;
  ::uint64_t max_len() const;
  void set_max_len(::uint64_t value);

  private:
  ::uint64_t _internal_max_len() const;
  void _internal_set_max_len(::uint64_t value);

  public:
  // optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.priv.field) = {
  bool has_min_bytes() const;
  void clear_min_bytes() ;
  ::uint64_t min_bytes() const;
  void set_min_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_min_bytes() const;
  void _internal_set_min_bytes(::uint64_t value);

  public:
  // optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.priv.field) = {
  bool has_max_bytes() const;
  void clear_max_bytes() ;
  ::uint64_t max_bytes() const;
  void set_max_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_max_bytes() const;
  void _internal_set_max_bytes(::uint64_t value);

  public:
  // optional uint64 len = 19 [json_name = "len", (.buf.validate.priv.field) = {
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.priv.field) = {
  bool has_len_bytes() const;
  void clear_len_bytes() ;
  ::uint64_t len_bytes() const;
  void set_len_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_len_bytes() const;
  void _internal_set_len_bytes(::uint64_t value);

  public:
  // optional bool strict = 25 [json_name = "strict"];
  bool has_strict() const;
  void clear_strict() ;
  bool strict() const;
  void set_strict(bool value);

  private:
  bool _internal_strict() const;
  void _internal_set_strict(bool value);

  public:
  // bool email = 12 [json_name = "email", (.buf.validate.priv.field) = {
  bool has_email() const;
  void clear_email() ;
  bool email() const;
  void set_email(bool value);

  private:
  bool _internal_email() const;
  void _internal_set_email(bool value);

  public:
  // bool hostname = 13 [json_name = "hostname", (.buf.validate.priv.field) = {
  bool has_hostname() const;
  void clear_hostname() ;
  bool hostname() const;
  void set_hostname(bool value);

  private:
  bool _internal_hostname() const;
  void _internal_set_hostname(bool value);

  public:
  // bool ip = 14 [json_name = "ip", (.buf.validate.priv.field) = {
  bool has_ip() const;
  void clear_ip() ;
  bool ip() const;
  void set_ip(bool value);

  private:
  bool _internal_ip() const;
  void _internal_set_ip(bool value);

  public:
  // bool ipv4 = 15 [json_name = "ipv4", (.buf.validate.priv.field) = {
  bool has_ipv4() const;
  void clear_ipv4() ;
  bool ipv4() const;
  void set_ipv4(bool value);

  private:
  bool _internal_ipv4() const;
  void _internal_set_ipv4(bool value);

  public:
  // bool ipv6 = 16 [json_name = "ipv6", (.buf.validate.priv.field) = {
  bool has_ipv6() const;
  void clear_ipv6() ;
  bool ipv6() const;
  void set_ipv6(bool value);

  private:
  bool _internal_ipv6() const;
  void _internal_set_ipv6(bool value);

  public:
  // bool uri = 17 [json_name = "uri", (.buf.validate.priv.field) = {
  bool has_uri() const;
  void clear_uri() ;
  bool uri() const;
  void set_uri(bool value);

  private:
  bool _internal_uri() const;
  void _internal_set_uri(bool value);

  public:
  // bool uri_ref = 18 [json_name = "uriRef", (.buf.validate.priv.field) = {
  bool has_uri_ref() const;
  void clear_uri_ref() ;
  bool uri_ref() const;
  void set_uri_ref(bool value);

  private:
  bool _internal_uri_ref() const;
  void _internal_set_uri_ref(bool value);

  public:
  // bool address = 21 [json_name = "address", (.buf.validate.priv.field) = {
  bool has_address() const;
  void clear_address() ;
  bool address() const;
  void set_address(bool value);

  private:
  bool _internal_address() const;
  void _internal_set_address(bool value);

  public:
  // bool uuid = 22 [json_name = "uuid", (.buf.validate.priv.field) = {
  bool has_uuid() const;
  void clear_uuid() ;
  bool uuid() const;
  void set_uuid(bool value);

  private:
  bool _internal_uuid() const;
  void _internal_set_uuid(bool value);

  public:
  // .buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.priv.field) = {
  bool has_well_known_regex() const;
  void clear_well_known_regex() ;
  ::buf::validate::KnownRegex well_known_regex() const;
  void set_well_known_regex(::buf::validate::KnownRegex value);

  private:
  ::buf::validate::KnownRegex _internal_well_known_regex() const;
  void _internal_set_well_known_regex(::buf::validate::KnownRegex value);

  public:
  void clear_well_known();
  WellKnownCase well_known_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.StringRules)
 private:
  class _Internal;
  void set_has_email();
  void set_has_hostname();
  void set_has_ip();
  void set_has_ipv4();
  void set_has_ipv6();
  void set_has_uri();
  void set_has_uri_ref();
  void set_has_address();
  void set_has_uuid();
  void set_has_well_known_regex();

  inline bool has_well_known() const;
  inline void clear_has_well_known();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 25, 0, 109, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> in_;
    ::google::protobuf::RepeatedPtrField<std::string> not_in_;
    ::google::protobuf::internal::ArenaStringPtr const__;
    ::google::protobuf::internal::ArenaStringPtr pattern_;
    ::google::protobuf::internal::ArenaStringPtr prefix_;
    ::google::protobuf::internal::ArenaStringPtr suffix_;
    ::google::protobuf::internal::ArenaStringPtr contains_;
    ::google::protobuf::internal::ArenaStringPtr not_contains_;
    ::uint64_t min_len_;
    ::uint64_t max_len_;
    ::uint64_t min_bytes_;
    ::uint64_t max_bytes_;
    ::uint64_t len_;
    ::uint64_t len_bytes_;
    bool strict_;
    union WellKnownUnion {
      constexpr WellKnownUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool email_;
      bool hostname_;
      bool ip_;
      bool ipv4_;
      bool ipv6_;
      bool uri_;
      bool uri_ref_;
      bool address_;
      bool uuid_;
      int well_known_regex_;
    } well_known_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class BytesRules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.BytesRules) */ {
 public:
  inline BytesRules() : BytesRules(nullptr) {}
  ~BytesRules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BytesRules(::google::protobuf::internal::ConstantInitialized);

  BytesRules(const BytesRules& from);
  BytesRules(BytesRules&& from) noexcept
    : BytesRules() {
    *this = ::std::move(from);
  }

  inline BytesRules& operator=(const BytesRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline BytesRules& operator=(BytesRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BytesRules& default_instance() {
    return *internal_default_instance();
  }
  enum WellKnownCase {
    kIp = 10,
    kIpv4 = 11,
    kIpv6 = 12,
    WELL_KNOWN_NOT_SET = 0,
  };

  static inline const BytesRules* internal_default_instance() {
    return reinterpret_cast<const BytesRules*>(
               &_BytesRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BytesRules& a, BytesRules& b) {
    a.Swap(&b);
  }
  inline void Swap(BytesRules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BytesRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BytesRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BytesRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BytesRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BytesRules& from) {
    BytesRules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytesRules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.BytesRules";
  }
  protected:
  explicit BytesRules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 8,
    kNotInFieldNumber = 9,
    kConstFieldNumber = 1,
    kPatternFieldNumber = 4,
    kPrefixFieldNumber = 5,
    kSuffixFieldNumber = 6,
    kContainsFieldNumber = 7,
    kMinLenFieldNumber = 2,
    kMaxLenFieldNumber = 3,
    kLenFieldNumber = 13,
    kIpFieldNumber = 10,
    kIpv4FieldNumber = 11,
    kIpv6FieldNumber = 12,
  };
  // repeated bytes in = 8 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  const std::string& in(int index) const;
  std::string* mutable_in(int index);
  void set_in(int index, const std::string& value);
  void set_in(int index, std::string&& value);
  void set_in(int index, const char* value);
  void set_in(int index, const void* value, std::size_t size);
  void set_in(int index, absl::string_view value);
  std::string* add_in();
  void add_in(const std::string& value);
  void add_in(std::string&& value);
  void add_in(const char* value);
  void add_in(const void* value, std::size_t size);
  void add_in(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_in();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_in();

  public:
  // repeated bytes not_in = 9 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  const std::string& not_in(int index) const;
  std::string* mutable_not_in(int index);
  void set_not_in(int index, const std::string& value);
  void set_not_in(int index, std::string&& value);
  void set_not_in(int index, const char* value);
  void set_not_in(int index, const void* value, std::size_t size);
  void set_not_in(int index, absl::string_view value);
  std::string* add_not_in();
  void add_not_in(const std::string& value);
  void add_not_in(std::string&& value);
  void add_not_in(const char* value);
  void add_not_in(const void* value, std::size_t size);
  void add_not_in(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_not_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_not_in();

  public:
  // optional bytes const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  const std::string& const_() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_const_(Arg_&& arg, Args_... args);
  std::string* mutable_const_();
  PROTOBUF_NODISCARD std::string* release_const_();
  void set_allocated_const_(std::string* ptr);

  private:
  const std::string& _internal_const_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_const_(
      const std::string& value);
  std::string* _internal_mutable_const_();

  public:
  // optional string pattern = 4 [json_name = "pattern", (.buf.validate.priv.field) = {
  bool has_pattern() const;
  void clear_pattern() ;
  const std::string& pattern() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_pattern();
  PROTOBUF_NODISCARD std::string* release_pattern();
  void set_allocated_pattern(std::string* ptr);

  private:
  const std::string& _internal_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(
      const std::string& value);
  std::string* _internal_mutable_pattern();

  public:
  // optional bytes prefix = 5 [json_name = "prefix", (.buf.validate.priv.field) = {
  bool has_prefix() const;
  void clear_prefix() ;
  const std::string& prefix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_prefix(Arg_&& arg, Args_... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* ptr);

  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(
      const std::string& value);
  std::string* _internal_mutable_prefix();

  public:
  // optional bytes suffix = 6 [json_name = "suffix", (.buf.validate.priv.field) = {
  bool has_suffix() const;
  void clear_suffix() ;
  const std::string& suffix() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_suffix(Arg_&& arg, Args_... args);
  std::string* mutable_suffix();
  PROTOBUF_NODISCARD std::string* release_suffix();
  void set_allocated_suffix(std::string* ptr);

  private:
  const std::string& _internal_suffix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_suffix(
      const std::string& value);
  std::string* _internal_mutable_suffix();

  public:
  // optional bytes contains = 7 [json_name = "contains", (.buf.validate.priv.field) = {
  bool has_contains() const;
  void clear_contains() ;
  const std::string& contains() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contains(Arg_&& arg, Args_... args);
  std::string* mutable_contains();
  PROTOBUF_NODISCARD std::string* release_contains();
  void set_allocated_contains(std::string* ptr);

  private:
  const std::string& _internal_contains() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contains(
      const std::string& value);
  std::string* _internal_mutable_contains();

  public:
  // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {
  bool has_min_len() const;
  void clear_min_len() ;
  ::uint64_t min_len() const;
  void set_min_len(::uint64_t value);

  private:
  ::uint64_t _internal_min_len() const;
  void _internal_set_min_len(::uint64_t value);

  public:
  // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {
  bool has_max_len() const;
  void clear_max_len() ;
  ::uint64_t max_len() const;
  void set_max_len(::uint64_t value);

  private:
  ::uint64_t _internal_max_len() const;
  void _internal_set_max_len(::uint64_t value);

  public:
  // optional uint64 len = 13 [json_name = "len", (.buf.validate.priv.field) = {
  bool has_len() const;
  void clear_len() ;
  ::uint64_t len() const;
  void set_len(::uint64_t value);

  private:
  ::uint64_t _internal_len() const;
  void _internal_set_len(::uint64_t value);

  public:
  // bool ip = 10 [json_name = "ip", (.buf.validate.priv.field) = {
  bool has_ip() const;
  void clear_ip() ;
  bool ip() const;
  void set_ip(bool value);

  private:
  bool _internal_ip() const;
  void _internal_set_ip(bool value);

  public:
  // bool ipv4 = 11 [json_name = "ipv4", (.buf.validate.priv.field) = {
  bool has_ipv4() const;
  void clear_ipv4() ;
  bool ipv4() const;
  void set_ipv4(bool value);

  private:
  bool _internal_ipv4() const;
  void _internal_set_ipv4(bool value);

  public:
  // bool ipv6 = 12 [json_name = "ipv6", (.buf.validate.priv.field) = {
  bool has_ipv6() const;
  void clear_ipv6() ;
  bool ipv6() const;
  void set_ipv6(bool value);

  private:
  bool _internal_ipv6() const;
  void _internal_set_ipv6(bool value);

  public:
  void clear_well_known();
  WellKnownCase well_known_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.BytesRules)
 private:
  class _Internal;
  void set_has_ip();
  void set_has_ipv4();
  void set_has_ipv6();

  inline bool has_well_known() const;
  inline void clear_has_well_known();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 13, 0, 47, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> in_;
    ::google::protobuf::RepeatedPtrField<std::string> not_in_;
    ::google::protobuf::internal::ArenaStringPtr const__;
    ::google::protobuf::internal::ArenaStringPtr pattern_;
    ::google::protobuf::internal::ArenaStringPtr prefix_;
    ::google::protobuf::internal::ArenaStringPtr suffix_;
    ::google::protobuf::internal::ArenaStringPtr contains_;
    ::uint64_t min_len_;
    ::uint64_t max_len_;
    ::uint64_t len_;
    union WellKnownUnion {
      constexpr WellKnownUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      bool ip_;
      bool ipv4_;
      bool ipv6_;
    } well_known_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class EnumRules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.EnumRules) */ {
 public:
  inline EnumRules() : EnumRules(nullptr) {}
  ~EnumRules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EnumRules(::google::protobuf::internal::ConstantInitialized);

  EnumRules(const EnumRules& from);
  EnumRules(EnumRules&& from) noexcept
    : EnumRules() {
    *this = ::std::move(from);
  }

  inline EnumRules& operator=(const EnumRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnumRules& operator=(EnumRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnumRules& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnumRules* internal_default_instance() {
    return reinterpret_cast<const EnumRules*>(
               &_EnumRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EnumRules& a, EnumRules& b) {
    a.Swap(&b);
  }
  inline void Swap(EnumRules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnumRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnumRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnumRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EnumRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EnumRules& from) {
    EnumRules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnumRules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.EnumRules";
  }
  protected:
  explicit EnumRules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 3,
    kNotInFieldNumber = 4,
    kConstFieldNumber = 1,
    kDefinedOnlyFieldNumber = 2,
  };
  // repeated int32 in = 3 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::int32_t in(int index) const;
  void set_in(int index, ::int32_t value);
  void add_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_in();

  public:
  // repeated int32 not_in = 4 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::int32_t not_in(int index) const;
  void set_not_in(int index, ::int32_t value);
  void add_not_in(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_not_in() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_not_in();

  public:
  // optional int32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  ::int32_t const_() const;
  void set_const_(::int32_t value);

  private:
  ::int32_t _internal_const_() const;
  void _internal_set_const_(::int32_t value);

  public:
  // optional bool defined_only = 2 [json_name = "definedOnly"];
  bool has_defined_only() const;
  void clear_defined_only() ;
  bool defined_only() const;
  void set_defined_only(bool value);

  private:
  bool _internal_defined_only() const;
  void _internal_set_defined_only(bool value);

  public:
  // @@protoc_insertion_point(class_scope:buf.validate.EnumRules)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> in_;
    mutable ::google::protobuf::internal::CachedSize _in_cached_byte_size_;
    ::google::protobuf::RepeatedField<::int32_t> not_in_;
    mutable ::google::protobuf::internal::CachedSize _not_in_cached_byte_size_;
    ::int32_t const__;
    bool defined_only_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class RepeatedRules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.RepeatedRules) */ {
 public:
  inline RepeatedRules() : RepeatedRules(nullptr) {}
  ~RepeatedRules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RepeatedRules(::google::protobuf::internal::ConstantInitialized);

  RepeatedRules(const RepeatedRules& from);
  RepeatedRules(RepeatedRules&& from) noexcept
    : RepeatedRules() {
    *this = ::std::move(from);
  }

  inline RepeatedRules& operator=(const RepeatedRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepeatedRules& operator=(RepeatedRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepeatedRules& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepeatedRules* internal_default_instance() {
    return reinterpret_cast<const RepeatedRules*>(
               &_RepeatedRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RepeatedRules& a, RepeatedRules& b) {
    a.Swap(&b);
  }
  inline void Swap(RepeatedRules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepeatedRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepeatedRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepeatedRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RepeatedRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RepeatedRules& from) {
    RepeatedRules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepeatedRules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.RepeatedRules";
  }
  protected:
  explicit RepeatedRules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 4,
    kMinItemsFieldNumber = 1,
    kMaxItemsFieldNumber = 2,
    kUniqueFieldNumber = 3,
  };
  // optional .buf.validate.FieldConstraints items = 4 [json_name = "items"];
  bool has_items() const;
  void clear_items() ;
  const ::buf::validate::FieldConstraints& items() const;
  PROTOBUF_NODISCARD ::buf::validate::FieldConstraints* release_items();
  ::buf::validate::FieldConstraints* mutable_items();
  void set_allocated_items(::buf::validate::FieldConstraints* value);
  void unsafe_arena_set_allocated_items(::buf::validate::FieldConstraints* value);
  ::buf::validate::FieldConstraints* unsafe_arena_release_items();

  private:
  const ::buf::validate::FieldConstraints& _internal_items() const;
  ::buf::validate::FieldConstraints* _internal_mutable_items();

  public:
  // optional uint64 min_items = 1 [json_name = "minItems", (.buf.validate.priv.field) = {
  bool has_min_items() const;
  void clear_min_items() ;
  ::uint64_t min_items() const;
  void set_min_items(::uint64_t value);

  private:
  ::uint64_t _internal_min_items() const;
  void _internal_set_min_items(::uint64_t value);

  public:
  // optional uint64 max_items = 2 [json_name = "maxItems", (.buf.validate.priv.field) = {
  bool has_max_items() const;
  void clear_max_items() ;
  ::uint64_t max_items() const;
  void set_max_items(::uint64_t value);

  private:
  ::uint64_t _internal_max_items() const;
  void _internal_set_max_items(::uint64_t value);

  public:
  // optional bool unique = 3 [json_name = "unique", (.buf.validate.priv.field) = {
  bool has_unique() const;
  void clear_unique() ;
  bool unique() const;
  void set_unique(bool value);

  private:
  bool _internal_unique() const;
  void _internal_set_unique(bool value);

  public:
  // @@protoc_insertion_point(class_scope:buf.validate.RepeatedRules)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::buf::validate::FieldConstraints* items_;
    ::uint64_t min_items_;
    ::uint64_t max_items_;
    bool unique_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class MapRules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.MapRules) */ {
 public:
  inline MapRules() : MapRules(nullptr) {}
  ~MapRules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MapRules(::google::protobuf::internal::ConstantInitialized);

  MapRules(const MapRules& from);
  MapRules(MapRules&& from) noexcept
    : MapRules() {
    *this = ::std::move(from);
  }

  inline MapRules& operator=(const MapRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapRules& operator=(MapRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MapRules& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapRules* internal_default_instance() {
    return reinterpret_cast<const MapRules*>(
               &_MapRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(MapRules& a, MapRules& b) {
    a.Swap(&b);
  }
  inline void Swap(MapRules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MapRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MapRules& from) {
    MapRules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapRules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.MapRules";
  }
  protected:
  explicit MapRules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 4,
    kValuesFieldNumber = 5,
    kMinPairsFieldNumber = 1,
    kMaxPairsFieldNumber = 2,
  };
  // optional .buf.validate.FieldConstraints keys = 4 [json_name = "keys"];
  bool has_keys() const;
  void clear_keys() ;
  const ::buf::validate::FieldConstraints& keys() const;
  PROTOBUF_NODISCARD ::buf::validate::FieldConstraints* release_keys();
  ::buf::validate::FieldConstraints* mutable_keys();
  void set_allocated_keys(::buf::validate::FieldConstraints* value);
  void unsafe_arena_set_allocated_keys(::buf::validate::FieldConstraints* value);
  ::buf::validate::FieldConstraints* unsafe_arena_release_keys();

  private:
  const ::buf::validate::FieldConstraints& _internal_keys() const;
  ::buf::validate::FieldConstraints* _internal_mutable_keys();

  public:
  // optional .buf.validate.FieldConstraints values = 5 [json_name = "values"];
  bool has_values() const;
  void clear_values() ;
  const ::buf::validate::FieldConstraints& values() const;
  PROTOBUF_NODISCARD ::buf::validate::FieldConstraints* release_values();
  ::buf::validate::FieldConstraints* mutable_values();
  void set_allocated_values(::buf::validate::FieldConstraints* value);
  void unsafe_arena_set_allocated_values(::buf::validate::FieldConstraints* value);
  ::buf::validate::FieldConstraints* unsafe_arena_release_values();

  private:
  const ::buf::validate::FieldConstraints& _internal_values() const;
  ::buf::validate::FieldConstraints* _internal_mutable_values();

  public:
  // optional uint64 min_pairs = 1 [json_name = "minPairs", (.buf.validate.priv.field) = {
  bool has_min_pairs() const;
  void clear_min_pairs() ;
  ::uint64_t min_pairs() const;
  void set_min_pairs(::uint64_t value);

  private:
  ::uint64_t _internal_min_pairs() const;
  void _internal_set_min_pairs(::uint64_t value);

  public:
  // optional uint64 max_pairs = 2 [json_name = "maxPairs", (.buf.validate.priv.field) = {
  bool has_max_pairs() const;
  void clear_max_pairs() ;
  ::uint64_t max_pairs() const;
  void set_max_pairs(::uint64_t value);

  private:
  ::uint64_t _internal_max_pairs() const;
  void _internal_set_max_pairs(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:buf.validate.MapRules)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 4, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::buf::validate::FieldConstraints* keys_;
    ::buf::validate::FieldConstraints* values_;
    ::uint64_t min_pairs_;
    ::uint64_t max_pairs_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class AnyRules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.AnyRules) */ {
 public:
  inline AnyRules() : AnyRules(nullptr) {}
  ~AnyRules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AnyRules(::google::protobuf::internal::ConstantInitialized);

  AnyRules(const AnyRules& from);
  AnyRules(AnyRules&& from) noexcept
    : AnyRules() {
    *this = ::std::move(from);
  }

  inline AnyRules& operator=(const AnyRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnyRules& operator=(AnyRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnyRules& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnyRules* internal_default_instance() {
    return reinterpret_cast<const AnyRules*>(
               &_AnyRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(AnyRules& a, AnyRules& b) {
    a.Swap(&b);
  }
  inline void Swap(AnyRules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnyRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnyRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnyRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnyRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AnyRules& from) {
    AnyRules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnyRules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.AnyRules";
  }
  protected:
  explicit AnyRules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 2,
    kNotInFieldNumber = 3,
  };
  // repeated string in = 2 [json_name = "in"];
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  const std::string& in(int index) const;
  std::string* mutable_in(int index);
  void set_in(int index, const std::string& value);
  void set_in(int index, std::string&& value);
  void set_in(int index, const char* value);
  void set_in(int index, const char* value, std::size_t size);
  void set_in(int index, absl::string_view value);
  std::string* add_in();
  void add_in(const std::string& value);
  void add_in(std::string&& value);
  void add_in(const char* value);
  void add_in(const char* value, std::size_t size);
  void add_in(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_in();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_in();

  public:
  // repeated string not_in = 3 [json_name = "notIn"];
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  const std::string& not_in(int index) const;
  std::string* mutable_not_in(int index);
  void set_not_in(int index, const std::string& value);
  void set_not_in(int index, std::string&& value);
  void set_not_in(int index, const char* value);
  void set_not_in(int index, const char* value, std::size_t size);
  void set_not_in(int index, absl::string_view value);
  std::string* add_not_in();
  void add_not_in(const std::string& value);
  void add_not_in(std::string&& value);
  void add_not_in(const char* value);
  void add_not_in(const char* value, std::size_t size);
  void add_not_in(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& not_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_not_in();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_not_in() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_not_in();

  public:
  // @@protoc_insertion_point(class_scope:buf.validate.AnyRules)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 38, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField<std::string> in_;
    ::google::protobuf::RepeatedPtrField<std::string> not_in_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class DurationRules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.DurationRules) */ {
 public:
  inline DurationRules() : DurationRules(nullptr) {}
  ~DurationRules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DurationRules(::google::protobuf::internal::ConstantInitialized);

  DurationRules(const DurationRules& from);
  DurationRules(DurationRules&& from) noexcept
    : DurationRules() {
    *this = ::std::move(from);
  }

  inline DurationRules& operator=(const DurationRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline DurationRules& operator=(DurationRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DurationRules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 3,
    kLte = 4,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 5,
    kGte = 6,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const DurationRules* internal_default_instance() {
    return reinterpret_cast<const DurationRules*>(
               &_DurationRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DurationRules& a, DurationRules& b) {
    a.Swap(&b);
  }
  inline void Swap(DurationRules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DurationRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DurationRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DurationRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DurationRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DurationRules& from) {
    DurationRules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DurationRules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.DurationRules";
  }
  protected:
  explicit DurationRules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInFieldNumber = 7,
    kNotInFieldNumber = 8,
    kConstFieldNumber = 2,
    kLtFieldNumber = 3,
    kLteFieldNumber = 4,
    kGtFieldNumber = 5,
    kGteFieldNumber = 6,
  };
  // repeated .google.protobuf.Duration in = 7 [json_name = "in", (.buf.validate.priv.field) = {
  int in_size() const;
  private:
  int _internal_in_size() const;

  public:
  void clear_in() ;
  ::google::protobuf::Duration* mutable_in(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >*
      mutable_in();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& _internal_in() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* _internal_mutable_in();
  public:
  const ::google::protobuf::Duration& in(int index) const;
  ::google::protobuf::Duration* add_in();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >&
      in() const;
  // repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn", (.buf.validate.priv.field) = {
  int not_in_size() const;
  private:
  int _internal_not_in_size() const;

  public:
  void clear_not_in() ;
  ::google::protobuf::Duration* mutable_not_in(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >*
      mutable_not_in();
  private:
  const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>& _internal_not_in() const;
  ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>* _internal_mutable_not_in();
  public:
  const ::google::protobuf::Duration& not_in(int index) const;
  ::google::protobuf::Duration* add_not_in();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >&
      not_in() const;
  // optional .google.protobuf.Duration const = 2 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  const ::google::protobuf::Duration& const_() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_const_();
  ::google::protobuf::Duration* mutable_const_();
  void set_allocated_const_(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_const_(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_const_();

  private:
  const ::google::protobuf::Duration& _internal_const_() const;
  ::google::protobuf::Duration* _internal_mutable_const_();

  public:
  // .google.protobuf.Duration lt = 3 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  private:
  bool _internal_has_lt() const;

  public:
  void clear_lt() ;
  const ::google::protobuf::Duration& lt() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_lt();
  ::google::protobuf::Duration* mutable_lt();
  void set_allocated_lt(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_lt(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_lt();

  private:
  const ::google::protobuf::Duration& _internal_lt() const;
  ::google::protobuf::Duration* _internal_mutable_lt();

  public:
  // .google.protobuf.Duration lte = 4 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  private:
  bool _internal_has_lte() const;

  public:
  void clear_lte() ;
  const ::google::protobuf::Duration& lte() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_lte();
  ::google::protobuf::Duration* mutable_lte();
  void set_allocated_lte(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_lte(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_lte();

  private:
  const ::google::protobuf::Duration& _internal_lte() const;
  ::google::protobuf::Duration* _internal_mutable_lte();

  public:
  // .google.protobuf.Duration gt = 5 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  private:
  bool _internal_has_gt() const;

  public:
  void clear_gt() ;
  const ::google::protobuf::Duration& gt() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_gt();
  ::google::protobuf::Duration* mutable_gt();
  void set_allocated_gt(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_gt(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_gt();

  private:
  const ::google::protobuf::Duration& _internal_gt() const;
  ::google::protobuf::Duration* _internal_mutable_gt();

  public:
  // .google.protobuf.Duration gte = 6 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  private:
  bool _internal_has_gte() const;

  public:
  void clear_gte() ;
  const ::google::protobuf::Duration& gte() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_gte();
  ::google::protobuf::Duration* mutable_gte();
  void set_allocated_gte(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_gte(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_gte();

  private:
  const ::google::protobuf::Duration& _internal_gte() const;
  ::google::protobuf::Duration* _internal_mutable_gte();

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.DurationRules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_gt();
  void set_has_gte();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 7, 7, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration > in_;
    ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration > not_in_;
    ::google::protobuf::Duration* const__;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Duration* lt_;
      ::google::protobuf::Duration* lte_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Duration* gt_;
      ::google::protobuf::Duration* gte_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};// -------------------------------------------------------------------

class TimestampRules final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buf.validate.TimestampRules) */ {
 public:
  inline TimestampRules() : TimestampRules(nullptr) {}
  ~TimestampRules() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TimestampRules(::google::protobuf::internal::ConstantInitialized);

  TimestampRules(const TimestampRules& from);
  TimestampRules(TimestampRules&& from) noexcept
    : TimestampRules() {
    *this = ::std::move(from);
  }

  inline TimestampRules& operator=(const TimestampRules& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimestampRules& operator=(TimestampRules&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimestampRules& default_instance() {
    return *internal_default_instance();
  }
  enum LessThanCase {
    kLt = 3,
    kLte = 4,
    kLtNow = 7,
    LESS_THAN_NOT_SET = 0,
  };

  enum GreaterThanCase {
    kGt = 5,
    kGte = 6,
    kGtNow = 8,
    GREATER_THAN_NOT_SET = 0,
  };

  static inline const TimestampRules* internal_default_instance() {
    return reinterpret_cast<const TimestampRules*>(
               &_TimestampRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TimestampRules& a, TimestampRules& b) {
    a.Swap(&b);
  }
  inline void Swap(TimestampRules* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimestampRules* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimestampRules* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimestampRules>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimestampRules& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TimestampRules& from) {
    TimestampRules::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimestampRules* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "buf.validate.TimestampRules";
  }
  protected:
  explicit TimestampRules(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstFieldNumber = 2,
    kWithinFieldNumber = 9,
    kLtFieldNumber = 3,
    kLteFieldNumber = 4,
    kLtNowFieldNumber = 7,
    kGtFieldNumber = 5,
    kGteFieldNumber = 6,
    kGtNowFieldNumber = 8,
  };
  // optional .google.protobuf.Timestamp const = 2 [json_name = "const", (.buf.validate.priv.field) = {
  bool has_const_() const;
  void clear_const_() ;
  const ::google::protobuf::Timestamp& const_() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_const_();
  ::google::protobuf::Timestamp* mutable_const_();
  void set_allocated_const_(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_const_(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_const_();

  private:
  const ::google::protobuf::Timestamp& _internal_const_() const;
  ::google::protobuf::Timestamp* _internal_mutable_const_();

  public:
  // optional .google.protobuf.Duration within = 9 [json_name = "within", (.buf.validate.priv.field) = {
  bool has_within() const;
  void clear_within() ;
  const ::google::protobuf::Duration& within() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_within();
  ::google::protobuf::Duration* mutable_within();
  void set_allocated_within(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_within(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_within();

  private:
  const ::google::protobuf::Duration& _internal_within() const;
  ::google::protobuf::Duration* _internal_mutable_within();

  public:
  // .google.protobuf.Timestamp lt = 3 [json_name = "lt", (.buf.validate.priv.field) = {
  bool has_lt() const;
  private:
  bool _internal_has_lt() const;

  public:
  void clear_lt() ;
  const ::google::protobuf::Timestamp& lt() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_lt();
  ::google::protobuf::Timestamp* mutable_lt();
  void set_allocated_lt(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_lt(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_lt();

  private:
  const ::google::protobuf::Timestamp& _internal_lt() const;
  ::google::protobuf::Timestamp* _internal_mutable_lt();

  public:
  // .google.protobuf.Timestamp lte = 4 [json_name = "lte", (.buf.validate.priv.field) = {
  bool has_lte() const;
  private:
  bool _internal_has_lte() const;

  public:
  void clear_lte() ;
  const ::google::protobuf::Timestamp& lte() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_lte();
  ::google::protobuf::Timestamp* mutable_lte();
  void set_allocated_lte(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_lte(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_lte();

  private:
  const ::google::protobuf::Timestamp& _internal_lte() const;
  ::google::protobuf::Timestamp* _internal_mutable_lte();

  public:
  // bool lt_now = 7 [json_name = "ltNow", (.buf.validate.priv.field) = {
  bool has_lt_now() const;
  void clear_lt_now() ;
  bool lt_now() const;
  void set_lt_now(bool value);

  private:
  bool _internal_lt_now() const;
  void _internal_set_lt_now(bool value);

  public:
  // .google.protobuf.Timestamp gt = 5 [json_name = "gt", (.buf.validate.priv.field) = {
  bool has_gt() const;
  private:
  bool _internal_has_gt() const;

  public:
  void clear_gt() ;
  const ::google::protobuf::Timestamp& gt() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_gt();
  ::google::protobuf::Timestamp* mutable_gt();
  void set_allocated_gt(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_gt(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_gt();

  private:
  const ::google::protobuf::Timestamp& _internal_gt() const;
  ::google::protobuf::Timestamp* _internal_mutable_gt();

  public:
  // .google.protobuf.Timestamp gte = 6 [json_name = "gte", (.buf.validate.priv.field) = {
  bool has_gte() const;
  private:
  bool _internal_has_gte() const;

  public:
  void clear_gte() ;
  const ::google::protobuf::Timestamp& gte() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_gte();
  ::google::protobuf::Timestamp* mutable_gte();
  void set_allocated_gte(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_gte(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_gte();

  private:
  const ::google::protobuf::Timestamp& _internal_gte() const;
  ::google::protobuf::Timestamp* _internal_mutable_gte();

  public:
  // bool gt_now = 8 [json_name = "gtNow", (.buf.validate.priv.field) = {
  bool has_gt_now() const;
  void clear_gt_now() ;
  bool gt_now() const;
  void set_gt_now(bool value);

  private:
  bool _internal_gt_now() const;
  void _internal_set_gt_now(bool value);

  public:
  void clear_less_than();
  LessThanCase less_than_case() const;
  void clear_greater_than();
  GreaterThanCase greater_than_case() const;
  // @@protoc_insertion_point(class_scope:buf.validate.TimestampRules)
 private:
  class _Internal;
  void set_has_lt();
  void set_has_lte();
  void set_has_lt_now();
  void set_has_gt();
  void set_has_gte();
  void set_has_gt_now();

  inline bool has_less_than() const;
  inline void clear_has_less_than();

  inline bool has_greater_than() const;
  inline void clear_has_greater_than();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 8, 6, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* const__;
    ::google::protobuf::Duration* within_;
    union LessThanUnion {
      constexpr LessThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Timestamp* lt_;
      ::google::protobuf::Timestamp* lte_;
      bool lt_now_;
    } less_than_;
    union GreaterThanUnion {
      constexpr GreaterThanUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::Timestamp* gt_;
      ::google::protobuf::Timestamp* gte_;
      bool gt_now_;
    } greater_than_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_buf_2fvalidate_2fvalidate_2eproto;
};

// ===================================================================



static const int kMessageFieldNumber = 1159;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::buf::validate::MessageConstraints >, 11, false >
  message;
static const int kOneofFieldNumber = 1159;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::OneofOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::buf::validate::OneofConstraints >, 11, false >
  oneof;
static const int kFieldFieldNumber = 1159;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::buf::validate::FieldConstraints >, 11, false >
  field;

// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MessageConstraints

// optional bool disabled = 1 [json_name = "disabled"];
inline bool MessageConstraints::has_disabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MessageConstraints::clear_disabled() {
  _impl_.disabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool MessageConstraints::disabled() const {
  // @@protoc_insertion_point(field_get:buf.validate.MessageConstraints.disabled)
  return _internal_disabled();
}
inline void MessageConstraints::set_disabled(bool value) {
  _internal_set_disabled(value);
  // @@protoc_insertion_point(field_set:buf.validate.MessageConstraints.disabled)
}
inline bool MessageConstraints::_internal_disabled() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.disabled_;
}
inline void MessageConstraints::_internal_set_disabled(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.disabled_ = value;
}

// repeated .buf.validate.Constraint cel = 3 [json_name = "cel"];
inline int MessageConstraints::_internal_cel_size() const {
  return _internal_cel().size();
}
inline int MessageConstraints::cel_size() const {
  return _internal_cel_size();
}
inline ::buf::validate::Constraint* MessageConstraints::mutable_cel(int index) {
  // @@protoc_insertion_point(field_mutable:buf.validate.MessageConstraints.cel)
  return _internal_mutable_cel()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::buf::validate::Constraint >*
MessageConstraints::mutable_cel() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.MessageConstraints.cel)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_cel();
}
inline const ::buf::validate::Constraint& MessageConstraints::cel(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.MessageConstraints.cel)
    return _internal_cel().Get(index);
}
inline ::buf::validate::Constraint* MessageConstraints::add_cel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::buf::validate::Constraint* _add = _internal_mutable_cel()->Add();
  // @@protoc_insertion_point(field_add:buf.validate.MessageConstraints.cel)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::buf::validate::Constraint >&
MessageConstraints::cel() const {
  // @@protoc_insertion_point(field_list:buf.validate.MessageConstraints.cel)
  return _internal_cel();
}
inline const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>&
MessageConstraints::_internal_cel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cel_;
}
inline ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>*
MessageConstraints::_internal_mutable_cel() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.cel_;
}

// -------------------------------------------------------------------

// OneofConstraints

// optional bool required = 1 [json_name = "required"];
inline bool OneofConstraints::has_required() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void OneofConstraints::clear_required() {
  _impl_.required_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool OneofConstraints::required() const {
  // @@protoc_insertion_point(field_get:buf.validate.OneofConstraints.required)
  return _internal_required();
}
inline void OneofConstraints::set_required(bool value) {
  _internal_set_required(value);
  // @@protoc_insertion_point(field_set:buf.validate.OneofConstraints.required)
}
inline bool OneofConstraints::_internal_required() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.required_;
}
inline void OneofConstraints::_internal_set_required(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.required_ = value;
}

// -------------------------------------------------------------------

// FieldConstraints

// repeated .buf.validate.Constraint cel = 23 [json_name = "cel"];
inline int FieldConstraints::_internal_cel_size() const {
  return _internal_cel().size();
}
inline int FieldConstraints::cel_size() const {
  return _internal_cel_size();
}
inline ::buf::validate::Constraint* FieldConstraints::mutable_cel(int index) {
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.cel)
  return _internal_mutable_cel()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::buf::validate::Constraint >*
FieldConstraints::mutable_cel() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.FieldConstraints.cel)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_cel();
}
inline const ::buf::validate::Constraint& FieldConstraints::cel(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.cel)
    return _internal_cel().Get(index);
}
inline ::buf::validate::Constraint* FieldConstraints::add_cel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::buf::validate::Constraint* _add = _internal_mutable_cel()->Add();
  // @@protoc_insertion_point(field_add:buf.validate.FieldConstraints.cel)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::buf::validate::Constraint >&
FieldConstraints::cel() const {
  // @@protoc_insertion_point(field_list:buf.validate.FieldConstraints.cel)
  return _internal_cel();
}
inline const ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>&
FieldConstraints::_internal_cel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cel_;
}
inline ::google::protobuf::RepeatedPtrField<::buf::validate::Constraint>*
FieldConstraints::_internal_mutable_cel() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.cel_;
}

// bool skipped = 24 [json_name = "skipped"];
inline void FieldConstraints::clear_skipped() {
  _impl_.skipped_ = false;
}
inline bool FieldConstraints::skipped() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.skipped)
  return _internal_skipped();
}
inline void FieldConstraints::set_skipped(bool value) {
  _internal_set_skipped(value);
  // @@protoc_insertion_point(field_set:buf.validate.FieldConstraints.skipped)
}
inline bool FieldConstraints::_internal_skipped() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skipped_;
}
inline void FieldConstraints::_internal_set_skipped(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.skipped_ = value;
}

// bool required = 25 [json_name = "required"];
inline void FieldConstraints::clear_required() {
  _impl_.required_ = false;
}
inline bool FieldConstraints::required() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.required)
  return _internal_required();
}
inline void FieldConstraints::set_required(bool value) {
  _internal_set_required(value);
  // @@protoc_insertion_point(field_set:buf.validate.FieldConstraints.required)
}
inline bool FieldConstraints::_internal_required() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.required_;
}
inline void FieldConstraints::_internal_set_required(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.required_ = value;
}

// bool ignore_empty = 26 [json_name = "ignoreEmpty"];
inline void FieldConstraints::clear_ignore_empty() {
  _impl_.ignore_empty_ = false;
}
inline bool FieldConstraints::ignore_empty() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.ignore_empty)
  return _internal_ignore_empty();
}
inline void FieldConstraints::set_ignore_empty(bool value) {
  _internal_set_ignore_empty(value);
  // @@protoc_insertion_point(field_set:buf.validate.FieldConstraints.ignore_empty)
}
inline bool FieldConstraints::_internal_ignore_empty() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ignore_empty_;
}
inline void FieldConstraints::_internal_set_ignore_empty(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ignore_empty_ = value;
}

// .buf.validate.FloatRules float = 1 [json_name = "float"];
inline bool FieldConstraints::has_float_() const {
  return type_case() == kFloat;
}
inline bool FieldConstraints::_internal_has_float_() const {
  return type_case() == kFloat;
}
inline void FieldConstraints::set_has_float_() {
  _impl_._oneof_case_[0] = kFloat;
}
inline void FieldConstraints::clear_float_() {
  if (type_case() == kFloat) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.float__;
    }
    clear_has_type();
  }
}
inline ::buf::validate::FloatRules* FieldConstraints::release_float_() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.float)
  if (type_case() == kFloat) {
    clear_has_type();
    ::buf::validate::FloatRules* temp = _impl_.type_.float__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.float__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::FloatRules& FieldConstraints::_internal_float_() const {
  return type_case() == kFloat
      ? *_impl_.type_.float__
      : reinterpret_cast<::buf::validate::FloatRules&>(::buf::validate::_FloatRules_default_instance_);
}
inline const ::buf::validate::FloatRules& FieldConstraints::float_() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.float)
  return _internal_float_();
}
inline ::buf::validate::FloatRules* FieldConstraints::unsafe_arena_release_float_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.float)
  if (type_case() == kFloat) {
    clear_has_type();
    ::buf::validate::FloatRules* temp = _impl_.type_.float__;
    _impl_.type_.float__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_float_(::buf::validate::FloatRules* float_) {
  clear_type();
  if (float_) {
    set_has_float_();
    _impl_.type_.float__ = float_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.float)
}
inline ::buf::validate::FloatRules* FieldConstraints::_internal_mutable_float_() {
  if (type_case() != kFloat) {
    clear_type();
    set_has_float_();
    _impl_.type_.float__ = CreateMaybeMessage< ::buf::validate::FloatRules >(GetArenaForAllocation());
  }
  return _impl_.type_.float__;
}
inline ::buf::validate::FloatRules* FieldConstraints::mutable_float_() {
  ::buf::validate::FloatRules* _msg = _internal_mutable_float_();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.float)
  return _msg;
}

// .buf.validate.DoubleRules double = 2 [json_name = "double"];
inline bool FieldConstraints::has_double_() const {
  return type_case() == kDouble;
}
inline bool FieldConstraints::_internal_has_double_() const {
  return type_case() == kDouble;
}
inline void FieldConstraints::set_has_double_() {
  _impl_._oneof_case_[0] = kDouble;
}
inline void FieldConstraints::clear_double_() {
  if (type_case() == kDouble) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.double__;
    }
    clear_has_type();
  }
}
inline ::buf::validate::DoubleRules* FieldConstraints::release_double_() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.double)
  if (type_case() == kDouble) {
    clear_has_type();
    ::buf::validate::DoubleRules* temp = _impl_.type_.double__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.double__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::DoubleRules& FieldConstraints::_internal_double_() const {
  return type_case() == kDouble
      ? *_impl_.type_.double__
      : reinterpret_cast<::buf::validate::DoubleRules&>(::buf::validate::_DoubleRules_default_instance_);
}
inline const ::buf::validate::DoubleRules& FieldConstraints::double_() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.double)
  return _internal_double_();
}
inline ::buf::validate::DoubleRules* FieldConstraints::unsafe_arena_release_double_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.double)
  if (type_case() == kDouble) {
    clear_has_type();
    ::buf::validate::DoubleRules* temp = _impl_.type_.double__;
    _impl_.type_.double__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_double_(::buf::validate::DoubleRules* double_) {
  clear_type();
  if (double_) {
    set_has_double_();
    _impl_.type_.double__ = double_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.double)
}
inline ::buf::validate::DoubleRules* FieldConstraints::_internal_mutable_double_() {
  if (type_case() != kDouble) {
    clear_type();
    set_has_double_();
    _impl_.type_.double__ = CreateMaybeMessage< ::buf::validate::DoubleRules >(GetArenaForAllocation());
  }
  return _impl_.type_.double__;
}
inline ::buf::validate::DoubleRules* FieldConstraints::mutable_double_() {
  ::buf::validate::DoubleRules* _msg = _internal_mutable_double_();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.double)
  return _msg;
}

// .buf.validate.Int32Rules int32 = 3 [json_name = "int32"];
inline bool FieldConstraints::has_int32() const {
  return type_case() == kInt32;
}
inline bool FieldConstraints::_internal_has_int32() const {
  return type_case() == kInt32;
}
inline void FieldConstraints::set_has_int32() {
  _impl_._oneof_case_[0] = kInt32;
}
inline void FieldConstraints::clear_int32() {
  if (type_case() == kInt32) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.int32_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::Int32Rules* FieldConstraints::release_int32() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.int32)
  if (type_case() == kInt32) {
    clear_has_type();
    ::buf::validate::Int32Rules* temp = _impl_.type_.int32_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.int32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::Int32Rules& FieldConstraints::_internal_int32() const {
  return type_case() == kInt32
      ? *_impl_.type_.int32_
      : reinterpret_cast<::buf::validate::Int32Rules&>(::buf::validate::_Int32Rules_default_instance_);
}
inline const ::buf::validate::Int32Rules& FieldConstraints::int32() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.int32)
  return _internal_int32();
}
inline ::buf::validate::Int32Rules* FieldConstraints::unsafe_arena_release_int32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.int32)
  if (type_case() == kInt32) {
    clear_has_type();
    ::buf::validate::Int32Rules* temp = _impl_.type_.int32_;
    _impl_.type_.int32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_int32(::buf::validate::Int32Rules* int32) {
  clear_type();
  if (int32) {
    set_has_int32();
    _impl_.type_.int32_ = int32;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.int32)
}
inline ::buf::validate::Int32Rules* FieldConstraints::_internal_mutable_int32() {
  if (type_case() != kInt32) {
    clear_type();
    set_has_int32();
    _impl_.type_.int32_ = CreateMaybeMessage< ::buf::validate::Int32Rules >(GetArenaForAllocation());
  }
  return _impl_.type_.int32_;
}
inline ::buf::validate::Int32Rules* FieldConstraints::mutable_int32() {
  ::buf::validate::Int32Rules* _msg = _internal_mutable_int32();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.int32)
  return _msg;
}

// .buf.validate.Int64Rules int64 = 4 [json_name = "int64"];
inline bool FieldConstraints::has_int64() const {
  return type_case() == kInt64;
}
inline bool FieldConstraints::_internal_has_int64() const {
  return type_case() == kInt64;
}
inline void FieldConstraints::set_has_int64() {
  _impl_._oneof_case_[0] = kInt64;
}
inline void FieldConstraints::clear_int64() {
  if (type_case() == kInt64) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.int64_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::Int64Rules* FieldConstraints::release_int64() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.int64)
  if (type_case() == kInt64) {
    clear_has_type();
    ::buf::validate::Int64Rules* temp = _impl_.type_.int64_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.int64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::Int64Rules& FieldConstraints::_internal_int64() const {
  return type_case() == kInt64
      ? *_impl_.type_.int64_
      : reinterpret_cast<::buf::validate::Int64Rules&>(::buf::validate::_Int64Rules_default_instance_);
}
inline const ::buf::validate::Int64Rules& FieldConstraints::int64() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.int64)
  return _internal_int64();
}
inline ::buf::validate::Int64Rules* FieldConstraints::unsafe_arena_release_int64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.int64)
  if (type_case() == kInt64) {
    clear_has_type();
    ::buf::validate::Int64Rules* temp = _impl_.type_.int64_;
    _impl_.type_.int64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_int64(::buf::validate::Int64Rules* int64) {
  clear_type();
  if (int64) {
    set_has_int64();
    _impl_.type_.int64_ = int64;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.int64)
}
inline ::buf::validate::Int64Rules* FieldConstraints::_internal_mutable_int64() {
  if (type_case() != kInt64) {
    clear_type();
    set_has_int64();
    _impl_.type_.int64_ = CreateMaybeMessage< ::buf::validate::Int64Rules >(GetArenaForAllocation());
  }
  return _impl_.type_.int64_;
}
inline ::buf::validate::Int64Rules* FieldConstraints::mutable_int64() {
  ::buf::validate::Int64Rules* _msg = _internal_mutable_int64();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.int64)
  return _msg;
}

// .buf.validate.UInt32Rules uint32 = 5 [json_name = "uint32"];
inline bool FieldConstraints::has_uint32() const {
  return type_case() == kUint32;
}
inline bool FieldConstraints::_internal_has_uint32() const {
  return type_case() == kUint32;
}
inline void FieldConstraints::set_has_uint32() {
  _impl_._oneof_case_[0] = kUint32;
}
inline void FieldConstraints::clear_uint32() {
  if (type_case() == kUint32) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.uint32_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::UInt32Rules* FieldConstraints::release_uint32() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.uint32)
  if (type_case() == kUint32) {
    clear_has_type();
    ::buf::validate::UInt32Rules* temp = _impl_.type_.uint32_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.uint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::UInt32Rules& FieldConstraints::_internal_uint32() const {
  return type_case() == kUint32
      ? *_impl_.type_.uint32_
      : reinterpret_cast<::buf::validate::UInt32Rules&>(::buf::validate::_UInt32Rules_default_instance_);
}
inline const ::buf::validate::UInt32Rules& FieldConstraints::uint32() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.uint32)
  return _internal_uint32();
}
inline ::buf::validate::UInt32Rules* FieldConstraints::unsafe_arena_release_uint32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.uint32)
  if (type_case() == kUint32) {
    clear_has_type();
    ::buf::validate::UInt32Rules* temp = _impl_.type_.uint32_;
    _impl_.type_.uint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_uint32(::buf::validate::UInt32Rules* uint32) {
  clear_type();
  if (uint32) {
    set_has_uint32();
    _impl_.type_.uint32_ = uint32;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.uint32)
}
inline ::buf::validate::UInt32Rules* FieldConstraints::_internal_mutable_uint32() {
  if (type_case() != kUint32) {
    clear_type();
    set_has_uint32();
    _impl_.type_.uint32_ = CreateMaybeMessage< ::buf::validate::UInt32Rules >(GetArenaForAllocation());
  }
  return _impl_.type_.uint32_;
}
inline ::buf::validate::UInt32Rules* FieldConstraints::mutable_uint32() {
  ::buf::validate::UInt32Rules* _msg = _internal_mutable_uint32();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.uint32)
  return _msg;
}

// .buf.validate.UInt64Rules uint64 = 6 [json_name = "uint64"];
inline bool FieldConstraints::has_uint64() const {
  return type_case() == kUint64;
}
inline bool FieldConstraints::_internal_has_uint64() const {
  return type_case() == kUint64;
}
inline void FieldConstraints::set_has_uint64() {
  _impl_._oneof_case_[0] = kUint64;
}
inline void FieldConstraints::clear_uint64() {
  if (type_case() == kUint64) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.uint64_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::UInt64Rules* FieldConstraints::release_uint64() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.uint64)
  if (type_case() == kUint64) {
    clear_has_type();
    ::buf::validate::UInt64Rules* temp = _impl_.type_.uint64_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.uint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::UInt64Rules& FieldConstraints::_internal_uint64() const {
  return type_case() == kUint64
      ? *_impl_.type_.uint64_
      : reinterpret_cast<::buf::validate::UInt64Rules&>(::buf::validate::_UInt64Rules_default_instance_);
}
inline const ::buf::validate::UInt64Rules& FieldConstraints::uint64() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.uint64)
  return _internal_uint64();
}
inline ::buf::validate::UInt64Rules* FieldConstraints::unsafe_arena_release_uint64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.uint64)
  if (type_case() == kUint64) {
    clear_has_type();
    ::buf::validate::UInt64Rules* temp = _impl_.type_.uint64_;
    _impl_.type_.uint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_uint64(::buf::validate::UInt64Rules* uint64) {
  clear_type();
  if (uint64) {
    set_has_uint64();
    _impl_.type_.uint64_ = uint64;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.uint64)
}
inline ::buf::validate::UInt64Rules* FieldConstraints::_internal_mutable_uint64() {
  if (type_case() != kUint64) {
    clear_type();
    set_has_uint64();
    _impl_.type_.uint64_ = CreateMaybeMessage< ::buf::validate::UInt64Rules >(GetArenaForAllocation());
  }
  return _impl_.type_.uint64_;
}
inline ::buf::validate::UInt64Rules* FieldConstraints::mutable_uint64() {
  ::buf::validate::UInt64Rules* _msg = _internal_mutable_uint64();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.uint64)
  return _msg;
}

// .buf.validate.SInt32Rules sint32 = 7 [json_name = "sint32"];
inline bool FieldConstraints::has_sint32() const {
  return type_case() == kSint32;
}
inline bool FieldConstraints::_internal_has_sint32() const {
  return type_case() == kSint32;
}
inline void FieldConstraints::set_has_sint32() {
  _impl_._oneof_case_[0] = kSint32;
}
inline void FieldConstraints::clear_sint32() {
  if (type_case() == kSint32) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.sint32_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::SInt32Rules* FieldConstraints::release_sint32() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.sint32)
  if (type_case() == kSint32) {
    clear_has_type();
    ::buf::validate::SInt32Rules* temp = _impl_.type_.sint32_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::SInt32Rules& FieldConstraints::_internal_sint32() const {
  return type_case() == kSint32
      ? *_impl_.type_.sint32_
      : reinterpret_cast<::buf::validate::SInt32Rules&>(::buf::validate::_SInt32Rules_default_instance_);
}
inline const ::buf::validate::SInt32Rules& FieldConstraints::sint32() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.sint32)
  return _internal_sint32();
}
inline ::buf::validate::SInt32Rules* FieldConstraints::unsafe_arena_release_sint32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.sint32)
  if (type_case() == kSint32) {
    clear_has_type();
    ::buf::validate::SInt32Rules* temp = _impl_.type_.sint32_;
    _impl_.type_.sint32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_sint32(::buf::validate::SInt32Rules* sint32) {
  clear_type();
  if (sint32) {
    set_has_sint32();
    _impl_.type_.sint32_ = sint32;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.sint32)
}
inline ::buf::validate::SInt32Rules* FieldConstraints::_internal_mutable_sint32() {
  if (type_case() != kSint32) {
    clear_type();
    set_has_sint32();
    _impl_.type_.sint32_ = CreateMaybeMessage< ::buf::validate::SInt32Rules >(GetArenaForAllocation());
  }
  return _impl_.type_.sint32_;
}
inline ::buf::validate::SInt32Rules* FieldConstraints::mutable_sint32() {
  ::buf::validate::SInt32Rules* _msg = _internal_mutable_sint32();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.sint32)
  return _msg;
}

// .buf.validate.SInt64Rules sint64 = 8 [json_name = "sint64"];
inline bool FieldConstraints::has_sint64() const {
  return type_case() == kSint64;
}
inline bool FieldConstraints::_internal_has_sint64() const {
  return type_case() == kSint64;
}
inline void FieldConstraints::set_has_sint64() {
  _impl_._oneof_case_[0] = kSint64;
}
inline void FieldConstraints::clear_sint64() {
  if (type_case() == kSint64) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.sint64_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::SInt64Rules* FieldConstraints::release_sint64() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.sint64)
  if (type_case() == kSint64) {
    clear_has_type();
    ::buf::validate::SInt64Rules* temp = _impl_.type_.sint64_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::SInt64Rules& FieldConstraints::_internal_sint64() const {
  return type_case() == kSint64
      ? *_impl_.type_.sint64_
      : reinterpret_cast<::buf::validate::SInt64Rules&>(::buf::validate::_SInt64Rules_default_instance_);
}
inline const ::buf::validate::SInt64Rules& FieldConstraints::sint64() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.sint64)
  return _internal_sint64();
}
inline ::buf::validate::SInt64Rules* FieldConstraints::unsafe_arena_release_sint64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.sint64)
  if (type_case() == kSint64) {
    clear_has_type();
    ::buf::validate::SInt64Rules* temp = _impl_.type_.sint64_;
    _impl_.type_.sint64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_sint64(::buf::validate::SInt64Rules* sint64) {
  clear_type();
  if (sint64) {
    set_has_sint64();
    _impl_.type_.sint64_ = sint64;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.sint64)
}
inline ::buf::validate::SInt64Rules* FieldConstraints::_internal_mutable_sint64() {
  if (type_case() != kSint64) {
    clear_type();
    set_has_sint64();
    _impl_.type_.sint64_ = CreateMaybeMessage< ::buf::validate::SInt64Rules >(GetArenaForAllocation());
  }
  return _impl_.type_.sint64_;
}
inline ::buf::validate::SInt64Rules* FieldConstraints::mutable_sint64() {
  ::buf::validate::SInt64Rules* _msg = _internal_mutable_sint64();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.sint64)
  return _msg;
}

// .buf.validate.Fixed32Rules fixed32 = 9 [json_name = "fixed32"];
inline bool FieldConstraints::has_fixed32() const {
  return type_case() == kFixed32;
}
inline bool FieldConstraints::_internal_has_fixed32() const {
  return type_case() == kFixed32;
}
inline void FieldConstraints::set_has_fixed32() {
  _impl_._oneof_case_[0] = kFixed32;
}
inline void FieldConstraints::clear_fixed32() {
  if (type_case() == kFixed32) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.fixed32_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::Fixed32Rules* FieldConstraints::release_fixed32() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.fixed32)
  if (type_case() == kFixed32) {
    clear_has_type();
    ::buf::validate::Fixed32Rules* temp = _impl_.type_.fixed32_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.fixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::Fixed32Rules& FieldConstraints::_internal_fixed32() const {
  return type_case() == kFixed32
      ? *_impl_.type_.fixed32_
      : reinterpret_cast<::buf::validate::Fixed32Rules&>(::buf::validate::_Fixed32Rules_default_instance_);
}
inline const ::buf::validate::Fixed32Rules& FieldConstraints::fixed32() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.fixed32)
  return _internal_fixed32();
}
inline ::buf::validate::Fixed32Rules* FieldConstraints::unsafe_arena_release_fixed32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.fixed32)
  if (type_case() == kFixed32) {
    clear_has_type();
    ::buf::validate::Fixed32Rules* temp = _impl_.type_.fixed32_;
    _impl_.type_.fixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_fixed32(::buf::validate::Fixed32Rules* fixed32) {
  clear_type();
  if (fixed32) {
    set_has_fixed32();
    _impl_.type_.fixed32_ = fixed32;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.fixed32)
}
inline ::buf::validate::Fixed32Rules* FieldConstraints::_internal_mutable_fixed32() {
  if (type_case() != kFixed32) {
    clear_type();
    set_has_fixed32();
    _impl_.type_.fixed32_ = CreateMaybeMessage< ::buf::validate::Fixed32Rules >(GetArenaForAllocation());
  }
  return _impl_.type_.fixed32_;
}
inline ::buf::validate::Fixed32Rules* FieldConstraints::mutable_fixed32() {
  ::buf::validate::Fixed32Rules* _msg = _internal_mutable_fixed32();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.fixed32)
  return _msg;
}

// .buf.validate.Fixed64Rules fixed64 = 10 [json_name = "fixed64"];
inline bool FieldConstraints::has_fixed64() const {
  return type_case() == kFixed64;
}
inline bool FieldConstraints::_internal_has_fixed64() const {
  return type_case() == kFixed64;
}
inline void FieldConstraints::set_has_fixed64() {
  _impl_._oneof_case_[0] = kFixed64;
}
inline void FieldConstraints::clear_fixed64() {
  if (type_case() == kFixed64) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.fixed64_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::Fixed64Rules* FieldConstraints::release_fixed64() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.fixed64)
  if (type_case() == kFixed64) {
    clear_has_type();
    ::buf::validate::Fixed64Rules* temp = _impl_.type_.fixed64_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.fixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::Fixed64Rules& FieldConstraints::_internal_fixed64() const {
  return type_case() == kFixed64
      ? *_impl_.type_.fixed64_
      : reinterpret_cast<::buf::validate::Fixed64Rules&>(::buf::validate::_Fixed64Rules_default_instance_);
}
inline const ::buf::validate::Fixed64Rules& FieldConstraints::fixed64() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.fixed64)
  return _internal_fixed64();
}
inline ::buf::validate::Fixed64Rules* FieldConstraints::unsafe_arena_release_fixed64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.fixed64)
  if (type_case() == kFixed64) {
    clear_has_type();
    ::buf::validate::Fixed64Rules* temp = _impl_.type_.fixed64_;
    _impl_.type_.fixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_fixed64(::buf::validate::Fixed64Rules* fixed64) {
  clear_type();
  if (fixed64) {
    set_has_fixed64();
    _impl_.type_.fixed64_ = fixed64;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.fixed64)
}
inline ::buf::validate::Fixed64Rules* FieldConstraints::_internal_mutable_fixed64() {
  if (type_case() != kFixed64) {
    clear_type();
    set_has_fixed64();
    _impl_.type_.fixed64_ = CreateMaybeMessage< ::buf::validate::Fixed64Rules >(GetArenaForAllocation());
  }
  return _impl_.type_.fixed64_;
}
inline ::buf::validate::Fixed64Rules* FieldConstraints::mutable_fixed64() {
  ::buf::validate::Fixed64Rules* _msg = _internal_mutable_fixed64();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.fixed64)
  return _msg;
}

// .buf.validate.SFixed32Rules sfixed32 = 11 [json_name = "sfixed32"];
inline bool FieldConstraints::has_sfixed32() const {
  return type_case() == kSfixed32;
}
inline bool FieldConstraints::_internal_has_sfixed32() const {
  return type_case() == kSfixed32;
}
inline void FieldConstraints::set_has_sfixed32() {
  _impl_._oneof_case_[0] = kSfixed32;
}
inline void FieldConstraints::clear_sfixed32() {
  if (type_case() == kSfixed32) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.sfixed32_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::SFixed32Rules* FieldConstraints::release_sfixed32() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.sfixed32)
  if (type_case() == kSfixed32) {
    clear_has_type();
    ::buf::validate::SFixed32Rules* temp = _impl_.type_.sfixed32_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sfixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::SFixed32Rules& FieldConstraints::_internal_sfixed32() const {
  return type_case() == kSfixed32
      ? *_impl_.type_.sfixed32_
      : reinterpret_cast<::buf::validate::SFixed32Rules&>(::buf::validate::_SFixed32Rules_default_instance_);
}
inline const ::buf::validate::SFixed32Rules& FieldConstraints::sfixed32() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.sfixed32)
  return _internal_sfixed32();
}
inline ::buf::validate::SFixed32Rules* FieldConstraints::unsafe_arena_release_sfixed32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.sfixed32)
  if (type_case() == kSfixed32) {
    clear_has_type();
    ::buf::validate::SFixed32Rules* temp = _impl_.type_.sfixed32_;
    _impl_.type_.sfixed32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_sfixed32(::buf::validate::SFixed32Rules* sfixed32) {
  clear_type();
  if (sfixed32) {
    set_has_sfixed32();
    _impl_.type_.sfixed32_ = sfixed32;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.sfixed32)
}
inline ::buf::validate::SFixed32Rules* FieldConstraints::_internal_mutable_sfixed32() {
  if (type_case() != kSfixed32) {
    clear_type();
    set_has_sfixed32();
    _impl_.type_.sfixed32_ = CreateMaybeMessage< ::buf::validate::SFixed32Rules >(GetArenaForAllocation());
  }
  return _impl_.type_.sfixed32_;
}
inline ::buf::validate::SFixed32Rules* FieldConstraints::mutable_sfixed32() {
  ::buf::validate::SFixed32Rules* _msg = _internal_mutable_sfixed32();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.sfixed32)
  return _msg;
}

// .buf.validate.SFixed64Rules sfixed64 = 12 [json_name = "sfixed64"];
inline bool FieldConstraints::has_sfixed64() const {
  return type_case() == kSfixed64;
}
inline bool FieldConstraints::_internal_has_sfixed64() const {
  return type_case() == kSfixed64;
}
inline void FieldConstraints::set_has_sfixed64() {
  _impl_._oneof_case_[0] = kSfixed64;
}
inline void FieldConstraints::clear_sfixed64() {
  if (type_case() == kSfixed64) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.sfixed64_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::SFixed64Rules* FieldConstraints::release_sfixed64() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.sfixed64)
  if (type_case() == kSfixed64) {
    clear_has_type();
    ::buf::validate::SFixed64Rules* temp = _impl_.type_.sfixed64_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sfixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::SFixed64Rules& FieldConstraints::_internal_sfixed64() const {
  return type_case() == kSfixed64
      ? *_impl_.type_.sfixed64_
      : reinterpret_cast<::buf::validate::SFixed64Rules&>(::buf::validate::_SFixed64Rules_default_instance_);
}
inline const ::buf::validate::SFixed64Rules& FieldConstraints::sfixed64() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.sfixed64)
  return _internal_sfixed64();
}
inline ::buf::validate::SFixed64Rules* FieldConstraints::unsafe_arena_release_sfixed64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.sfixed64)
  if (type_case() == kSfixed64) {
    clear_has_type();
    ::buf::validate::SFixed64Rules* temp = _impl_.type_.sfixed64_;
    _impl_.type_.sfixed64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_sfixed64(::buf::validate::SFixed64Rules* sfixed64) {
  clear_type();
  if (sfixed64) {
    set_has_sfixed64();
    _impl_.type_.sfixed64_ = sfixed64;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.sfixed64)
}
inline ::buf::validate::SFixed64Rules* FieldConstraints::_internal_mutable_sfixed64() {
  if (type_case() != kSfixed64) {
    clear_type();
    set_has_sfixed64();
    _impl_.type_.sfixed64_ = CreateMaybeMessage< ::buf::validate::SFixed64Rules >(GetArenaForAllocation());
  }
  return _impl_.type_.sfixed64_;
}
inline ::buf::validate::SFixed64Rules* FieldConstraints::mutable_sfixed64() {
  ::buf::validate::SFixed64Rules* _msg = _internal_mutable_sfixed64();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.sfixed64)
  return _msg;
}

// .buf.validate.BoolRules bool = 13 [json_name = "bool"];
inline bool FieldConstraints::has_bool_() const {
  return type_case() == kBool;
}
inline bool FieldConstraints::_internal_has_bool_() const {
  return type_case() == kBool;
}
inline void FieldConstraints::set_has_bool_() {
  _impl_._oneof_case_[0] = kBool;
}
inline void FieldConstraints::clear_bool_() {
  if (type_case() == kBool) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.bool__;
    }
    clear_has_type();
  }
}
inline ::buf::validate::BoolRules* FieldConstraints::release_bool_() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.bool)
  if (type_case() == kBool) {
    clear_has_type();
    ::buf::validate::BoolRules* temp = _impl_.type_.bool__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::BoolRules& FieldConstraints::_internal_bool_() const {
  return type_case() == kBool
      ? *_impl_.type_.bool__
      : reinterpret_cast<::buf::validate::BoolRules&>(::buf::validate::_BoolRules_default_instance_);
}
inline const ::buf::validate::BoolRules& FieldConstraints::bool_() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.bool)
  return _internal_bool_();
}
inline ::buf::validate::BoolRules* FieldConstraints::unsafe_arena_release_bool_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.bool)
  if (type_case() == kBool) {
    clear_has_type();
    ::buf::validate::BoolRules* temp = _impl_.type_.bool__;
    _impl_.type_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_bool_(::buf::validate::BoolRules* bool_) {
  clear_type();
  if (bool_) {
    set_has_bool_();
    _impl_.type_.bool__ = bool_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.bool)
}
inline ::buf::validate::BoolRules* FieldConstraints::_internal_mutable_bool_() {
  if (type_case() != kBool) {
    clear_type();
    set_has_bool_();
    _impl_.type_.bool__ = CreateMaybeMessage< ::buf::validate::BoolRules >(GetArenaForAllocation());
  }
  return _impl_.type_.bool__;
}
inline ::buf::validate::BoolRules* FieldConstraints::mutable_bool_() {
  ::buf::validate::BoolRules* _msg = _internal_mutable_bool_();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.bool)
  return _msg;
}

// .buf.validate.StringRules string = 14 [json_name = "string"];
inline bool FieldConstraints::has_string() const {
  return type_case() == kString;
}
inline bool FieldConstraints::_internal_has_string() const {
  return type_case() == kString;
}
inline void FieldConstraints::set_has_string() {
  _impl_._oneof_case_[0] = kString;
}
inline void FieldConstraints::clear_string() {
  if (type_case() == kString) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.string_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::StringRules* FieldConstraints::release_string() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.string)
  if (type_case() == kString) {
    clear_has_type();
    ::buf::validate::StringRules* temp = _impl_.type_.string_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::StringRules& FieldConstraints::_internal_string() const {
  return type_case() == kString
      ? *_impl_.type_.string_
      : reinterpret_cast<::buf::validate::StringRules&>(::buf::validate::_StringRules_default_instance_);
}
inline const ::buf::validate::StringRules& FieldConstraints::string() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.string)
  return _internal_string();
}
inline ::buf::validate::StringRules* FieldConstraints::unsafe_arena_release_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.string)
  if (type_case() == kString) {
    clear_has_type();
    ::buf::validate::StringRules* temp = _impl_.type_.string_;
    _impl_.type_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_string(::buf::validate::StringRules* string) {
  clear_type();
  if (string) {
    set_has_string();
    _impl_.type_.string_ = string;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.string)
}
inline ::buf::validate::StringRules* FieldConstraints::_internal_mutable_string() {
  if (type_case() != kString) {
    clear_type();
    set_has_string();
    _impl_.type_.string_ = CreateMaybeMessage< ::buf::validate::StringRules >(GetArenaForAllocation());
  }
  return _impl_.type_.string_;
}
inline ::buf::validate::StringRules* FieldConstraints::mutable_string() {
  ::buf::validate::StringRules* _msg = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.string)
  return _msg;
}

// .buf.validate.BytesRules bytes = 15 [json_name = "bytes"];
inline bool FieldConstraints::has_bytes() const {
  return type_case() == kBytes;
}
inline bool FieldConstraints::_internal_has_bytes() const {
  return type_case() == kBytes;
}
inline void FieldConstraints::set_has_bytes() {
  _impl_._oneof_case_[0] = kBytes;
}
inline void FieldConstraints::clear_bytes() {
  if (type_case() == kBytes) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.bytes_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::BytesRules* FieldConstraints::release_bytes() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.bytes)
  if (type_case() == kBytes) {
    clear_has_type();
    ::buf::validate::BytesRules* temp = _impl_.type_.bytes_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::BytesRules& FieldConstraints::_internal_bytes() const {
  return type_case() == kBytes
      ? *_impl_.type_.bytes_
      : reinterpret_cast<::buf::validate::BytesRules&>(::buf::validate::_BytesRules_default_instance_);
}
inline const ::buf::validate::BytesRules& FieldConstraints::bytes() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.bytes)
  return _internal_bytes();
}
inline ::buf::validate::BytesRules* FieldConstraints::unsafe_arena_release_bytes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.bytes)
  if (type_case() == kBytes) {
    clear_has_type();
    ::buf::validate::BytesRules* temp = _impl_.type_.bytes_;
    _impl_.type_.bytes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_bytes(::buf::validate::BytesRules* bytes) {
  clear_type();
  if (bytes) {
    set_has_bytes();
    _impl_.type_.bytes_ = bytes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.bytes)
}
inline ::buf::validate::BytesRules* FieldConstraints::_internal_mutable_bytes() {
  if (type_case() != kBytes) {
    clear_type();
    set_has_bytes();
    _impl_.type_.bytes_ = CreateMaybeMessage< ::buf::validate::BytesRules >(GetArenaForAllocation());
  }
  return _impl_.type_.bytes_;
}
inline ::buf::validate::BytesRules* FieldConstraints::mutable_bytes() {
  ::buf::validate::BytesRules* _msg = _internal_mutable_bytes();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.bytes)
  return _msg;
}

// .buf.validate.EnumRules enum = 16 [json_name = "enum"];
inline bool FieldConstraints::has_enum_() const {
  return type_case() == kEnum;
}
inline bool FieldConstraints::_internal_has_enum_() const {
  return type_case() == kEnum;
}
inline void FieldConstraints::set_has_enum_() {
  _impl_._oneof_case_[0] = kEnum;
}
inline void FieldConstraints::clear_enum_() {
  if (type_case() == kEnum) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.enum__;
    }
    clear_has_type();
  }
}
inline ::buf::validate::EnumRules* FieldConstraints::release_enum_() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.enum)
  if (type_case() == kEnum) {
    clear_has_type();
    ::buf::validate::EnumRules* temp = _impl_.type_.enum__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.enum__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::EnumRules& FieldConstraints::_internal_enum_() const {
  return type_case() == kEnum
      ? *_impl_.type_.enum__
      : reinterpret_cast<::buf::validate::EnumRules&>(::buf::validate::_EnumRules_default_instance_);
}
inline const ::buf::validate::EnumRules& FieldConstraints::enum_() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.enum)
  return _internal_enum_();
}
inline ::buf::validate::EnumRules* FieldConstraints::unsafe_arena_release_enum_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.enum)
  if (type_case() == kEnum) {
    clear_has_type();
    ::buf::validate::EnumRules* temp = _impl_.type_.enum__;
    _impl_.type_.enum__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_enum_(::buf::validate::EnumRules* enum_) {
  clear_type();
  if (enum_) {
    set_has_enum_();
    _impl_.type_.enum__ = enum_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.enum)
}
inline ::buf::validate::EnumRules* FieldConstraints::_internal_mutable_enum_() {
  if (type_case() != kEnum) {
    clear_type();
    set_has_enum_();
    _impl_.type_.enum__ = CreateMaybeMessage< ::buf::validate::EnumRules >(GetArenaForAllocation());
  }
  return _impl_.type_.enum__;
}
inline ::buf::validate::EnumRules* FieldConstraints::mutable_enum_() {
  ::buf::validate::EnumRules* _msg = _internal_mutable_enum_();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.enum)
  return _msg;
}

// .buf.validate.RepeatedRules repeated = 18 [json_name = "repeated"];
inline bool FieldConstraints::has_repeated() const {
  return type_case() == kRepeated;
}
inline bool FieldConstraints::_internal_has_repeated() const {
  return type_case() == kRepeated;
}
inline void FieldConstraints::set_has_repeated() {
  _impl_._oneof_case_[0] = kRepeated;
}
inline void FieldConstraints::clear_repeated() {
  if (type_case() == kRepeated) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.repeated_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::RepeatedRules* FieldConstraints::release_repeated() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.repeated)
  if (type_case() == kRepeated) {
    clear_has_type();
    ::buf::validate::RepeatedRules* temp = _impl_.type_.repeated_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.repeated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::RepeatedRules& FieldConstraints::_internal_repeated() const {
  return type_case() == kRepeated
      ? *_impl_.type_.repeated_
      : reinterpret_cast<::buf::validate::RepeatedRules&>(::buf::validate::_RepeatedRules_default_instance_);
}
inline const ::buf::validate::RepeatedRules& FieldConstraints::repeated() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.repeated)
  return _internal_repeated();
}
inline ::buf::validate::RepeatedRules* FieldConstraints::unsafe_arena_release_repeated() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.repeated)
  if (type_case() == kRepeated) {
    clear_has_type();
    ::buf::validate::RepeatedRules* temp = _impl_.type_.repeated_;
    _impl_.type_.repeated_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_repeated(::buf::validate::RepeatedRules* repeated) {
  clear_type();
  if (repeated) {
    set_has_repeated();
    _impl_.type_.repeated_ = repeated;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.repeated)
}
inline ::buf::validate::RepeatedRules* FieldConstraints::_internal_mutable_repeated() {
  if (type_case() != kRepeated) {
    clear_type();
    set_has_repeated();
    _impl_.type_.repeated_ = CreateMaybeMessage< ::buf::validate::RepeatedRules >(GetArenaForAllocation());
  }
  return _impl_.type_.repeated_;
}
inline ::buf::validate::RepeatedRules* FieldConstraints::mutable_repeated() {
  ::buf::validate::RepeatedRules* _msg = _internal_mutable_repeated();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.repeated)
  return _msg;
}

// .buf.validate.MapRules map = 19 [json_name = "map"];
inline bool FieldConstraints::has_map() const {
  return type_case() == kMap;
}
inline bool FieldConstraints::_internal_has_map() const {
  return type_case() == kMap;
}
inline void FieldConstraints::set_has_map() {
  _impl_._oneof_case_[0] = kMap;
}
inline void FieldConstraints::clear_map() {
  if (type_case() == kMap) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.map_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::MapRules* FieldConstraints::release_map() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.map)
  if (type_case() == kMap) {
    clear_has_type();
    ::buf::validate::MapRules* temp = _impl_.type_.map_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::MapRules& FieldConstraints::_internal_map() const {
  return type_case() == kMap
      ? *_impl_.type_.map_
      : reinterpret_cast<::buf::validate::MapRules&>(::buf::validate::_MapRules_default_instance_);
}
inline const ::buf::validate::MapRules& FieldConstraints::map() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.map)
  return _internal_map();
}
inline ::buf::validate::MapRules* FieldConstraints::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.map)
  if (type_case() == kMap) {
    clear_has_type();
    ::buf::validate::MapRules* temp = _impl_.type_.map_;
    _impl_.type_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_map(::buf::validate::MapRules* map) {
  clear_type();
  if (map) {
    set_has_map();
    _impl_.type_.map_ = map;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.map)
}
inline ::buf::validate::MapRules* FieldConstraints::_internal_mutable_map() {
  if (type_case() != kMap) {
    clear_type();
    set_has_map();
    _impl_.type_.map_ = CreateMaybeMessage< ::buf::validate::MapRules >(GetArenaForAllocation());
  }
  return _impl_.type_.map_;
}
inline ::buf::validate::MapRules* FieldConstraints::mutable_map() {
  ::buf::validate::MapRules* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.map)
  return _msg;
}

// .buf.validate.AnyRules any = 20 [json_name = "any"];
inline bool FieldConstraints::has_any() const {
  return type_case() == kAny;
}
inline bool FieldConstraints::_internal_has_any() const {
  return type_case() == kAny;
}
inline void FieldConstraints::set_has_any() {
  _impl_._oneof_case_[0] = kAny;
}
inline void FieldConstraints::clear_any() {
  if (type_case() == kAny) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.any_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::AnyRules* FieldConstraints::release_any() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.any)
  if (type_case() == kAny) {
    clear_has_type();
    ::buf::validate::AnyRules* temp = _impl_.type_.any_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.any_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::AnyRules& FieldConstraints::_internal_any() const {
  return type_case() == kAny
      ? *_impl_.type_.any_
      : reinterpret_cast<::buf::validate::AnyRules&>(::buf::validate::_AnyRules_default_instance_);
}
inline const ::buf::validate::AnyRules& FieldConstraints::any() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.any)
  return _internal_any();
}
inline ::buf::validate::AnyRules* FieldConstraints::unsafe_arena_release_any() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.any)
  if (type_case() == kAny) {
    clear_has_type();
    ::buf::validate::AnyRules* temp = _impl_.type_.any_;
    _impl_.type_.any_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_any(::buf::validate::AnyRules* any) {
  clear_type();
  if (any) {
    set_has_any();
    _impl_.type_.any_ = any;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.any)
}
inline ::buf::validate::AnyRules* FieldConstraints::_internal_mutable_any() {
  if (type_case() != kAny) {
    clear_type();
    set_has_any();
    _impl_.type_.any_ = CreateMaybeMessage< ::buf::validate::AnyRules >(GetArenaForAllocation());
  }
  return _impl_.type_.any_;
}
inline ::buf::validate::AnyRules* FieldConstraints::mutable_any() {
  ::buf::validate::AnyRules* _msg = _internal_mutable_any();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.any)
  return _msg;
}

// .buf.validate.DurationRules duration = 21 [json_name = "duration"];
inline bool FieldConstraints::has_duration() const {
  return type_case() == kDuration;
}
inline bool FieldConstraints::_internal_has_duration() const {
  return type_case() == kDuration;
}
inline void FieldConstraints::set_has_duration() {
  _impl_._oneof_case_[0] = kDuration;
}
inline void FieldConstraints::clear_duration() {
  if (type_case() == kDuration) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.duration_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::DurationRules* FieldConstraints::release_duration() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.duration)
  if (type_case() == kDuration) {
    clear_has_type();
    ::buf::validate::DurationRules* temp = _impl_.type_.duration_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::DurationRules& FieldConstraints::_internal_duration() const {
  return type_case() == kDuration
      ? *_impl_.type_.duration_
      : reinterpret_cast<::buf::validate::DurationRules&>(::buf::validate::_DurationRules_default_instance_);
}
inline const ::buf::validate::DurationRules& FieldConstraints::duration() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.duration)
  return _internal_duration();
}
inline ::buf::validate::DurationRules* FieldConstraints::unsafe_arena_release_duration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.duration)
  if (type_case() == kDuration) {
    clear_has_type();
    ::buf::validate::DurationRules* temp = _impl_.type_.duration_;
    _impl_.type_.duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_duration(::buf::validate::DurationRules* duration) {
  clear_type();
  if (duration) {
    set_has_duration();
    _impl_.type_.duration_ = duration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.duration)
}
inline ::buf::validate::DurationRules* FieldConstraints::_internal_mutable_duration() {
  if (type_case() != kDuration) {
    clear_type();
    set_has_duration();
    _impl_.type_.duration_ = CreateMaybeMessage< ::buf::validate::DurationRules >(GetArenaForAllocation());
  }
  return _impl_.type_.duration_;
}
inline ::buf::validate::DurationRules* FieldConstraints::mutable_duration() {
  ::buf::validate::DurationRules* _msg = _internal_mutable_duration();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.duration)
  return _msg;
}

// .buf.validate.TimestampRules timestamp = 22 [json_name = "timestamp"];
inline bool FieldConstraints::has_timestamp() const {
  return type_case() == kTimestamp;
}
inline bool FieldConstraints::_internal_has_timestamp() const {
  return type_case() == kTimestamp;
}
inline void FieldConstraints::set_has_timestamp() {
  _impl_._oneof_case_[0] = kTimestamp;
}
inline void FieldConstraints::clear_timestamp() {
  if (type_case() == kTimestamp) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.timestamp_;
    }
    clear_has_type();
  }
}
inline ::buf::validate::TimestampRules* FieldConstraints::release_timestamp() {
  // @@protoc_insertion_point(field_release:buf.validate.FieldConstraints.timestamp)
  if (type_case() == kTimestamp) {
    clear_has_type();
    ::buf::validate::TimestampRules* temp = _impl_.type_.timestamp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::buf::validate::TimestampRules& FieldConstraints::_internal_timestamp() const {
  return type_case() == kTimestamp
      ? *_impl_.type_.timestamp_
      : reinterpret_cast<::buf::validate::TimestampRules&>(::buf::validate::_TimestampRules_default_instance_);
}
inline const ::buf::validate::TimestampRules& FieldConstraints::timestamp() const {
  // @@protoc_insertion_point(field_get:buf.validate.FieldConstraints.timestamp)
  return _internal_timestamp();
}
inline ::buf::validate::TimestampRules* FieldConstraints::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.FieldConstraints.timestamp)
  if (type_case() == kTimestamp) {
    clear_has_type();
    ::buf::validate::TimestampRules* temp = _impl_.type_.timestamp_;
    _impl_.type_.timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FieldConstraints::unsafe_arena_set_allocated_timestamp(::buf::validate::TimestampRules* timestamp) {
  clear_type();
  if (timestamp) {
    set_has_timestamp();
    _impl_.type_.timestamp_ = timestamp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.FieldConstraints.timestamp)
}
inline ::buf::validate::TimestampRules* FieldConstraints::_internal_mutable_timestamp() {
  if (type_case() != kTimestamp) {
    clear_type();
    set_has_timestamp();
    _impl_.type_.timestamp_ = CreateMaybeMessage< ::buf::validate::TimestampRules >(GetArenaForAllocation());
  }
  return _impl_.type_.timestamp_;
}
inline ::buf::validate::TimestampRules* FieldConstraints::mutable_timestamp() {
  ::buf::validate::TimestampRules* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:buf.validate.FieldConstraints.timestamp)
  return _msg;
}

inline bool FieldConstraints::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void FieldConstraints::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline FieldConstraints::TypeCase FieldConstraints::type_case() const {
  return FieldConstraints::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FloatRules

// optional float const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool FloatRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FloatRules::clear_const_() {
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float FloatRules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.const)
  return _internal_const_();
}
inline void FloatRules::set_const_(float value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.const)
}
inline float FloatRules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void FloatRules::_internal_set_const_(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// float lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool FloatRules::has_lt() const {
  return less_than_case() == kLt;
}
inline void FloatRules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void FloatRules::clear_lt() {
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0;
    clear_has_less_than();
  }
}
inline float FloatRules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.lt)
  return _internal_lt();
}
inline void FloatRules::set_lt(float value) {
  _internal_set_lt(value);
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.lt)
}
inline float FloatRules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0;
}
inline void FloatRules::_internal_set_lt(float value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
}

// float lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool FloatRules::has_lte() const {
  return less_than_case() == kLte;
}
inline void FloatRules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void FloatRules::clear_lte() {
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0;
    clear_has_less_than();
  }
}
inline float FloatRules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.lte)
  return _internal_lte();
}
inline void FloatRules::set_lte(float value) {
  _internal_set_lte(value);
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.lte)
}
inline float FloatRules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0;
}
inline void FloatRules::_internal_set_lte(float value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
}

// float gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool FloatRules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void FloatRules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void FloatRules::clear_gt() {
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0;
    clear_has_greater_than();
  }
}
inline float FloatRules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.gt)
  return _internal_gt();
}
inline void FloatRules::set_gt(float value) {
  _internal_set_gt(value);
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.gt)
}
inline float FloatRules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0;
}
inline void FloatRules::_internal_set_gt(float value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
}

// float gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool FloatRules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void FloatRules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void FloatRules::clear_gte() {
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0;
    clear_has_greater_than();
  }
}
inline float FloatRules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.gte)
  return _internal_gte();
}
inline void FloatRules::set_gte(float value) {
  _internal_set_gte(value);
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.gte)
}
inline float FloatRules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0;
}
inline void FloatRules::_internal_set_gte(float value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
}

// repeated float in = 6 [json_name = "in", (.buf.validate.priv.field) = {
inline int FloatRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int FloatRules::in_size() const {
  return _internal_in_size();
}
inline void FloatRules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline float FloatRules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.in)
  return _internal_in().Get(index);
}
inline void FloatRules::set_in(int index, float value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.in)
}
inline void FloatRules::add_in(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.FloatRules.in)
}
inline const ::google::protobuf::RepeatedField<float>& FloatRules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.FloatRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<float>* FloatRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.FloatRules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}

inline const ::google::protobuf::RepeatedField<float>& FloatRules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<float>* FloatRules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated float not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int FloatRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int FloatRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void FloatRules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline float FloatRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.not_in)
  return _internal_not_in().Get(index);
}
inline void FloatRules::set_not_in(int index, float value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.not_in)
}
inline void FloatRules::add_not_in(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.FloatRules.not_in)
}
inline const ::google::protobuf::RepeatedField<float>& FloatRules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.FloatRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<float>* FloatRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.FloatRules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}

inline const ::google::protobuf::RepeatedField<float>& FloatRules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<float>* FloatRules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

// bool finite = 8 [json_name = "finite", (.buf.validate.priv.field) = {
inline void FloatRules::clear_finite() {
  _impl_.finite_ = false;
}
inline bool FloatRules::finite() const {
  // @@protoc_insertion_point(field_get:buf.validate.FloatRules.finite)
  return _internal_finite();
}
inline void FloatRules::set_finite(bool value) {
  _internal_set_finite(value);
  // @@protoc_insertion_point(field_set:buf.validate.FloatRules.finite)
}
inline bool FloatRules::_internal_finite() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.finite_;
}
inline void FloatRules::_internal_set_finite(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.finite_ = value;
}

inline bool FloatRules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void FloatRules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool FloatRules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void FloatRules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline FloatRules::LessThanCase FloatRules::less_than_case() const {
  return FloatRules::LessThanCase(_impl_._oneof_case_[0]);
}
inline FloatRules::GreaterThanCase FloatRules::greater_than_case() const {
  return FloatRules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// DoubleRules

// optional double const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool DoubleRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DoubleRules::clear_const_() {
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double DoubleRules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.const)
  return _internal_const_();
}
inline void DoubleRules::set_const_(double value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.const)
}
inline double DoubleRules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void DoubleRules::_internal_set_const_(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// double lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool DoubleRules::has_lt() const {
  return less_than_case() == kLt;
}
inline void DoubleRules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void DoubleRules::clear_lt() {
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0;
    clear_has_less_than();
  }
}
inline double DoubleRules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.lt)
  return _internal_lt();
}
inline void DoubleRules::set_lt(double value) {
  _internal_set_lt(value);
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.lt)
}
inline double DoubleRules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0;
}
inline void DoubleRules::_internal_set_lt(double value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
}

// double lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool DoubleRules::has_lte() const {
  return less_than_case() == kLte;
}
inline void DoubleRules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void DoubleRules::clear_lte() {
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0;
    clear_has_less_than();
  }
}
inline double DoubleRules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.lte)
  return _internal_lte();
}
inline void DoubleRules::set_lte(double value) {
  _internal_set_lte(value);
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.lte)
}
inline double DoubleRules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0;
}
inline void DoubleRules::_internal_set_lte(double value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
}

// double gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool DoubleRules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void DoubleRules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void DoubleRules::clear_gt() {
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0;
    clear_has_greater_than();
  }
}
inline double DoubleRules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.gt)
  return _internal_gt();
}
inline void DoubleRules::set_gt(double value) {
  _internal_set_gt(value);
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.gt)
}
inline double DoubleRules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0;
}
inline void DoubleRules::_internal_set_gt(double value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
}

// double gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool DoubleRules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void DoubleRules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void DoubleRules::clear_gte() {
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0;
    clear_has_greater_than();
  }
}
inline double DoubleRules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.gte)
  return _internal_gte();
}
inline void DoubleRules::set_gte(double value) {
  _internal_set_gte(value);
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.gte)
}
inline double DoubleRules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0;
}
inline void DoubleRules::_internal_set_gte(double value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
}

// repeated double in = 6 [json_name = "in", (.buf.validate.priv.field) = {
inline int DoubleRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int DoubleRules::in_size() const {
  return _internal_in_size();
}
inline void DoubleRules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline double DoubleRules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.in)
  return _internal_in().Get(index);
}
inline void DoubleRules::set_in(int index, double value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.in)
}
inline void DoubleRules::add_in(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.DoubleRules.in)
}
inline const ::google::protobuf::RepeatedField<double>& DoubleRules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.DoubleRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<double>* DoubleRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.DoubleRules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}

inline const ::google::protobuf::RepeatedField<double>& DoubleRules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<double>* DoubleRules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated double not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int DoubleRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int DoubleRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void DoubleRules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline double DoubleRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.not_in)
  return _internal_not_in().Get(index);
}
inline void DoubleRules::set_not_in(int index, double value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.not_in)
}
inline void DoubleRules::add_not_in(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.DoubleRules.not_in)
}
inline const ::google::protobuf::RepeatedField<double>& DoubleRules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.DoubleRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<double>* DoubleRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.DoubleRules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}

inline const ::google::protobuf::RepeatedField<double>& DoubleRules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<double>* DoubleRules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

// bool finite = 8 [json_name = "finite", (.buf.validate.priv.field) = {
inline void DoubleRules::clear_finite() {
  _impl_.finite_ = false;
}
inline bool DoubleRules::finite() const {
  // @@protoc_insertion_point(field_get:buf.validate.DoubleRules.finite)
  return _internal_finite();
}
inline void DoubleRules::set_finite(bool value) {
  _internal_set_finite(value);
  // @@protoc_insertion_point(field_set:buf.validate.DoubleRules.finite)
}
inline bool DoubleRules::_internal_finite() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.finite_;
}
inline void DoubleRules::_internal_set_finite(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.finite_ = value;
}

inline bool DoubleRules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void DoubleRules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool DoubleRules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void DoubleRules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline DoubleRules::LessThanCase DoubleRules::less_than_case() const {
  return DoubleRules::LessThanCase(_impl_._oneof_case_[0]);
}
inline DoubleRules::GreaterThanCase DoubleRules::greater_than_case() const {
  return DoubleRules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Int32Rules

// optional int32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool Int32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Int32Rules::clear_const_() {
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Int32Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.const)
  return _internal_const_();
}
inline void Int32Rules::set_const_(::int32_t value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.const)
}
inline ::int32_t Int32Rules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void Int32Rules::_internal_set_const_(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// int32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool Int32Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void Int32Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void Int32Rules::clear_lt() {
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0;
    clear_has_less_than();
  }
}
inline ::int32_t Int32Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.lt)
  return _internal_lt();
}
inline void Int32Rules::set_lt(::int32_t value) {
  _internal_set_lt(value);
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.lt)
}
inline ::int32_t Int32Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0;
}
inline void Int32Rules::_internal_set_lt(::int32_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
}

// int32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool Int32Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void Int32Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void Int32Rules::clear_lte() {
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0;
    clear_has_less_than();
  }
}
inline ::int32_t Int32Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.lte)
  return _internal_lte();
}
inline void Int32Rules::set_lte(::int32_t value) {
  _internal_set_lte(value);
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.lte)
}
inline ::int32_t Int32Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0;
}
inline void Int32Rules::_internal_set_lte(::int32_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
}

// int32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool Int32Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void Int32Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void Int32Rules::clear_gt() {
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0;
    clear_has_greater_than();
  }
}
inline ::int32_t Int32Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.gt)
  return _internal_gt();
}
inline void Int32Rules::set_gt(::int32_t value) {
  _internal_set_gt(value);
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.gt)
}
inline ::int32_t Int32Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0;
}
inline void Int32Rules::_internal_set_gt(::int32_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
}

// int32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool Int32Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void Int32Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void Int32Rules::clear_gte() {
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0;
    clear_has_greater_than();
  }
}
inline ::int32_t Int32Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.gte)
  return _internal_gte();
}
inline void Int32Rules::set_gte(::int32_t value) {
  _internal_set_gte(value);
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.gte)
}
inline ::int32_t Int32Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0;
}
inline void Int32Rules::_internal_set_gte(::int32_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
}

// repeated int32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
inline int Int32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int Int32Rules::in_size() const {
  return _internal_in_size();
}
inline void Int32Rules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline ::int32_t Int32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.in)
  return _internal_in().Get(index);
}
inline void Int32Rules::set_in(int index, ::int32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.in)
}
inline void Int32Rules::add_in(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Int32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Int32Rules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.Int32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Int32Rules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& Int32Rules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32Rules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated int32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int Int32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int Int32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void Int32Rules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline ::int32_t Int32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Int32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void Int32Rules::set_not_in(int index, ::int32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Int32Rules.not_in)
}
inline void Int32Rules::add_not_in(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Int32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& Int32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.Int32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Int32Rules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& Int32Rules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* Int32Rules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

inline bool Int32Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void Int32Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool Int32Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void Int32Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline Int32Rules::LessThanCase Int32Rules::less_than_case() const {
  return Int32Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline Int32Rules::GreaterThanCase Int32Rules::greater_than_case() const {
  return Int32Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Int64Rules

// optional int64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool Int64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Int64Rules::clear_const_() {
  _impl_.const__ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t Int64Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.const)
  return _internal_const_();
}
inline void Int64Rules::set_const_(::int64_t value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.const)
}
inline ::int64_t Int64Rules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void Int64Rules::_internal_set_const_(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// int64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool Int64Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void Int64Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void Int64Rules::clear_lt() {
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = ::int64_t{0};
    clear_has_less_than();
  }
}
inline ::int64_t Int64Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.lt)
  return _internal_lt();
}
inline void Int64Rules::set_lt(::int64_t value) {
  _internal_set_lt(value);
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.lt)
}
inline ::int64_t Int64Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return ::int64_t{0};
}
inline void Int64Rules::_internal_set_lt(::int64_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
}

// int64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool Int64Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void Int64Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void Int64Rules::clear_lte() {
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = ::int64_t{0};
    clear_has_less_than();
  }
}
inline ::int64_t Int64Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.lte)
  return _internal_lte();
}
inline void Int64Rules::set_lte(::int64_t value) {
  _internal_set_lte(value);
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.lte)
}
inline ::int64_t Int64Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return ::int64_t{0};
}
inline void Int64Rules::_internal_set_lte(::int64_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
}

// int64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool Int64Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void Int64Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void Int64Rules::clear_gt() {
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = ::int64_t{0};
    clear_has_greater_than();
  }
}
inline ::int64_t Int64Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.gt)
  return _internal_gt();
}
inline void Int64Rules::set_gt(::int64_t value) {
  _internal_set_gt(value);
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.gt)
}
inline ::int64_t Int64Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return ::int64_t{0};
}
inline void Int64Rules::_internal_set_gt(::int64_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
}

// int64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool Int64Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void Int64Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void Int64Rules::clear_gte() {
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = ::int64_t{0};
    clear_has_greater_than();
  }
}
inline ::int64_t Int64Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.gte)
  return _internal_gte();
}
inline void Int64Rules::set_gte(::int64_t value) {
  _internal_set_gte(value);
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.gte)
}
inline ::int64_t Int64Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return ::int64_t{0};
}
inline void Int64Rules::_internal_set_gte(::int64_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
}

// repeated int64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
inline int Int64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int Int64Rules::in_size() const {
  return _internal_in_size();
}
inline void Int64Rules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline ::int64_t Int64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.in)
  return _internal_in().Get(index);
}
inline void Int64Rules::set_in(int index, ::int64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.in)
}
inline void Int64Rules::add_in(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Int64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Int64Rules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.Int64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Int64Rules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}

inline const ::google::protobuf::RepeatedField<::int64_t>& Int64Rules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64Rules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated int64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int Int64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int Int64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void Int64Rules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline ::int64_t Int64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Int64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void Int64Rules::set_not_in(int index, ::int64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Int64Rules.not_in)
}
inline void Int64Rules::add_not_in(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Int64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& Int64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.Int64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Int64Rules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}

inline const ::google::protobuf::RepeatedField<::int64_t>& Int64Rules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* Int64Rules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

inline bool Int64Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void Int64Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool Int64Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void Int64Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline Int64Rules::LessThanCase Int64Rules::less_than_case() const {
  return Int64Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline Int64Rules::GreaterThanCase Int64Rules::greater_than_case() const {
  return Int64Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// UInt32Rules

// optional uint32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool UInt32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UInt32Rules::clear_const_() {
  _impl_.const__ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t UInt32Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.const)
  return _internal_const_();
}
inline void UInt32Rules::set_const_(::uint32_t value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.const)
}
inline ::uint32_t UInt32Rules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void UInt32Rules::_internal_set_const_(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// uint32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool UInt32Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void UInt32Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void UInt32Rules::clear_lt() {
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0u;
    clear_has_less_than();
  }
}
inline ::uint32_t UInt32Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.lt)
  return _internal_lt();
}
inline void UInt32Rules::set_lt(::uint32_t value) {
  _internal_set_lt(value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.lt)
}
inline ::uint32_t UInt32Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0u;
}
inline void UInt32Rules::_internal_set_lt(::uint32_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
}

// uint32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool UInt32Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void UInt32Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void UInt32Rules::clear_lte() {
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0u;
    clear_has_less_than();
  }
}
inline ::uint32_t UInt32Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.lte)
  return _internal_lte();
}
inline void UInt32Rules::set_lte(::uint32_t value) {
  _internal_set_lte(value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.lte)
}
inline ::uint32_t UInt32Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0u;
}
inline void UInt32Rules::_internal_set_lte(::uint32_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
}

// uint32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool UInt32Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void UInt32Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void UInt32Rules::clear_gt() {
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0u;
    clear_has_greater_than();
  }
}
inline ::uint32_t UInt32Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.gt)
  return _internal_gt();
}
inline void UInt32Rules::set_gt(::uint32_t value) {
  _internal_set_gt(value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.gt)
}
inline ::uint32_t UInt32Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0u;
}
inline void UInt32Rules::_internal_set_gt(::uint32_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
}

// uint32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool UInt32Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void UInt32Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void UInt32Rules::clear_gte() {
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0u;
    clear_has_greater_than();
  }
}
inline ::uint32_t UInt32Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.gte)
  return _internal_gte();
}
inline void UInt32Rules::set_gte(::uint32_t value) {
  _internal_set_gte(value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.gte)
}
inline ::uint32_t UInt32Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0u;
}
inline void UInt32Rules::_internal_set_gte(::uint32_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
}

// repeated uint32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
inline int UInt32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int UInt32Rules::in_size() const {
  return _internal_in_size();
}
inline void UInt32Rules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline ::uint32_t UInt32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.in)
  return _internal_in().Get(index);
}
inline void UInt32Rules::set_in(int index, ::uint32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.in)
}
inline void UInt32Rules::add_in(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.UInt32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& UInt32Rules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.UInt32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* UInt32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.UInt32Rules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}

inline const ::google::protobuf::RepeatedField<::uint32_t>& UInt32Rules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* UInt32Rules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated uint32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int UInt32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int UInt32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void UInt32Rules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline ::uint32_t UInt32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void UInt32Rules::set_not_in(int index, ::uint32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt32Rules.not_in)
}
inline void UInt32Rules::add_not_in(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.UInt32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& UInt32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.UInt32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* UInt32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.UInt32Rules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}

inline const ::google::protobuf::RepeatedField<::uint32_t>& UInt32Rules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* UInt32Rules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

inline bool UInt32Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void UInt32Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool UInt32Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void UInt32Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline UInt32Rules::LessThanCase UInt32Rules::less_than_case() const {
  return UInt32Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline UInt32Rules::GreaterThanCase UInt32Rules::greater_than_case() const {
  return UInt32Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// UInt64Rules

// optional uint64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool UInt64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UInt64Rules::clear_const_() {
  _impl_.const__ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t UInt64Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.const)
  return _internal_const_();
}
inline void UInt64Rules::set_const_(::uint64_t value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.const)
}
inline ::uint64_t UInt64Rules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void UInt64Rules::_internal_set_const_(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// uint64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool UInt64Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void UInt64Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void UInt64Rules::clear_lt() {
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = ::uint64_t{0u};
    clear_has_less_than();
  }
}
inline ::uint64_t UInt64Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.lt)
  return _internal_lt();
}
inline void UInt64Rules::set_lt(::uint64_t value) {
  _internal_set_lt(value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.lt)
}
inline ::uint64_t UInt64Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return ::uint64_t{0u};
}
inline void UInt64Rules::_internal_set_lt(::uint64_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
}

// uint64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool UInt64Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void UInt64Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void UInt64Rules::clear_lte() {
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = ::uint64_t{0u};
    clear_has_less_than();
  }
}
inline ::uint64_t UInt64Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.lte)
  return _internal_lte();
}
inline void UInt64Rules::set_lte(::uint64_t value) {
  _internal_set_lte(value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.lte)
}
inline ::uint64_t UInt64Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return ::uint64_t{0u};
}
inline void UInt64Rules::_internal_set_lte(::uint64_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
}

// uint64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool UInt64Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void UInt64Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void UInt64Rules::clear_gt() {
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = ::uint64_t{0u};
    clear_has_greater_than();
  }
}
inline ::uint64_t UInt64Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.gt)
  return _internal_gt();
}
inline void UInt64Rules::set_gt(::uint64_t value) {
  _internal_set_gt(value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.gt)
}
inline ::uint64_t UInt64Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return ::uint64_t{0u};
}
inline void UInt64Rules::_internal_set_gt(::uint64_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
}

// uint64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool UInt64Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void UInt64Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void UInt64Rules::clear_gte() {
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = ::uint64_t{0u};
    clear_has_greater_than();
  }
}
inline ::uint64_t UInt64Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.gte)
  return _internal_gte();
}
inline void UInt64Rules::set_gte(::uint64_t value) {
  _internal_set_gte(value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.gte)
}
inline ::uint64_t UInt64Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return ::uint64_t{0u};
}
inline void UInt64Rules::_internal_set_gte(::uint64_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
}

// repeated uint64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
inline int UInt64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int UInt64Rules::in_size() const {
  return _internal_in_size();
}
inline void UInt64Rules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline ::uint64_t UInt64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.in)
  return _internal_in().Get(index);
}
inline void UInt64Rules::set_in(int index, ::uint64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.in)
}
inline void UInt64Rules::add_in(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.UInt64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& UInt64Rules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.UInt64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* UInt64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.UInt64Rules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}

inline const ::google::protobuf::RepeatedField<::uint64_t>& UInt64Rules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* UInt64Rules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated uint64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int UInt64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int UInt64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void UInt64Rules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline ::uint64_t UInt64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.UInt64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void UInt64Rules::set_not_in(int index, ::uint64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.UInt64Rules.not_in)
}
inline void UInt64Rules::add_not_in(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.UInt64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& UInt64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.UInt64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* UInt64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.UInt64Rules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}

inline const ::google::protobuf::RepeatedField<::uint64_t>& UInt64Rules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* UInt64Rules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

inline bool UInt64Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void UInt64Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool UInt64Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void UInt64Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline UInt64Rules::LessThanCase UInt64Rules::less_than_case() const {
  return UInt64Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline UInt64Rules::GreaterThanCase UInt64Rules::greater_than_case() const {
  return UInt64Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// SInt32Rules

// optional sint32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool SInt32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SInt32Rules::clear_const_() {
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SInt32Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.const)
  return _internal_const_();
}
inline void SInt32Rules::set_const_(::int32_t value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.const)
}
inline ::int32_t SInt32Rules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void SInt32Rules::_internal_set_const_(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// sint32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool SInt32Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void SInt32Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void SInt32Rules::clear_lt() {
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0;
    clear_has_less_than();
  }
}
inline ::int32_t SInt32Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.lt)
  return _internal_lt();
}
inline void SInt32Rules::set_lt(::int32_t value) {
  _internal_set_lt(value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.lt)
}
inline ::int32_t SInt32Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0;
}
inline void SInt32Rules::_internal_set_lt(::int32_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
}

// sint32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool SInt32Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void SInt32Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void SInt32Rules::clear_lte() {
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0;
    clear_has_less_than();
  }
}
inline ::int32_t SInt32Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.lte)
  return _internal_lte();
}
inline void SInt32Rules::set_lte(::int32_t value) {
  _internal_set_lte(value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.lte)
}
inline ::int32_t SInt32Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0;
}
inline void SInt32Rules::_internal_set_lte(::int32_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
}

// sint32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool SInt32Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void SInt32Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void SInt32Rules::clear_gt() {
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0;
    clear_has_greater_than();
  }
}
inline ::int32_t SInt32Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.gt)
  return _internal_gt();
}
inline void SInt32Rules::set_gt(::int32_t value) {
  _internal_set_gt(value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.gt)
}
inline ::int32_t SInt32Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0;
}
inline void SInt32Rules::_internal_set_gt(::int32_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
}

// sint32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool SInt32Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void SInt32Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void SInt32Rules::clear_gte() {
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0;
    clear_has_greater_than();
  }
}
inline ::int32_t SInt32Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.gte)
  return _internal_gte();
}
inline void SInt32Rules::set_gte(::int32_t value) {
  _internal_set_gte(value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.gte)
}
inline ::int32_t SInt32Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0;
}
inline void SInt32Rules::_internal_set_gte(::int32_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
}

// repeated sint32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
inline int SInt32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int SInt32Rules::in_size() const {
  return _internal_in_size();
}
inline void SInt32Rules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline ::int32_t SInt32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.in)
  return _internal_in().Get(index);
}
inline void SInt32Rules::set_in(int index, ::int32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.in)
}
inline void SInt32Rules::add_in(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SInt32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SInt32Rules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.SInt32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* SInt32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SInt32Rules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& SInt32Rules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* SInt32Rules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated sint32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int SInt32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int SInt32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void SInt32Rules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline ::int32_t SInt32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void SInt32Rules::set_not_in(int index, ::int32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt32Rules.not_in)
}
inline void SInt32Rules::add_not_in(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SInt32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SInt32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.SInt32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* SInt32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SInt32Rules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& SInt32Rules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* SInt32Rules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

inline bool SInt32Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void SInt32Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool SInt32Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void SInt32Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline SInt32Rules::LessThanCase SInt32Rules::less_than_case() const {
  return SInt32Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline SInt32Rules::GreaterThanCase SInt32Rules::greater_than_case() const {
  return SInt32Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// SInt64Rules

// optional sint64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool SInt64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SInt64Rules::clear_const_() {
  _impl_.const__ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t SInt64Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.const)
  return _internal_const_();
}
inline void SInt64Rules::set_const_(::int64_t value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.const)
}
inline ::int64_t SInt64Rules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void SInt64Rules::_internal_set_const_(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// sint64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool SInt64Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void SInt64Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void SInt64Rules::clear_lt() {
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = ::int64_t{0};
    clear_has_less_than();
  }
}
inline ::int64_t SInt64Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.lt)
  return _internal_lt();
}
inline void SInt64Rules::set_lt(::int64_t value) {
  _internal_set_lt(value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.lt)
}
inline ::int64_t SInt64Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return ::int64_t{0};
}
inline void SInt64Rules::_internal_set_lt(::int64_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
}

// sint64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool SInt64Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void SInt64Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void SInt64Rules::clear_lte() {
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = ::int64_t{0};
    clear_has_less_than();
  }
}
inline ::int64_t SInt64Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.lte)
  return _internal_lte();
}
inline void SInt64Rules::set_lte(::int64_t value) {
  _internal_set_lte(value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.lte)
}
inline ::int64_t SInt64Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return ::int64_t{0};
}
inline void SInt64Rules::_internal_set_lte(::int64_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
}

// sint64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool SInt64Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void SInt64Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void SInt64Rules::clear_gt() {
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = ::int64_t{0};
    clear_has_greater_than();
  }
}
inline ::int64_t SInt64Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.gt)
  return _internal_gt();
}
inline void SInt64Rules::set_gt(::int64_t value) {
  _internal_set_gt(value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.gt)
}
inline ::int64_t SInt64Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return ::int64_t{0};
}
inline void SInt64Rules::_internal_set_gt(::int64_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
}

// sint64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool SInt64Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void SInt64Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void SInt64Rules::clear_gte() {
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = ::int64_t{0};
    clear_has_greater_than();
  }
}
inline ::int64_t SInt64Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.gte)
  return _internal_gte();
}
inline void SInt64Rules::set_gte(::int64_t value) {
  _internal_set_gte(value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.gte)
}
inline ::int64_t SInt64Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return ::int64_t{0};
}
inline void SInt64Rules::_internal_set_gte(::int64_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
}

// repeated sint64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
inline int SInt64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int SInt64Rules::in_size() const {
  return _internal_in_size();
}
inline void SInt64Rules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline ::int64_t SInt64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.in)
  return _internal_in().Get(index);
}
inline void SInt64Rules::set_in(int index, ::int64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.in)
}
inline void SInt64Rules::add_in(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SInt64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SInt64Rules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.SInt64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* SInt64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SInt64Rules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}

inline const ::google::protobuf::RepeatedField<::int64_t>& SInt64Rules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* SInt64Rules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated sint64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int SInt64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int SInt64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void SInt64Rules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline ::int64_t SInt64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SInt64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void SInt64Rules::set_not_in(int index, ::int64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SInt64Rules.not_in)
}
inline void SInt64Rules::add_not_in(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SInt64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SInt64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.SInt64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* SInt64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SInt64Rules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}

inline const ::google::protobuf::RepeatedField<::int64_t>& SInt64Rules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* SInt64Rules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

inline bool SInt64Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void SInt64Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool SInt64Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void SInt64Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline SInt64Rules::LessThanCase SInt64Rules::less_than_case() const {
  return SInt64Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline SInt64Rules::GreaterThanCase SInt64Rules::greater_than_case() const {
  return SInt64Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Fixed32Rules

// optional fixed32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool Fixed32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Fixed32Rules::clear_const_() {
  _impl_.const__ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t Fixed32Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.const)
  return _internal_const_();
}
inline void Fixed32Rules::set_const_(::uint32_t value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.const)
}
inline ::uint32_t Fixed32Rules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void Fixed32Rules::_internal_set_const_(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// fixed32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool Fixed32Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void Fixed32Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void Fixed32Rules::clear_lt() {
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0u;
    clear_has_less_than();
  }
}
inline ::uint32_t Fixed32Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.lt)
  return _internal_lt();
}
inline void Fixed32Rules::set_lt(::uint32_t value) {
  _internal_set_lt(value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.lt)
}
inline ::uint32_t Fixed32Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0u;
}
inline void Fixed32Rules::_internal_set_lt(::uint32_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
}

// fixed32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool Fixed32Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void Fixed32Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void Fixed32Rules::clear_lte() {
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0u;
    clear_has_less_than();
  }
}
inline ::uint32_t Fixed32Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.lte)
  return _internal_lte();
}
inline void Fixed32Rules::set_lte(::uint32_t value) {
  _internal_set_lte(value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.lte)
}
inline ::uint32_t Fixed32Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0u;
}
inline void Fixed32Rules::_internal_set_lte(::uint32_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
}

// fixed32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool Fixed32Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void Fixed32Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void Fixed32Rules::clear_gt() {
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0u;
    clear_has_greater_than();
  }
}
inline ::uint32_t Fixed32Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.gt)
  return _internal_gt();
}
inline void Fixed32Rules::set_gt(::uint32_t value) {
  _internal_set_gt(value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.gt)
}
inline ::uint32_t Fixed32Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0u;
}
inline void Fixed32Rules::_internal_set_gt(::uint32_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
}

// fixed32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool Fixed32Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void Fixed32Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void Fixed32Rules::clear_gte() {
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0u;
    clear_has_greater_than();
  }
}
inline ::uint32_t Fixed32Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.gte)
  return _internal_gte();
}
inline void Fixed32Rules::set_gte(::uint32_t value) {
  _internal_set_gte(value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.gte)
}
inline ::uint32_t Fixed32Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0u;
}
inline void Fixed32Rules::_internal_set_gte(::uint32_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
}

// repeated fixed32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
inline int Fixed32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int Fixed32Rules::in_size() const {
  return _internal_in_size();
}
inline void Fixed32Rules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline ::uint32_t Fixed32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.in)
  return _internal_in().Get(index);
}
inline void Fixed32Rules::set_in(int index, ::uint32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.in)
}
inline void Fixed32Rules::add_in(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Fixed32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Fixed32Rules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.Fixed32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Fixed32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Fixed32Rules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}

inline const ::google::protobuf::RepeatedField<::uint32_t>& Fixed32Rules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Fixed32Rules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated fixed32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int Fixed32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int Fixed32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void Fixed32Rules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline ::uint32_t Fixed32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void Fixed32Rules::set_not_in(int index, ::uint32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed32Rules.not_in)
}
inline void Fixed32Rules::add_not_in(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Fixed32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Fixed32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.Fixed32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Fixed32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Fixed32Rules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}

inline const ::google::protobuf::RepeatedField<::uint32_t>& Fixed32Rules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Fixed32Rules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

inline bool Fixed32Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void Fixed32Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool Fixed32Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void Fixed32Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline Fixed32Rules::LessThanCase Fixed32Rules::less_than_case() const {
  return Fixed32Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline Fixed32Rules::GreaterThanCase Fixed32Rules::greater_than_case() const {
  return Fixed32Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// Fixed64Rules

// optional fixed64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool Fixed64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Fixed64Rules::clear_const_() {
  _impl_.const__ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t Fixed64Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.const)
  return _internal_const_();
}
inline void Fixed64Rules::set_const_(::uint64_t value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.const)
}
inline ::uint64_t Fixed64Rules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void Fixed64Rules::_internal_set_const_(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// fixed64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool Fixed64Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void Fixed64Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void Fixed64Rules::clear_lt() {
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = ::uint64_t{0u};
    clear_has_less_than();
  }
}
inline ::uint64_t Fixed64Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.lt)
  return _internal_lt();
}
inline void Fixed64Rules::set_lt(::uint64_t value) {
  _internal_set_lt(value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.lt)
}
inline ::uint64_t Fixed64Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return ::uint64_t{0u};
}
inline void Fixed64Rules::_internal_set_lt(::uint64_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
}

// fixed64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool Fixed64Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void Fixed64Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void Fixed64Rules::clear_lte() {
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = ::uint64_t{0u};
    clear_has_less_than();
  }
}
inline ::uint64_t Fixed64Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.lte)
  return _internal_lte();
}
inline void Fixed64Rules::set_lte(::uint64_t value) {
  _internal_set_lte(value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.lte)
}
inline ::uint64_t Fixed64Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return ::uint64_t{0u};
}
inline void Fixed64Rules::_internal_set_lte(::uint64_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
}

// fixed64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool Fixed64Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void Fixed64Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void Fixed64Rules::clear_gt() {
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = ::uint64_t{0u};
    clear_has_greater_than();
  }
}
inline ::uint64_t Fixed64Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.gt)
  return _internal_gt();
}
inline void Fixed64Rules::set_gt(::uint64_t value) {
  _internal_set_gt(value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.gt)
}
inline ::uint64_t Fixed64Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return ::uint64_t{0u};
}
inline void Fixed64Rules::_internal_set_gt(::uint64_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
}

// fixed64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool Fixed64Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void Fixed64Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void Fixed64Rules::clear_gte() {
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = ::uint64_t{0u};
    clear_has_greater_than();
  }
}
inline ::uint64_t Fixed64Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.gte)
  return _internal_gte();
}
inline void Fixed64Rules::set_gte(::uint64_t value) {
  _internal_set_gte(value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.gte)
}
inline ::uint64_t Fixed64Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return ::uint64_t{0u};
}
inline void Fixed64Rules::_internal_set_gte(::uint64_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
}

// repeated fixed64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
inline int Fixed64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int Fixed64Rules::in_size() const {
  return _internal_in_size();
}
inline void Fixed64Rules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline ::uint64_t Fixed64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.in)
  return _internal_in().Get(index);
}
inline void Fixed64Rules::set_in(int index, ::uint64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.in)
}
inline void Fixed64Rules::add_in(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Fixed64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Fixed64Rules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.Fixed64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Fixed64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Fixed64Rules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}

inline const ::google::protobuf::RepeatedField<::uint64_t>& Fixed64Rules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Fixed64Rules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated fixed64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int Fixed64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int Fixed64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void Fixed64Rules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline ::uint64_t Fixed64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.Fixed64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void Fixed64Rules::set_not_in(int index, ::uint64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.Fixed64Rules.not_in)
}
inline void Fixed64Rules::add_not_in(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.Fixed64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& Fixed64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.Fixed64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Fixed64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.Fixed64Rules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}

inline const ::google::protobuf::RepeatedField<::uint64_t>& Fixed64Rules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* Fixed64Rules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

inline bool Fixed64Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void Fixed64Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool Fixed64Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void Fixed64Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline Fixed64Rules::LessThanCase Fixed64Rules::less_than_case() const {
  return Fixed64Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline Fixed64Rules::GreaterThanCase Fixed64Rules::greater_than_case() const {
  return Fixed64Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// SFixed32Rules

// optional sfixed32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool SFixed32Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SFixed32Rules::clear_const_() {
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SFixed32Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.const)
  return _internal_const_();
}
inline void SFixed32Rules::set_const_(::int32_t value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.const)
}
inline ::int32_t SFixed32Rules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void SFixed32Rules::_internal_set_const_(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// sfixed32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool SFixed32Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void SFixed32Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void SFixed32Rules::clear_lt() {
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = 0;
    clear_has_less_than();
  }
}
inline ::int32_t SFixed32Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.lt)
  return _internal_lt();
}
inline void SFixed32Rules::set_lt(::int32_t value) {
  _internal_set_lt(value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.lt)
}
inline ::int32_t SFixed32Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return 0;
}
inline void SFixed32Rules::_internal_set_lt(::int32_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
}

// sfixed32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool SFixed32Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void SFixed32Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void SFixed32Rules::clear_lte() {
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = 0;
    clear_has_less_than();
  }
}
inline ::int32_t SFixed32Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.lte)
  return _internal_lte();
}
inline void SFixed32Rules::set_lte(::int32_t value) {
  _internal_set_lte(value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.lte)
}
inline ::int32_t SFixed32Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return 0;
}
inline void SFixed32Rules::_internal_set_lte(::int32_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
}

// sfixed32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool SFixed32Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void SFixed32Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void SFixed32Rules::clear_gt() {
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = 0;
    clear_has_greater_than();
  }
}
inline ::int32_t SFixed32Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.gt)
  return _internal_gt();
}
inline void SFixed32Rules::set_gt(::int32_t value) {
  _internal_set_gt(value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.gt)
}
inline ::int32_t SFixed32Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return 0;
}
inline void SFixed32Rules::_internal_set_gt(::int32_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
}

// sfixed32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool SFixed32Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void SFixed32Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void SFixed32Rules::clear_gte() {
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = 0;
    clear_has_greater_than();
  }
}
inline ::int32_t SFixed32Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.gte)
  return _internal_gte();
}
inline void SFixed32Rules::set_gte(::int32_t value) {
  _internal_set_gte(value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.gte)
}
inline ::int32_t SFixed32Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return 0;
}
inline void SFixed32Rules::_internal_set_gte(::int32_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
}

// repeated sfixed32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
inline int SFixed32Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int SFixed32Rules::in_size() const {
  return _internal_in_size();
}
inline void SFixed32Rules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline ::int32_t SFixed32Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.in)
  return _internal_in().Get(index);
}
inline void SFixed32Rules::set_in(int index, ::int32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.in)
}
inline void SFixed32Rules::add_in(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SFixed32Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SFixed32Rules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.SFixed32Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* SFixed32Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SFixed32Rules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& SFixed32Rules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* SFixed32Rules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated sfixed32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int SFixed32Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int SFixed32Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void SFixed32Rules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline ::int32_t SFixed32Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed32Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void SFixed32Rules::set_not_in(int index, ::int32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed32Rules.not_in)
}
inline void SFixed32Rules::add_not_in(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SFixed32Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& SFixed32Rules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.SFixed32Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* SFixed32Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SFixed32Rules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& SFixed32Rules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* SFixed32Rules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

inline bool SFixed32Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void SFixed32Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool SFixed32Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void SFixed32Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline SFixed32Rules::LessThanCase SFixed32Rules::less_than_case() const {
  return SFixed32Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline SFixed32Rules::GreaterThanCase SFixed32Rules::greater_than_case() const {
  return SFixed32Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// SFixed64Rules

// optional sfixed64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool SFixed64Rules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SFixed64Rules::clear_const_() {
  _impl_.const__ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t SFixed64Rules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.const)
  return _internal_const_();
}
inline void SFixed64Rules::set_const_(::int64_t value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.const)
}
inline ::int64_t SFixed64Rules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void SFixed64Rules::_internal_set_const_(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// sfixed64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool SFixed64Rules::has_lt() const {
  return less_than_case() == kLt;
}
inline void SFixed64Rules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline void SFixed64Rules::clear_lt() {
  if (less_than_case() == kLt) {
    _impl_.less_than_.lt_ = ::int64_t{0};
    clear_has_less_than();
  }
}
inline ::int64_t SFixed64Rules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.lt)
  return _internal_lt();
}
inline void SFixed64Rules::set_lt(::int64_t value) {
  _internal_set_lt(value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.lt)
}
inline ::int64_t SFixed64Rules::_internal_lt() const {
  if (less_than_case() == kLt) {
    return _impl_.less_than_.lt_;
  }
  return ::int64_t{0};
}
inline void SFixed64Rules::_internal_set_lt(::int64_t value) {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
  }
  _impl_.less_than_.lt_ = value;
}

// sfixed64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool SFixed64Rules::has_lte() const {
  return less_than_case() == kLte;
}
inline void SFixed64Rules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline void SFixed64Rules::clear_lte() {
  if (less_than_case() == kLte) {
    _impl_.less_than_.lte_ = ::int64_t{0};
    clear_has_less_than();
  }
}
inline ::int64_t SFixed64Rules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.lte)
  return _internal_lte();
}
inline void SFixed64Rules::set_lte(::int64_t value) {
  _internal_set_lte(value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.lte)
}
inline ::int64_t SFixed64Rules::_internal_lte() const {
  if (less_than_case() == kLte) {
    return _impl_.less_than_.lte_;
  }
  return ::int64_t{0};
}
inline void SFixed64Rules::_internal_set_lte(::int64_t value) {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
  }
  _impl_.less_than_.lte_ = value;
}

// sfixed64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool SFixed64Rules::has_gt() const {
  return greater_than_case() == kGt;
}
inline void SFixed64Rules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline void SFixed64Rules::clear_gt() {
  if (greater_than_case() == kGt) {
    _impl_.greater_than_.gt_ = ::int64_t{0};
    clear_has_greater_than();
  }
}
inline ::int64_t SFixed64Rules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.gt)
  return _internal_gt();
}
inline void SFixed64Rules::set_gt(::int64_t value) {
  _internal_set_gt(value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.gt)
}
inline ::int64_t SFixed64Rules::_internal_gt() const {
  if (greater_than_case() == kGt) {
    return _impl_.greater_than_.gt_;
  }
  return ::int64_t{0};
}
inline void SFixed64Rules::_internal_set_gt(::int64_t value) {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
  }
  _impl_.greater_than_.gt_ = value;
}

// sfixed64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool SFixed64Rules::has_gte() const {
  return greater_than_case() == kGte;
}
inline void SFixed64Rules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline void SFixed64Rules::clear_gte() {
  if (greater_than_case() == kGte) {
    _impl_.greater_than_.gte_ = ::int64_t{0};
    clear_has_greater_than();
  }
}
inline ::int64_t SFixed64Rules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.gte)
  return _internal_gte();
}
inline void SFixed64Rules::set_gte(::int64_t value) {
  _internal_set_gte(value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.gte)
}
inline ::int64_t SFixed64Rules::_internal_gte() const {
  if (greater_than_case() == kGte) {
    return _impl_.greater_than_.gte_;
  }
  return ::int64_t{0};
}
inline void SFixed64Rules::_internal_set_gte(::int64_t value) {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
  }
  _impl_.greater_than_.gte_ = value;
}

// repeated sfixed64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
inline int SFixed64Rules::_internal_in_size() const {
  return _internal_in().size();
}
inline int SFixed64Rules::in_size() const {
  return _internal_in_size();
}
inline void SFixed64Rules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline ::int64_t SFixed64Rules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.in)
  return _internal_in().Get(index);
}
inline void SFixed64Rules::set_in(int index, ::int64_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.in)
}
inline void SFixed64Rules::add_in(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SFixed64Rules.in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SFixed64Rules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.SFixed64Rules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* SFixed64Rules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SFixed64Rules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}

inline const ::google::protobuf::RepeatedField<::int64_t>& SFixed64Rules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* SFixed64Rules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated sfixed64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int SFixed64Rules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int SFixed64Rules::not_in_size() const {
  return _internal_not_in_size();
}
inline void SFixed64Rules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline ::int64_t SFixed64Rules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.SFixed64Rules.not_in)
  return _internal_not_in().Get(index);
}
inline void SFixed64Rules::set_not_in(int index, ::int64_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.SFixed64Rules.not_in)
}
inline void SFixed64Rules::add_not_in(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.SFixed64Rules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& SFixed64Rules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.SFixed64Rules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int64_t>* SFixed64Rules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.SFixed64Rules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}

inline const ::google::protobuf::RepeatedField<::int64_t>& SFixed64Rules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* SFixed64Rules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

inline bool SFixed64Rules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void SFixed64Rules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool SFixed64Rules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void SFixed64Rules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline SFixed64Rules::LessThanCase SFixed64Rules::less_than_case() const {
  return SFixed64Rules::LessThanCase(_impl_._oneof_case_[0]);
}
inline SFixed64Rules::GreaterThanCase SFixed64Rules::greater_than_case() const {
  return SFixed64Rules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// BoolRules

// optional bool const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool BoolRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BoolRules::clear_const_() {
  _impl_.const__ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool BoolRules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.BoolRules.const)
  return _internal_const_();
}
inline void BoolRules::set_const_(bool value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.BoolRules.const)
}
inline bool BoolRules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void BoolRules::_internal_set_const_(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// -------------------------------------------------------------------

// StringRules

// optional string const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool StringRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StringRules::clear_const_() {
  _impl_.const__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StringRules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.const)
  return _internal_const_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringRules::set_const_(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.const)
}
inline std::string* StringRules::mutable_const_() {
  std::string* _s = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.const)
  return _s;
}
inline const std::string& StringRules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__.Get();
}
inline void StringRules::_internal_set_const_(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__.Set(value, GetArenaForAllocation());
}
inline std::string* StringRules::_internal_mutable_const_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.const__.Mutable( GetArenaForAllocation());
}
inline std::string* StringRules::release_const_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.StringRules.const)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.const__.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.const__.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringRules::set_allocated_const_(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.const__.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.const__.IsDefault()) {
          _impl_.const__.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.StringRules.const)
}

// optional uint64 len = 19 [json_name = "len", (.buf.validate.priv.field) = {
inline bool StringRules::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void StringRules::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint64_t StringRules::len() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.len)
  return _internal_len();
}
inline void StringRules::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.len)
}
inline ::uint64_t StringRules::_internal_len() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.len_;
}
inline void StringRules::_internal_set_len(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.len_ = value;
}

// optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {
inline bool StringRules::has_min_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void StringRules::clear_min_len() {
  _impl_.min_len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t StringRules::min_len() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.min_len)
  return _internal_min_len();
}
inline void StringRules::set_min_len(::uint64_t value) {
  _internal_set_min_len(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.min_len)
}
inline ::uint64_t StringRules::_internal_min_len() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_len_;
}
inline void StringRules::_internal_set_min_len(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.min_len_ = value;
}

// optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {
inline bool StringRules::has_max_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void StringRules::clear_max_len() {
  _impl_.max_len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t StringRules::max_len() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.max_len)
  return _internal_max_len();
}
inline void StringRules::set_max_len(::uint64_t value) {
  _internal_set_max_len(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.max_len)
}
inline ::uint64_t StringRules::_internal_max_len() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_len_;
}
inline void StringRules::_internal_set_max_len(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.max_len_ = value;
}

// optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.priv.field) = {
inline bool StringRules::has_len_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void StringRules::clear_len_bytes() {
  _impl_.len_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::uint64_t StringRules::len_bytes() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.len_bytes)
  return _internal_len_bytes();
}
inline void StringRules::set_len_bytes(::uint64_t value) {
  _internal_set_len_bytes(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.len_bytes)
}
inline ::uint64_t StringRules::_internal_len_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.len_bytes_;
}
inline void StringRules::_internal_set_len_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.len_bytes_ = value;
}

// optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.priv.field) = {
inline bool StringRules::has_min_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void StringRules::clear_min_bytes() {
  _impl_.min_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint64_t StringRules::min_bytes() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.min_bytes)
  return _internal_min_bytes();
}
inline void StringRules::set_min_bytes(::uint64_t value) {
  _internal_set_min_bytes(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.min_bytes)
}
inline ::uint64_t StringRules::_internal_min_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_bytes_;
}
inline void StringRules::_internal_set_min_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.min_bytes_ = value;
}

// optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.priv.field) = {
inline bool StringRules::has_max_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void StringRules::clear_max_bytes() {
  _impl_.max_bytes_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint64_t StringRules::max_bytes() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.max_bytes)
  return _internal_max_bytes();
}
inline void StringRules::set_max_bytes(::uint64_t value) {
  _internal_set_max_bytes(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.max_bytes)
}
inline ::uint64_t StringRules::_internal_max_bytes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_bytes_;
}
inline void StringRules::_internal_set_max_bytes(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.max_bytes_ = value;
}

// optional string pattern = 6 [json_name = "pattern", (.buf.validate.priv.field) = {
inline bool StringRules::has_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StringRules::clear_pattern() {
  _impl_.pattern_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StringRules::pattern() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.pattern)
  return _internal_pattern();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringRules::set_pattern(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.pattern)
}
inline std::string* StringRules::mutable_pattern() {
  std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.pattern)
  return _s;
}
inline const std::string& StringRules::_internal_pattern() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pattern_.Get();
}
inline void StringRules::_internal_set_pattern(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* StringRules::_internal_mutable_pattern() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pattern_.Mutable( GetArenaForAllocation());
}
inline std::string* StringRules::release_pattern() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.StringRules.pattern)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.pattern_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pattern_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringRules::set_allocated_pattern(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pattern_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pattern_.IsDefault()) {
          _impl_.pattern_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.StringRules.pattern)
}

// optional string prefix = 7 [json_name = "prefix", (.buf.validate.priv.field) = {
inline bool StringRules::has_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StringRules::clear_prefix() {
  _impl_.prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StringRules::prefix() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.prefix)
  return _internal_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringRules::set_prefix(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.prefix)
}
inline std::string* StringRules::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.prefix)
  return _s;
}
inline const std::string& StringRules::_internal_prefix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.prefix_.Get();
}
inline void StringRules::_internal_set_prefix(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* StringRules::_internal_mutable_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.prefix_.Mutable( GetArenaForAllocation());
}
inline std::string* StringRules::release_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.StringRules.prefix)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.prefix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringRules::set_allocated_prefix(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.prefix_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.prefix_.IsDefault()) {
          _impl_.prefix_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.StringRules.prefix)
}

// optional string suffix = 8 [json_name = "suffix", (.buf.validate.priv.field) = {
inline bool StringRules::has_suffix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void StringRules::clear_suffix() {
  _impl_.suffix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& StringRules::suffix() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.suffix)
  return _internal_suffix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringRules::set_suffix(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.suffix_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.suffix)
}
inline std::string* StringRules::mutable_suffix() {
  std::string* _s = _internal_mutable_suffix();
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.suffix)
  return _s;
}
inline const std::string& StringRules::_internal_suffix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.suffix_.Get();
}
inline void StringRules::_internal_set_suffix(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.suffix_.Set(value, GetArenaForAllocation());
}
inline std::string* StringRules::_internal_mutable_suffix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.suffix_.Mutable( GetArenaForAllocation());
}
inline std::string* StringRules::release_suffix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.StringRules.suffix)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.suffix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.suffix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringRules::set_allocated_suffix(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.suffix_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.suffix_.IsDefault()) {
          _impl_.suffix_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.StringRules.suffix)
}

// optional string contains = 9 [json_name = "contains", (.buf.validate.priv.field) = {
inline bool StringRules::has_contains() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void StringRules::clear_contains() {
  _impl_.contains_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& StringRules::contains() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.contains)
  return _internal_contains();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringRules::set_contains(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.contains_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.contains)
}
inline std::string* StringRules::mutable_contains() {
  std::string* _s = _internal_mutable_contains();
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.contains)
  return _s;
}
inline const std::string& StringRules::_internal_contains() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.contains_.Get();
}
inline void StringRules::_internal_set_contains(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.contains_.Set(value, GetArenaForAllocation());
}
inline std::string* StringRules::_internal_mutable_contains() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.contains_.Mutable( GetArenaForAllocation());
}
inline std::string* StringRules::release_contains() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.StringRules.contains)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.contains_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contains_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringRules::set_allocated_contains(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.contains_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contains_.IsDefault()) {
          _impl_.contains_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.StringRules.contains)
}

// optional string not_contains = 23 [json_name = "notContains", (.buf.validate.priv.field) = {
inline bool StringRules::has_not_contains() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void StringRules::clear_not_contains() {
  _impl_.not_contains_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& StringRules::not_contains() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.not_contains)
  return _internal_not_contains();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringRules::set_not_contains(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.not_contains_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.not_contains)
}
inline std::string* StringRules::mutable_not_contains() {
  std::string* _s = _internal_mutable_not_contains();
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.not_contains)
  return _s;
}
inline const std::string& StringRules::_internal_not_contains() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_contains_.Get();
}
inline void StringRules::_internal_set_not_contains(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.not_contains_.Set(value, GetArenaForAllocation());
}
inline std::string* StringRules::_internal_mutable_not_contains() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.not_contains_.Mutable( GetArenaForAllocation());
}
inline std::string* StringRules::release_not_contains() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.StringRules.not_contains)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.not_contains_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.not_contains_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringRules::set_allocated_not_contains(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.not_contains_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.not_contains_.IsDefault()) {
          _impl_.not_contains_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.StringRules.not_contains)
}

// repeated string in = 10 [json_name = "in", (.buf.validate.priv.field) = {
inline int StringRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int StringRules::in_size() const {
  return _internal_in_size();
}
inline void StringRules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline std::string* StringRules::add_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.StringRules.in)
  return _s;
}
inline const std::string& StringRules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.in)
  return _internal_in().Get(index);
}
inline std::string* StringRules::mutable_in(int index) {
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.in)
  return _internal_mutable_in()->Mutable(index);
}
inline void StringRules::set_in(int index, const std::string& value) {
  _internal_mutable_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.in)
}
inline void StringRules::set_in(int index, std::string&& value) {
  _internal_mutable_in()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.in)
}
inline void StringRules::set_in(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.StringRules.in)
}
inline void StringRules::set_in(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_in()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.StringRules.in)
}
inline void StringRules::set_in(int index, absl::string_view value) {
  _internal_mutable_in()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.StringRules.in)
}
inline void StringRules::add_in(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.StringRules.in)
}
inline void StringRules::add_in(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.StringRules.in)
}
inline void StringRules::add_in(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.StringRules.in)
}
inline void StringRules::add_in(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.StringRules.in)
}
inline void StringRules::add_in(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.StringRules.in)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringRules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.StringRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* StringRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.StringRules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringRules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringRules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated string not_in = 11 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int StringRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int StringRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void StringRules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline std::string* StringRules::add_not_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_not_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.StringRules.not_in)
  return _s;
}
inline const std::string& StringRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.not_in)
  return _internal_not_in().Get(index);
}
inline std::string* StringRules::mutable_not_in(int index) {
  // @@protoc_insertion_point(field_mutable:buf.validate.StringRules.not_in)
  return _internal_mutable_not_in()->Mutable(index);
}
inline void StringRules::set_not_in(int index, const std::string& value) {
  _internal_mutable_not_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.not_in)
}
inline void StringRules::set_not_in(int index, std::string&& value) {
  _internal_mutable_not_in()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.not_in)
}
inline void StringRules::set_not_in(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_not_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.StringRules.not_in)
}
inline void StringRules::set_not_in(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_not_in()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.StringRules.not_in)
}
inline void StringRules::set_not_in(int index, absl::string_view value) {
  _internal_mutable_not_in()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.StringRules.not_in)
}
inline void StringRules::add_not_in(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.StringRules.not_in)
}
inline void StringRules::add_not_in(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.StringRules.not_in)
}
inline void StringRules::add_not_in(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.StringRules.not_in)
}
inline void StringRules::add_not_in(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.StringRules.not_in)
}
inline void StringRules::add_not_in(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.StringRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringRules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.StringRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* StringRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.StringRules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringRules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringRules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

// bool email = 12 [json_name = "email", (.buf.validate.priv.field) = {
inline bool StringRules::has_email() const {
  return well_known_case() == kEmail;
}
inline void StringRules::set_has_email() {
  _impl_._oneof_case_[0] = kEmail;
}
inline void StringRules::clear_email() {
  if (well_known_case() == kEmail) {
    _impl_.well_known_.email_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::email() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.email)
  return _internal_email();
}
inline void StringRules::set_email(bool value) {
  _internal_set_email(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.email)
}
inline bool StringRules::_internal_email() const {
  if (well_known_case() == kEmail) {
    return _impl_.well_known_.email_;
  }
  return false;
}
inline void StringRules::_internal_set_email(bool value) {
  if (well_known_case() != kEmail) {
    clear_well_known();
    set_has_email();
  }
  _impl_.well_known_.email_ = value;
}

// bool hostname = 13 [json_name = "hostname", (.buf.validate.priv.field) = {
inline bool StringRules::has_hostname() const {
  return well_known_case() == kHostname;
}
inline void StringRules::set_has_hostname() {
  _impl_._oneof_case_[0] = kHostname;
}
inline void StringRules::clear_hostname() {
  if (well_known_case() == kHostname) {
    _impl_.well_known_.hostname_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::hostname() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.hostname)
  return _internal_hostname();
}
inline void StringRules::set_hostname(bool value) {
  _internal_set_hostname(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.hostname)
}
inline bool StringRules::_internal_hostname() const {
  if (well_known_case() == kHostname) {
    return _impl_.well_known_.hostname_;
  }
  return false;
}
inline void StringRules::_internal_set_hostname(bool value) {
  if (well_known_case() != kHostname) {
    clear_well_known();
    set_has_hostname();
  }
  _impl_.well_known_.hostname_ = value;
}

// bool ip = 14 [json_name = "ip", (.buf.validate.priv.field) = {
inline bool StringRules::has_ip() const {
  return well_known_case() == kIp;
}
inline void StringRules::set_has_ip() {
  _impl_._oneof_case_[0] = kIp;
}
inline void StringRules::clear_ip() {
  if (well_known_case() == kIp) {
    _impl_.well_known_.ip_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ip() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.ip)
  return _internal_ip();
}
inline void StringRules::set_ip(bool value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.ip)
}
inline bool StringRules::_internal_ip() const {
  if (well_known_case() == kIp) {
    return _impl_.well_known_.ip_;
  }
  return false;
}
inline void StringRules::_internal_set_ip(bool value) {
  if (well_known_case() != kIp) {
    clear_well_known();
    set_has_ip();
  }
  _impl_.well_known_.ip_ = value;
}

// bool ipv4 = 15 [json_name = "ipv4", (.buf.validate.priv.field) = {
inline bool StringRules::has_ipv4() const {
  return well_known_case() == kIpv4;
}
inline void StringRules::set_has_ipv4() {
  _impl_._oneof_case_[0] = kIpv4;
}
inline void StringRules::clear_ipv4() {
  if (well_known_case() == kIpv4) {
    _impl_.well_known_.ipv4_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv4() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.ipv4)
  return _internal_ipv4();
}
inline void StringRules::set_ipv4(bool value) {
  _internal_set_ipv4(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.ipv4)
}
inline bool StringRules::_internal_ipv4() const {
  if (well_known_case() == kIpv4) {
    return _impl_.well_known_.ipv4_;
  }
  return false;
}
inline void StringRules::_internal_set_ipv4(bool value) {
  if (well_known_case() != kIpv4) {
    clear_well_known();
    set_has_ipv4();
  }
  _impl_.well_known_.ipv4_ = value;
}

// bool ipv6 = 16 [json_name = "ipv6", (.buf.validate.priv.field) = {
inline bool StringRules::has_ipv6() const {
  return well_known_case() == kIpv6;
}
inline void StringRules::set_has_ipv6() {
  _impl_._oneof_case_[0] = kIpv6;
}
inline void StringRules::clear_ipv6() {
  if (well_known_case() == kIpv6) {
    _impl_.well_known_.ipv6_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::ipv6() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.ipv6)
  return _internal_ipv6();
}
inline void StringRules::set_ipv6(bool value) {
  _internal_set_ipv6(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.ipv6)
}
inline bool StringRules::_internal_ipv6() const {
  if (well_known_case() == kIpv6) {
    return _impl_.well_known_.ipv6_;
  }
  return false;
}
inline void StringRules::_internal_set_ipv6(bool value) {
  if (well_known_case() != kIpv6) {
    clear_well_known();
    set_has_ipv6();
  }
  _impl_.well_known_.ipv6_ = value;
}

// bool uri = 17 [json_name = "uri", (.buf.validate.priv.field) = {
inline bool StringRules::has_uri() const {
  return well_known_case() == kUri;
}
inline void StringRules::set_has_uri() {
  _impl_._oneof_case_[0] = kUri;
}
inline void StringRules::clear_uri() {
  if (well_known_case() == kUri) {
    _impl_.well_known_.uri_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::uri() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.uri)
  return _internal_uri();
}
inline void StringRules::set_uri(bool value) {
  _internal_set_uri(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.uri)
}
inline bool StringRules::_internal_uri() const {
  if (well_known_case() == kUri) {
    return _impl_.well_known_.uri_;
  }
  return false;
}
inline void StringRules::_internal_set_uri(bool value) {
  if (well_known_case() != kUri) {
    clear_well_known();
    set_has_uri();
  }
  _impl_.well_known_.uri_ = value;
}

// bool uri_ref = 18 [json_name = "uriRef", (.buf.validate.priv.field) = {
inline bool StringRules::has_uri_ref() const {
  return well_known_case() == kUriRef;
}
inline void StringRules::set_has_uri_ref() {
  _impl_._oneof_case_[0] = kUriRef;
}
inline void StringRules::clear_uri_ref() {
  if (well_known_case() == kUriRef) {
    _impl_.well_known_.uri_ref_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::uri_ref() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.uri_ref)
  return _internal_uri_ref();
}
inline void StringRules::set_uri_ref(bool value) {
  _internal_set_uri_ref(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.uri_ref)
}
inline bool StringRules::_internal_uri_ref() const {
  if (well_known_case() == kUriRef) {
    return _impl_.well_known_.uri_ref_;
  }
  return false;
}
inline void StringRules::_internal_set_uri_ref(bool value) {
  if (well_known_case() != kUriRef) {
    clear_well_known();
    set_has_uri_ref();
  }
  _impl_.well_known_.uri_ref_ = value;
}

// bool address = 21 [json_name = "address", (.buf.validate.priv.field) = {
inline bool StringRules::has_address() const {
  return well_known_case() == kAddress;
}
inline void StringRules::set_has_address() {
  _impl_._oneof_case_[0] = kAddress;
}
inline void StringRules::clear_address() {
  if (well_known_case() == kAddress) {
    _impl_.well_known_.address_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::address() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.address)
  return _internal_address();
}
inline void StringRules::set_address(bool value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.address)
}
inline bool StringRules::_internal_address() const {
  if (well_known_case() == kAddress) {
    return _impl_.well_known_.address_;
  }
  return false;
}
inline void StringRules::_internal_set_address(bool value) {
  if (well_known_case() != kAddress) {
    clear_well_known();
    set_has_address();
  }
  _impl_.well_known_.address_ = value;
}

// bool uuid = 22 [json_name = "uuid", (.buf.validate.priv.field) = {
inline bool StringRules::has_uuid() const {
  return well_known_case() == kUuid;
}
inline void StringRules::set_has_uuid() {
  _impl_._oneof_case_[0] = kUuid;
}
inline void StringRules::clear_uuid() {
  if (well_known_case() == kUuid) {
    _impl_.well_known_.uuid_ = false;
    clear_has_well_known();
  }
}
inline bool StringRules::uuid() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.uuid)
  return _internal_uuid();
}
inline void StringRules::set_uuid(bool value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.uuid)
}
inline bool StringRules::_internal_uuid() const {
  if (well_known_case() == kUuid) {
    return _impl_.well_known_.uuid_;
  }
  return false;
}
inline void StringRules::_internal_set_uuid(bool value) {
  if (well_known_case() != kUuid) {
    clear_well_known();
    set_has_uuid();
  }
  _impl_.well_known_.uuid_ = value;
}

// .buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.priv.field) = {
inline bool StringRules::has_well_known_regex() const {
  return well_known_case() == kWellKnownRegex;
}
inline void StringRules::set_has_well_known_regex() {
  _impl_._oneof_case_[0] = kWellKnownRegex;
}
inline void StringRules::clear_well_known_regex() {
  if (well_known_case() == kWellKnownRegex) {
    _impl_.well_known_.well_known_regex_ = 0;
    clear_has_well_known();
  }
}
inline ::buf::validate::KnownRegex StringRules::well_known_regex() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.well_known_regex)
  return _internal_well_known_regex();
}
inline void StringRules::set_well_known_regex(::buf::validate::KnownRegex value) {
  _internal_set_well_known_regex(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.well_known_regex)
}
inline ::buf::validate::KnownRegex StringRules::_internal_well_known_regex() const {
  if (well_known_case() == kWellKnownRegex) {
    return static_cast<::buf::validate::KnownRegex>(_impl_.well_known_.well_known_regex_);
  }
  return static_cast<::buf::validate::KnownRegex>(0);
}
inline void StringRules::_internal_set_well_known_regex(::buf::validate::KnownRegex value) {
  if (well_known_case() != kWellKnownRegex) {
    clear_well_known();
    set_has_well_known_regex();
  }
  _impl_.well_known_.well_known_regex_ = value;
}

// optional bool strict = 25 [json_name = "strict"];
inline bool StringRules::has_strict() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void StringRules::clear_strict() {
  _impl_.strict_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool StringRules::strict() const {
  // @@protoc_insertion_point(field_get:buf.validate.StringRules.strict)
  return _internal_strict();
}
inline void StringRules::set_strict(bool value) {
  _internal_set_strict(value);
  // @@protoc_insertion_point(field_set:buf.validate.StringRules.strict)
}
inline bool StringRules::_internal_strict() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.strict_;
}
inline void StringRules::_internal_set_strict(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.strict_ = value;
}

inline bool StringRules::has_well_known() const {
  return well_known_case() != WELL_KNOWN_NOT_SET;
}
inline void StringRules::clear_has_well_known() {
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}
inline StringRules::WellKnownCase StringRules::well_known_case() const {
  return StringRules::WellKnownCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BytesRules

// optional bytes const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool BytesRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BytesRules::clear_const_() {
  _impl_.const__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BytesRules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.const)
  return _internal_const_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BytesRules::set_const_(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.const)
}
inline std::string* BytesRules::mutable_const_() {
  std::string* _s = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.const)
  return _s;
}
inline const std::string& BytesRules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__.Get();
}
inline void BytesRules::_internal_set_const_(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__.Set(value, GetArenaForAllocation());
}
inline std::string* BytesRules::_internal_mutable_const_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.const__.Mutable( GetArenaForAllocation());
}
inline std::string* BytesRules::release_const_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.BytesRules.const)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.const__.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.const__.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BytesRules::set_allocated_const_(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.const__.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.const__.IsDefault()) {
          _impl_.const__.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.BytesRules.const)
}

// optional uint64 len = 13 [json_name = "len", (.buf.validate.priv.field) = {
inline bool BytesRules::has_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void BytesRules::clear_len() {
  _impl_.len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t BytesRules::len() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.len)
  return _internal_len();
}
inline void BytesRules::set_len(::uint64_t value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.len)
}
inline ::uint64_t BytesRules::_internal_len() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.len_;
}
inline void BytesRules::_internal_set_len(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.len_ = value;
}

// optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {
inline bool BytesRules::has_min_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BytesRules::clear_min_len() {
  _impl_.min_len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t BytesRules::min_len() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.min_len)
  return _internal_min_len();
}
inline void BytesRules::set_min_len(::uint64_t value) {
  _internal_set_min_len(value);
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.min_len)
}
inline ::uint64_t BytesRules::_internal_min_len() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_len_;
}
inline void BytesRules::_internal_set_min_len(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.min_len_ = value;
}

// optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {
inline bool BytesRules::has_max_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BytesRules::clear_max_len() {
  _impl_.max_len_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t BytesRules::max_len() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.max_len)
  return _internal_max_len();
}
inline void BytesRules::set_max_len(::uint64_t value) {
  _internal_set_max_len(value);
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.max_len)
}
inline ::uint64_t BytesRules::_internal_max_len() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_len_;
}
inline void BytesRules::_internal_set_max_len(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.max_len_ = value;
}

// optional string pattern = 4 [json_name = "pattern", (.buf.validate.priv.field) = {
inline bool BytesRules::has_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BytesRules::clear_pattern() {
  _impl_.pattern_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BytesRules::pattern() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.pattern)
  return _internal_pattern();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BytesRules::set_pattern(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.pattern)
}
inline std::string* BytesRules::mutable_pattern() {
  std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.pattern)
  return _s;
}
inline const std::string& BytesRules::_internal_pattern() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pattern_.Get();
}
inline void BytesRules::_internal_set_pattern(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* BytesRules::_internal_mutable_pattern() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.pattern_.Mutable( GetArenaForAllocation());
}
inline std::string* BytesRules::release_pattern() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.BytesRules.pattern)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.pattern_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pattern_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BytesRules::set_allocated_pattern(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.pattern_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pattern_.IsDefault()) {
          _impl_.pattern_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.BytesRules.pattern)
}

// optional bytes prefix = 5 [json_name = "prefix", (.buf.validate.priv.field) = {
inline bool BytesRules::has_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BytesRules::clear_prefix() {
  _impl_.prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BytesRules::prefix() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.prefix)
  return _internal_prefix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BytesRules::set_prefix(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prefix_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.prefix)
}
inline std::string* BytesRules::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.prefix)
  return _s;
}
inline const std::string& BytesRules::_internal_prefix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.prefix_.Get();
}
inline void BytesRules::_internal_set_prefix(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* BytesRules::_internal_mutable_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.prefix_.Mutable( GetArenaForAllocation());
}
inline std::string* BytesRules::release_prefix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.BytesRules.prefix)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.prefix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BytesRules::set_allocated_prefix(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.prefix_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.prefix_.IsDefault()) {
          _impl_.prefix_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.BytesRules.prefix)
}

// optional bytes suffix = 6 [json_name = "suffix", (.buf.validate.priv.field) = {
inline bool BytesRules::has_suffix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BytesRules::clear_suffix() {
  _impl_.suffix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& BytesRules::suffix() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.suffix)
  return _internal_suffix();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BytesRules::set_suffix(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.suffix_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.suffix)
}
inline std::string* BytesRules::mutable_suffix() {
  std::string* _s = _internal_mutable_suffix();
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.suffix)
  return _s;
}
inline const std::string& BytesRules::_internal_suffix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.suffix_.Get();
}
inline void BytesRules::_internal_set_suffix(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.suffix_.Set(value, GetArenaForAllocation());
}
inline std::string* BytesRules::_internal_mutable_suffix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.suffix_.Mutable( GetArenaForAllocation());
}
inline std::string* BytesRules::release_suffix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.BytesRules.suffix)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.suffix_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.suffix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BytesRules::set_allocated_suffix(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.suffix_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.suffix_.IsDefault()) {
          _impl_.suffix_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.BytesRules.suffix)
}

// optional bytes contains = 7 [json_name = "contains", (.buf.validate.priv.field) = {
inline bool BytesRules::has_contains() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BytesRules::clear_contains() {
  _impl_.contains_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& BytesRules::contains() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.contains)
  return _internal_contains();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BytesRules::set_contains(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.contains_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.contains)
}
inline std::string* BytesRules::mutable_contains() {
  std::string* _s = _internal_mutable_contains();
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.contains)
  return _s;
}
inline const std::string& BytesRules::_internal_contains() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.contains_.Get();
}
inline void BytesRules::_internal_set_contains(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.contains_.Set(value, GetArenaForAllocation());
}
inline std::string* BytesRules::_internal_mutable_contains() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.contains_.Mutable( GetArenaForAllocation());
}
inline std::string* BytesRules::release_contains() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.BytesRules.contains)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.contains_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contains_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BytesRules::set_allocated_contains(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.contains_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contains_.IsDefault()) {
          _impl_.contains_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:buf.validate.BytesRules.contains)
}

// repeated bytes in = 8 [json_name = "in", (.buf.validate.priv.field) = {
inline int BytesRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int BytesRules::in_size() const {
  return _internal_in_size();
}
inline void BytesRules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline std::string* BytesRules::add_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.BytesRules.in)
  return _s;
}
inline const std::string& BytesRules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.in)
  return _internal_in().Get(index);
}
inline std::string* BytesRules::mutable_in(int index) {
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.in)
  return _internal_mutable_in()->Mutable(index);
}
inline void BytesRules::set_in(int index, const std::string& value) {
  _internal_mutable_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.in)
}
inline void BytesRules::set_in(int index, std::string&& value) {
  _internal_mutable_in()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.in)
}
inline void BytesRules::set_in(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.BytesRules.in)
}
inline void BytesRules::set_in(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_in()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.BytesRules.in)
}
inline void BytesRules::set_in(int index, absl::string_view value) {
  _internal_mutable_in()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.BytesRules.in)
}
inline void BytesRules::add_in(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.BytesRules.in)
}
inline void BytesRules::add_in(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.BytesRules.in)
}
inline void BytesRules::add_in(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.BytesRules.in)
}
inline void BytesRules::add_in(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.BytesRules.in)
}
inline void BytesRules::add_in(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.BytesRules.in)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesRules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.BytesRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* BytesRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.BytesRules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesRules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BytesRules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated bytes not_in = 9 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int BytesRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int BytesRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void BytesRules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline std::string* BytesRules::add_not_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_not_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.BytesRules.not_in)
  return _s;
}
inline const std::string& BytesRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.not_in)
  return _internal_not_in().Get(index);
}
inline std::string* BytesRules::mutable_not_in(int index) {
  // @@protoc_insertion_point(field_mutable:buf.validate.BytesRules.not_in)
  return _internal_mutable_not_in()->Mutable(index);
}
inline void BytesRules::set_not_in(int index, const std::string& value) {
  _internal_mutable_not_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.not_in)
}
inline void BytesRules::set_not_in(int index, std::string&& value) {
  _internal_mutable_not_in()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.not_in)
}
inline void BytesRules::set_not_in(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_not_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.BytesRules.not_in)
}
inline void BytesRules::set_not_in(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_not_in()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.BytesRules.not_in)
}
inline void BytesRules::set_not_in(int index, absl::string_view value) {
  _internal_mutable_not_in()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.BytesRules.not_in)
}
inline void BytesRules::add_not_in(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.BytesRules.not_in)
}
inline void BytesRules::add_not_in(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.BytesRules.not_in)
}
inline void BytesRules::add_not_in(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.BytesRules.not_in)
}
inline void BytesRules::add_not_in(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.BytesRules.not_in)
}
inline void BytesRules::add_not_in(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.BytesRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesRules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.BytesRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* BytesRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.BytesRules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
BytesRules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
BytesRules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

// bool ip = 10 [json_name = "ip", (.buf.validate.priv.field) = {
inline bool BytesRules::has_ip() const {
  return well_known_case() == kIp;
}
inline void BytesRules::set_has_ip() {
  _impl_._oneof_case_[0] = kIp;
}
inline void BytesRules::clear_ip() {
  if (well_known_case() == kIp) {
    _impl_.well_known_.ip_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ip() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.ip)
  return _internal_ip();
}
inline void BytesRules::set_ip(bool value) {
  _internal_set_ip(value);
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.ip)
}
inline bool BytesRules::_internal_ip() const {
  if (well_known_case() == kIp) {
    return _impl_.well_known_.ip_;
  }
  return false;
}
inline void BytesRules::_internal_set_ip(bool value) {
  if (well_known_case() != kIp) {
    clear_well_known();
    set_has_ip();
  }
  _impl_.well_known_.ip_ = value;
}

// bool ipv4 = 11 [json_name = "ipv4", (.buf.validate.priv.field) = {
inline bool BytesRules::has_ipv4() const {
  return well_known_case() == kIpv4;
}
inline void BytesRules::set_has_ipv4() {
  _impl_._oneof_case_[0] = kIpv4;
}
inline void BytesRules::clear_ipv4() {
  if (well_known_case() == kIpv4) {
    _impl_.well_known_.ipv4_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ipv4() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.ipv4)
  return _internal_ipv4();
}
inline void BytesRules::set_ipv4(bool value) {
  _internal_set_ipv4(value);
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.ipv4)
}
inline bool BytesRules::_internal_ipv4() const {
  if (well_known_case() == kIpv4) {
    return _impl_.well_known_.ipv4_;
  }
  return false;
}
inline void BytesRules::_internal_set_ipv4(bool value) {
  if (well_known_case() != kIpv4) {
    clear_well_known();
    set_has_ipv4();
  }
  _impl_.well_known_.ipv4_ = value;
}

// bool ipv6 = 12 [json_name = "ipv6", (.buf.validate.priv.field) = {
inline bool BytesRules::has_ipv6() const {
  return well_known_case() == kIpv6;
}
inline void BytesRules::set_has_ipv6() {
  _impl_._oneof_case_[0] = kIpv6;
}
inline void BytesRules::clear_ipv6() {
  if (well_known_case() == kIpv6) {
    _impl_.well_known_.ipv6_ = false;
    clear_has_well_known();
  }
}
inline bool BytesRules::ipv6() const {
  // @@protoc_insertion_point(field_get:buf.validate.BytesRules.ipv6)
  return _internal_ipv6();
}
inline void BytesRules::set_ipv6(bool value) {
  _internal_set_ipv6(value);
  // @@protoc_insertion_point(field_set:buf.validate.BytesRules.ipv6)
}
inline bool BytesRules::_internal_ipv6() const {
  if (well_known_case() == kIpv6) {
    return _impl_.well_known_.ipv6_;
  }
  return false;
}
inline void BytesRules::_internal_set_ipv6(bool value) {
  if (well_known_case() != kIpv6) {
    clear_well_known();
    set_has_ipv6();
  }
  _impl_.well_known_.ipv6_ = value;
}

inline bool BytesRules::has_well_known() const {
  return well_known_case() != WELL_KNOWN_NOT_SET;
}
inline void BytesRules::clear_has_well_known() {
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}
inline BytesRules::WellKnownCase BytesRules::well_known_case() const {
  return BytesRules::WellKnownCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EnumRules

// optional int32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
inline bool EnumRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EnumRules::clear_const_() {
  _impl_.const__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t EnumRules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.EnumRules.const)
  return _internal_const_();
}
inline void EnumRules::set_const_(::int32_t value) {
  _internal_set_const_(value);
  // @@protoc_insertion_point(field_set:buf.validate.EnumRules.const)
}
inline ::int32_t EnumRules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.const__;
}
inline void EnumRules::_internal_set_const_(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.const__ = value;
}

// optional bool defined_only = 2 [json_name = "definedOnly"];
inline bool EnumRules::has_defined_only() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EnumRules::clear_defined_only() {
  _impl_.defined_only_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool EnumRules::defined_only() const {
  // @@protoc_insertion_point(field_get:buf.validate.EnumRules.defined_only)
  return _internal_defined_only();
}
inline void EnumRules::set_defined_only(bool value) {
  _internal_set_defined_only(value);
  // @@protoc_insertion_point(field_set:buf.validate.EnumRules.defined_only)
}
inline bool EnumRules::_internal_defined_only() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.defined_only_;
}
inline void EnumRules::_internal_set_defined_only(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.defined_only_ = value;
}

// repeated int32 in = 3 [json_name = "in", (.buf.validate.priv.field) = {
inline int EnumRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int EnumRules::in_size() const {
  return _internal_in_size();
}
inline void EnumRules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline ::int32_t EnumRules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.EnumRules.in)
  return _internal_in().Get(index);
}
inline void EnumRules::set_in(int index, ::int32_t value) {
  _internal_mutable_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.EnumRules.in)
}
inline void EnumRules::add_in(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.EnumRules.in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& EnumRules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.EnumRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* EnumRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.EnumRules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& EnumRules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* EnumRules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated int32 not_in = 4 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int EnumRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int EnumRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void EnumRules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline ::int32_t EnumRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.EnumRules.not_in)
  return _internal_not_in().Get(index);
}
inline void EnumRules::set_not_in(int index, ::int32_t value) {
  _internal_mutable_not_in()->Set(index, value);
  // @@protoc_insertion_point(field_set:buf.validate.EnumRules.not_in)
}
inline void EnumRules::add_not_in(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(value);
  // @@protoc_insertion_point(field_add:buf.validate.EnumRules.not_in)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& EnumRules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.EnumRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedField<::int32_t>* EnumRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.EnumRules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}

inline const ::google::protobuf::RepeatedField<::int32_t>& EnumRules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* EnumRules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

// -------------------------------------------------------------------

// RepeatedRules

// optional uint64 min_items = 1 [json_name = "minItems", (.buf.validate.priv.field) = {
inline bool RepeatedRules::has_min_items() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RepeatedRules::clear_min_items() {
  _impl_.min_items_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t RepeatedRules::min_items() const {
  // @@protoc_insertion_point(field_get:buf.validate.RepeatedRules.min_items)
  return _internal_min_items();
}
inline void RepeatedRules::set_min_items(::uint64_t value) {
  _internal_set_min_items(value);
  // @@protoc_insertion_point(field_set:buf.validate.RepeatedRules.min_items)
}
inline ::uint64_t RepeatedRules::_internal_min_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_items_;
}
inline void RepeatedRules::_internal_set_min_items(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.min_items_ = value;
}

// optional uint64 max_items = 2 [json_name = "maxItems", (.buf.validate.priv.field) = {
inline bool RepeatedRules::has_max_items() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RepeatedRules::clear_max_items() {
  _impl_.max_items_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t RepeatedRules::max_items() const {
  // @@protoc_insertion_point(field_get:buf.validate.RepeatedRules.max_items)
  return _internal_max_items();
}
inline void RepeatedRules::set_max_items(::uint64_t value) {
  _internal_set_max_items(value);
  // @@protoc_insertion_point(field_set:buf.validate.RepeatedRules.max_items)
}
inline ::uint64_t RepeatedRules::_internal_max_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_items_;
}
inline void RepeatedRules::_internal_set_max_items(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_items_ = value;
}

// optional bool unique = 3 [json_name = "unique", (.buf.validate.priv.field) = {
inline bool RepeatedRules::has_unique() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RepeatedRules::clear_unique() {
  _impl_.unique_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool RepeatedRules::unique() const {
  // @@protoc_insertion_point(field_get:buf.validate.RepeatedRules.unique)
  return _internal_unique();
}
inline void RepeatedRules::set_unique(bool value) {
  _internal_set_unique(value);
  // @@protoc_insertion_point(field_set:buf.validate.RepeatedRules.unique)
}
inline bool RepeatedRules::_internal_unique() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unique_;
}
inline void RepeatedRules::_internal_set_unique(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.unique_ = value;
}

// optional .buf.validate.FieldConstraints items = 4 [json_name = "items"];
inline bool RepeatedRules::has_items() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.items_ != nullptr);
  return value;
}
inline void RepeatedRules::clear_items() {
  if (_impl_.items_ != nullptr) _impl_.items_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::buf::validate::FieldConstraints& RepeatedRules::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::buf::validate::FieldConstraints* p = _impl_.items_;
  return p != nullptr ? *p : reinterpret_cast<const ::buf::validate::FieldConstraints&>(::buf::validate::_FieldConstraints_default_instance_);
}
inline const ::buf::validate::FieldConstraints& RepeatedRules::items() const {
  // @@protoc_insertion_point(field_get:buf.validate.RepeatedRules.items)
  return _internal_items();
}
inline void RepeatedRules::unsafe_arena_set_allocated_items(::buf::validate::FieldConstraints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.items_);
  }
  _impl_.items_ = reinterpret_cast<::buf::validate::FieldConstraints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.RepeatedRules.items)
}
inline ::buf::validate::FieldConstraints* RepeatedRules::release_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::buf::validate::FieldConstraints* released = _impl_.items_;
  _impl_.items_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::buf::validate::FieldConstraints* RepeatedRules::unsafe_arena_release_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.RepeatedRules.items)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::buf::validate::FieldConstraints* temp = _impl_.items_;
  _impl_.items_ = nullptr;
  return temp;
}
inline ::buf::validate::FieldConstraints* RepeatedRules::_internal_mutable_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.items_ == nullptr) {
    auto* p = CreateMaybeMessage<::buf::validate::FieldConstraints>(GetArenaForAllocation());
    _impl_.items_ = reinterpret_cast<::buf::validate::FieldConstraints*>(p);
  }
  return _impl_.items_;
}
inline ::buf::validate::FieldConstraints* RepeatedRules::mutable_items() {
  ::buf::validate::FieldConstraints* _msg = _internal_mutable_items();
  // @@protoc_insertion_point(field_mutable:buf.validate.RepeatedRules.items)
  return _msg;
}
inline void RepeatedRules::set_allocated_items(::buf::validate::FieldConstraints* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::buf::validate::FieldConstraints*>(_impl_.items_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::buf::validate::FieldConstraints*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.items_ = reinterpret_cast<::buf::validate::FieldConstraints*>(value);
  // @@protoc_insertion_point(field_set_allocated:buf.validate.RepeatedRules.items)
}

// -------------------------------------------------------------------

// MapRules

// optional uint64 min_pairs = 1 [json_name = "minPairs", (.buf.validate.priv.field) = {
inline bool MapRules::has_min_pairs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MapRules::clear_min_pairs() {
  _impl_.min_pairs_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t MapRules::min_pairs() const {
  // @@protoc_insertion_point(field_get:buf.validate.MapRules.min_pairs)
  return _internal_min_pairs();
}
inline void MapRules::set_min_pairs(::uint64_t value) {
  _internal_set_min_pairs(value);
  // @@protoc_insertion_point(field_set:buf.validate.MapRules.min_pairs)
}
inline ::uint64_t MapRules::_internal_min_pairs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_pairs_;
}
inline void MapRules::_internal_set_min_pairs(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.min_pairs_ = value;
}

// optional uint64 max_pairs = 2 [json_name = "maxPairs", (.buf.validate.priv.field) = {
inline bool MapRules::has_max_pairs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MapRules::clear_max_pairs() {
  _impl_.max_pairs_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t MapRules::max_pairs() const {
  // @@protoc_insertion_point(field_get:buf.validate.MapRules.max_pairs)
  return _internal_max_pairs();
}
inline void MapRules::set_max_pairs(::uint64_t value) {
  _internal_set_max_pairs(value);
  // @@protoc_insertion_point(field_set:buf.validate.MapRules.max_pairs)
}
inline ::uint64_t MapRules::_internal_max_pairs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_pairs_;
}
inline void MapRules::_internal_set_max_pairs(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.max_pairs_ = value;
}

// optional .buf.validate.FieldConstraints keys = 4 [json_name = "keys"];
inline bool MapRules::has_keys() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.keys_ != nullptr);
  return value;
}
inline void MapRules::clear_keys() {
  if (_impl_.keys_ != nullptr) _impl_.keys_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::buf::validate::FieldConstraints& MapRules::_internal_keys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::buf::validate::FieldConstraints* p = _impl_.keys_;
  return p != nullptr ? *p : reinterpret_cast<const ::buf::validate::FieldConstraints&>(::buf::validate::_FieldConstraints_default_instance_);
}
inline const ::buf::validate::FieldConstraints& MapRules::keys() const {
  // @@protoc_insertion_point(field_get:buf.validate.MapRules.keys)
  return _internal_keys();
}
inline void MapRules::unsafe_arena_set_allocated_keys(::buf::validate::FieldConstraints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.keys_);
  }
  _impl_.keys_ = reinterpret_cast<::buf::validate::FieldConstraints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.MapRules.keys)
}
inline ::buf::validate::FieldConstraints* MapRules::release_keys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::buf::validate::FieldConstraints* released = _impl_.keys_;
  _impl_.keys_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::buf::validate::FieldConstraints* MapRules::unsafe_arena_release_keys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.MapRules.keys)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::buf::validate::FieldConstraints* temp = _impl_.keys_;
  _impl_.keys_ = nullptr;
  return temp;
}
inline ::buf::validate::FieldConstraints* MapRules::_internal_mutable_keys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.keys_ == nullptr) {
    auto* p = CreateMaybeMessage<::buf::validate::FieldConstraints>(GetArenaForAllocation());
    _impl_.keys_ = reinterpret_cast<::buf::validate::FieldConstraints*>(p);
  }
  return _impl_.keys_;
}
inline ::buf::validate::FieldConstraints* MapRules::mutable_keys() {
  ::buf::validate::FieldConstraints* _msg = _internal_mutable_keys();
  // @@protoc_insertion_point(field_mutable:buf.validate.MapRules.keys)
  return _msg;
}
inline void MapRules::set_allocated_keys(::buf::validate::FieldConstraints* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::buf::validate::FieldConstraints*>(_impl_.keys_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::buf::validate::FieldConstraints*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.keys_ = reinterpret_cast<::buf::validate::FieldConstraints*>(value);
  // @@protoc_insertion_point(field_set_allocated:buf.validate.MapRules.keys)
}

// optional .buf.validate.FieldConstraints values = 5 [json_name = "values"];
inline bool MapRules::has_values() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.values_ != nullptr);
  return value;
}
inline void MapRules::clear_values() {
  if (_impl_.values_ != nullptr) _impl_.values_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::buf::validate::FieldConstraints& MapRules::_internal_values() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::buf::validate::FieldConstraints* p = _impl_.values_;
  return p != nullptr ? *p : reinterpret_cast<const ::buf::validate::FieldConstraints&>(::buf::validate::_FieldConstraints_default_instance_);
}
inline const ::buf::validate::FieldConstraints& MapRules::values() const {
  // @@protoc_insertion_point(field_get:buf.validate.MapRules.values)
  return _internal_values();
}
inline void MapRules::unsafe_arena_set_allocated_values(::buf::validate::FieldConstraints* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.values_);
  }
  _impl_.values_ = reinterpret_cast<::buf::validate::FieldConstraints*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.MapRules.values)
}
inline ::buf::validate::FieldConstraints* MapRules::release_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::buf::validate::FieldConstraints* released = _impl_.values_;
  _impl_.values_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::buf::validate::FieldConstraints* MapRules::unsafe_arena_release_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.MapRules.values)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::buf::validate::FieldConstraints* temp = _impl_.values_;
  _impl_.values_ = nullptr;
  return temp;
}
inline ::buf::validate::FieldConstraints* MapRules::_internal_mutable_values() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.values_ == nullptr) {
    auto* p = CreateMaybeMessage<::buf::validate::FieldConstraints>(GetArenaForAllocation());
    _impl_.values_ = reinterpret_cast<::buf::validate::FieldConstraints*>(p);
  }
  return _impl_.values_;
}
inline ::buf::validate::FieldConstraints* MapRules::mutable_values() {
  ::buf::validate::FieldConstraints* _msg = _internal_mutable_values();
  // @@protoc_insertion_point(field_mutable:buf.validate.MapRules.values)
  return _msg;
}
inline void MapRules::set_allocated_values(::buf::validate::FieldConstraints* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::buf::validate::FieldConstraints*>(_impl_.values_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::buf::validate::FieldConstraints*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.values_ = reinterpret_cast<::buf::validate::FieldConstraints*>(value);
  // @@protoc_insertion_point(field_set_allocated:buf.validate.MapRules.values)
}

// -------------------------------------------------------------------

// AnyRules

// repeated string in = 2 [json_name = "in"];
inline int AnyRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int AnyRules::in_size() const {
  return _internal_in_size();
}
inline void AnyRules::clear_in() {
  _internal_mutable_in()->Clear();
}
inline std::string* AnyRules::add_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.AnyRules.in)
  return _s;
}
inline const std::string& AnyRules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.AnyRules.in)
  return _internal_in().Get(index);
}
inline std::string* AnyRules::mutable_in(int index) {
  // @@protoc_insertion_point(field_mutable:buf.validate.AnyRules.in)
  return _internal_mutable_in()->Mutable(index);
}
inline void AnyRules::set_in(int index, const std::string& value) {
  _internal_mutable_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.AnyRules.in)
}
inline void AnyRules::set_in(int index, std::string&& value) {
  _internal_mutable_in()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.AnyRules.in)
}
inline void AnyRules::set_in(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.AnyRules.in)
}
inline void AnyRules::set_in(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_in()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.AnyRules.in)
}
inline void AnyRules::set_in(int index, absl::string_view value) {
  _internal_mutable_in()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.AnyRules.in)
}
inline void AnyRules::add_in(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.AnyRules.in)
}
inline void AnyRules::add_in(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.AnyRules.in)
}
inline void AnyRules::add_in(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.AnyRules.in)
}
inline void AnyRules::add_in(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.AnyRules.in)
}
inline void AnyRules::add_in(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_in()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.AnyRules.in)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AnyRules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.AnyRules.in)
  return _internal_in();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* AnyRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.AnyRules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AnyRules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AnyRules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated string not_in = 3 [json_name = "notIn"];
inline int AnyRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int AnyRules::not_in_size() const {
  return _internal_not_in_size();
}
inline void AnyRules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
inline std::string* AnyRules::add_not_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_not_in()->Add();
  // @@protoc_insertion_point(field_add_mutable:buf.validate.AnyRules.not_in)
  return _s;
}
inline const std::string& AnyRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.AnyRules.not_in)
  return _internal_not_in().Get(index);
}
inline std::string* AnyRules::mutable_not_in(int index) {
  // @@protoc_insertion_point(field_mutable:buf.validate.AnyRules.not_in)
  return _internal_mutable_not_in()->Mutable(index);
}
inline void AnyRules::set_not_in(int index, const std::string& value) {
  _internal_mutable_not_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:buf.validate.AnyRules.not_in)
}
inline void AnyRules::set_not_in(int index, std::string&& value) {
  _internal_mutable_not_in()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:buf.validate.AnyRules.not_in)
}
inline void AnyRules::set_not_in(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_not_in()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:buf.validate.AnyRules.not_in)
}
inline void AnyRules::set_not_in(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_not_in()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:buf.validate.AnyRules.not_in)
}
inline void AnyRules::set_not_in(int index, absl::string_view value) {
  _internal_mutable_not_in()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:buf.validate.AnyRules.not_in)
}
inline void AnyRules::add_not_in(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:buf.validate.AnyRules.not_in)
}
inline void AnyRules::add_not_in(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:buf.validate.AnyRules.not_in)
}
inline void AnyRules::add_not_in(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:buf.validate.AnyRules.not_in)
}
inline void AnyRules::add_not_in(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:buf.validate.AnyRules.not_in)
}
inline void AnyRules::add_not_in(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_not_in()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:buf.validate.AnyRules.not_in)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AnyRules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.AnyRules.not_in)
  return _internal_not_in();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* AnyRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.AnyRules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AnyRules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AnyRules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

// -------------------------------------------------------------------

// DurationRules

// optional .google.protobuf.Duration const = 2 [json_name = "const", (.buf.validate.priv.field) = {
inline bool DurationRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.const__ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& DurationRules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.const__;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.const)
  return _internal_const_();
}
inline void DurationRules::unsafe_arena_set_allocated_const_(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.const__);
  }
  _impl_.const__ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.DurationRules.const)
}
inline ::google::protobuf::Duration* DurationRules::release_const_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.const__;
  _impl_.const__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* DurationRules::unsafe_arena_release_const_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.DurationRules.const)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.const__;
  _impl_.const__ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* DurationRules::_internal_mutable_const_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.const__ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaForAllocation());
    _impl_.const__ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.const__;
}
inline ::google::protobuf::Duration* DurationRules::mutable_const_() {
  ::google::protobuf::Duration* _msg = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.const)
  return _msg;
}
inline void DurationRules::set_allocated_const_(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.const__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.const__ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.const)
}

// .google.protobuf.Duration lt = 3 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool DurationRules::has_lt() const {
  return less_than_case() == kLt;
}
inline bool DurationRules::_internal_has_lt() const {
  return less_than_case() == kLt;
}
inline void DurationRules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline ::google::protobuf::Duration* DurationRules::release_lt() {
  // @@protoc_insertion_point(field_release:buf.validate.DurationRules.lt)
  if (less_than_case() == kLt) {
    clear_has_less_than();
    ::google::protobuf::Duration* temp = _impl_.less_than_.lt_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.less_than_.lt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Duration& DurationRules::_internal_lt() const {
  return less_than_case() == kLt
      ? *_impl_.less_than_.lt_
      : reinterpret_cast<::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.lt)
  return _internal_lt();
}
inline ::google::protobuf::Duration* DurationRules::unsafe_arena_release_lt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.DurationRules.lt)
  if (less_than_case() == kLt) {
    clear_has_less_than();
    ::google::protobuf::Duration* temp = _impl_.less_than_.lt_;
    _impl_.less_than_.lt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DurationRules::unsafe_arena_set_allocated_lt(::google::protobuf::Duration* lt) {
  clear_less_than();
  if (lt) {
    set_has_lt();
    _impl_.less_than_.lt_ = lt;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.DurationRules.lt)
}
inline ::google::protobuf::Duration* DurationRules::_internal_mutable_lt() {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
    _impl_.less_than_.lt_ = CreateMaybeMessage< ::google::protobuf::Duration >(GetArenaForAllocation());
  }
  return _impl_.less_than_.lt_;
}
inline ::google::protobuf::Duration* DurationRules::mutable_lt() {
  ::google::protobuf::Duration* _msg = _internal_mutable_lt();
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.lt)
  return _msg;
}

// .google.protobuf.Duration lte = 4 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool DurationRules::has_lte() const {
  return less_than_case() == kLte;
}
inline bool DurationRules::_internal_has_lte() const {
  return less_than_case() == kLte;
}
inline void DurationRules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline ::google::protobuf::Duration* DurationRules::release_lte() {
  // @@protoc_insertion_point(field_release:buf.validate.DurationRules.lte)
  if (less_than_case() == kLte) {
    clear_has_less_than();
    ::google::protobuf::Duration* temp = _impl_.less_than_.lte_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.less_than_.lte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Duration& DurationRules::_internal_lte() const {
  return less_than_case() == kLte
      ? *_impl_.less_than_.lte_
      : reinterpret_cast<::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.lte)
  return _internal_lte();
}
inline ::google::protobuf::Duration* DurationRules::unsafe_arena_release_lte() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.DurationRules.lte)
  if (less_than_case() == kLte) {
    clear_has_less_than();
    ::google::protobuf::Duration* temp = _impl_.less_than_.lte_;
    _impl_.less_than_.lte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DurationRules::unsafe_arena_set_allocated_lte(::google::protobuf::Duration* lte) {
  clear_less_than();
  if (lte) {
    set_has_lte();
    _impl_.less_than_.lte_ = lte;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.DurationRules.lte)
}
inline ::google::protobuf::Duration* DurationRules::_internal_mutable_lte() {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
    _impl_.less_than_.lte_ = CreateMaybeMessage< ::google::protobuf::Duration >(GetArenaForAllocation());
  }
  return _impl_.less_than_.lte_;
}
inline ::google::protobuf::Duration* DurationRules::mutable_lte() {
  ::google::protobuf::Duration* _msg = _internal_mutable_lte();
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.lte)
  return _msg;
}

// .google.protobuf.Duration gt = 5 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool DurationRules::has_gt() const {
  return greater_than_case() == kGt;
}
inline bool DurationRules::_internal_has_gt() const {
  return greater_than_case() == kGt;
}
inline void DurationRules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline ::google::protobuf::Duration* DurationRules::release_gt() {
  // @@protoc_insertion_point(field_release:buf.validate.DurationRules.gt)
  if (greater_than_case() == kGt) {
    clear_has_greater_than();
    ::google::protobuf::Duration* temp = _impl_.greater_than_.gt_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.greater_than_.gt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Duration& DurationRules::_internal_gt() const {
  return greater_than_case() == kGt
      ? *_impl_.greater_than_.gt_
      : reinterpret_cast<::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.gt)
  return _internal_gt();
}
inline ::google::protobuf::Duration* DurationRules::unsafe_arena_release_gt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.DurationRules.gt)
  if (greater_than_case() == kGt) {
    clear_has_greater_than();
    ::google::protobuf::Duration* temp = _impl_.greater_than_.gt_;
    _impl_.greater_than_.gt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DurationRules::unsafe_arena_set_allocated_gt(::google::protobuf::Duration* gt) {
  clear_greater_than();
  if (gt) {
    set_has_gt();
    _impl_.greater_than_.gt_ = gt;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.DurationRules.gt)
}
inline ::google::protobuf::Duration* DurationRules::_internal_mutable_gt() {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
    _impl_.greater_than_.gt_ = CreateMaybeMessage< ::google::protobuf::Duration >(GetArenaForAllocation());
  }
  return _impl_.greater_than_.gt_;
}
inline ::google::protobuf::Duration* DurationRules::mutable_gt() {
  ::google::protobuf::Duration* _msg = _internal_mutable_gt();
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.gt)
  return _msg;
}

// .google.protobuf.Duration gte = 6 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool DurationRules::has_gte() const {
  return greater_than_case() == kGte;
}
inline bool DurationRules::_internal_has_gte() const {
  return greater_than_case() == kGte;
}
inline void DurationRules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline ::google::protobuf::Duration* DurationRules::release_gte() {
  // @@protoc_insertion_point(field_release:buf.validate.DurationRules.gte)
  if (greater_than_case() == kGte) {
    clear_has_greater_than();
    ::google::protobuf::Duration* temp = _impl_.greater_than_.gte_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.greater_than_.gte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Duration& DurationRules::_internal_gte() const {
  return greater_than_case() == kGte
      ? *_impl_.greater_than_.gte_
      : reinterpret_cast<::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& DurationRules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.gte)
  return _internal_gte();
}
inline ::google::protobuf::Duration* DurationRules::unsafe_arena_release_gte() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.DurationRules.gte)
  if (greater_than_case() == kGte) {
    clear_has_greater_than();
    ::google::protobuf::Duration* temp = _impl_.greater_than_.gte_;
    _impl_.greater_than_.gte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DurationRules::unsafe_arena_set_allocated_gte(::google::protobuf::Duration* gte) {
  clear_greater_than();
  if (gte) {
    set_has_gte();
    _impl_.greater_than_.gte_ = gte;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.DurationRules.gte)
}
inline ::google::protobuf::Duration* DurationRules::_internal_mutable_gte() {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
    _impl_.greater_than_.gte_ = CreateMaybeMessage< ::google::protobuf::Duration >(GetArenaForAllocation());
  }
  return _impl_.greater_than_.gte_;
}
inline ::google::protobuf::Duration* DurationRules::mutable_gte() {
  ::google::protobuf::Duration* _msg = _internal_mutable_gte();
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.gte)
  return _msg;
}

// repeated .google.protobuf.Duration in = 7 [json_name = "in", (.buf.validate.priv.field) = {
inline int DurationRules::_internal_in_size() const {
  return _internal_in().size();
}
inline int DurationRules::in_size() const {
  return _internal_in_size();
}
inline ::google::protobuf::Duration* DurationRules::mutable_in(int index) {
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.in)
  return _internal_mutable_in()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >*
DurationRules::mutable_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.DurationRules.in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_in();
}
inline const ::google::protobuf::Duration& DurationRules::in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.in)
    return _internal_in().Get(index);
}
inline ::google::protobuf::Duration* DurationRules::add_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Duration* _add = _internal_mutable_in()->Add();
  // @@protoc_insertion_point(field_add:buf.validate.DurationRules.in)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >&
DurationRules::in() const {
  // @@protoc_insertion_point(field_list:buf.validate.DurationRules.in)
  return _internal_in();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>&
DurationRules::_internal_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.in_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>*
DurationRules::_internal_mutable_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.in_;
}

// repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn", (.buf.validate.priv.field) = {
inline int DurationRules::_internal_not_in_size() const {
  return _internal_not_in().size();
}
inline int DurationRules::not_in_size() const {
  return _internal_not_in_size();
}
inline ::google::protobuf::Duration* DurationRules::mutable_not_in(int index) {
  // @@protoc_insertion_point(field_mutable:buf.validate.DurationRules.not_in)
  return _internal_mutable_not_in()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >*
DurationRules::mutable_not_in() {
  // @@protoc_insertion_point(field_mutable_list:buf.validate.DurationRules.not_in)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_not_in();
}
inline const ::google::protobuf::Duration& DurationRules::not_in(int index) const {
  // @@protoc_insertion_point(field_get:buf.validate.DurationRules.not_in)
    return _internal_not_in().Get(index);
}
inline ::google::protobuf::Duration* DurationRules::add_not_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::google::protobuf::Duration* _add = _internal_mutable_not_in()->Add();
  // @@protoc_insertion_point(field_add:buf.validate.DurationRules.not_in)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Duration >&
DurationRules::not_in() const {
  // @@protoc_insertion_point(field_list:buf.validate.DurationRules.not_in)
  return _internal_not_in();
}
inline const ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>&
DurationRules::_internal_not_in() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.not_in_;
}
inline ::google::protobuf::RepeatedPtrField<::google::protobuf::Duration>*
DurationRules::_internal_mutable_not_in() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.not_in_;
}

inline bool DurationRules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void DurationRules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool DurationRules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void DurationRules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline DurationRules::LessThanCase DurationRules::less_than_case() const {
  return DurationRules::LessThanCase(_impl_._oneof_case_[0]);
}
inline DurationRules::GreaterThanCase DurationRules::greater_than_case() const {
  return DurationRules::GreaterThanCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// TimestampRules

// optional .google.protobuf.Timestamp const = 2 [json_name = "const", (.buf.validate.priv.field) = {
inline bool TimestampRules::has_const_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.const__ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_const_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.const__;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::const_() const {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.const)
  return _internal_const_();
}
inline void TimestampRules::unsafe_arena_set_allocated_const_(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.const__);
  }
  _impl_.const__ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.TimestampRules.const)
}
inline ::google::protobuf::Timestamp* TimestampRules::release_const_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.const__;
  _impl_.const__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* TimestampRules::unsafe_arena_release_const_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.TimestampRules.const)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.const__;
  _impl_.const__ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* TimestampRules::_internal_mutable_const_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.const__ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.const__ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.const__;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_const_() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_const_();
  // @@protoc_insertion_point(field_mutable:buf.validate.TimestampRules.const)
  return _msg;
}
inline void TimestampRules::set_allocated_const_(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.const__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.const__ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.const)
}

// .google.protobuf.Timestamp lt = 3 [json_name = "lt", (.buf.validate.priv.field) = {
inline bool TimestampRules::has_lt() const {
  return less_than_case() == kLt;
}
inline bool TimestampRules::_internal_has_lt() const {
  return less_than_case() == kLt;
}
inline void TimestampRules::set_has_lt() {
  _impl_._oneof_case_[0] = kLt;
}
inline ::google::protobuf::Timestamp* TimestampRules::release_lt() {
  // @@protoc_insertion_point(field_release:buf.validate.TimestampRules.lt)
  if (less_than_case() == kLt) {
    clear_has_less_than();
    ::google::protobuf::Timestamp* temp = _impl_.less_than_.lt_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.less_than_.lt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_lt() const {
  return less_than_case() == kLt
      ? *_impl_.less_than_.lt_
      : reinterpret_cast<::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::lt() const {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.lt)
  return _internal_lt();
}
inline ::google::protobuf::Timestamp* TimestampRules::unsafe_arena_release_lt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.TimestampRules.lt)
  if (less_than_case() == kLt) {
    clear_has_less_than();
    ::google::protobuf::Timestamp* temp = _impl_.less_than_.lt_;
    _impl_.less_than_.lt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TimestampRules::unsafe_arena_set_allocated_lt(::google::protobuf::Timestamp* lt) {
  clear_less_than();
  if (lt) {
    set_has_lt();
    _impl_.less_than_.lt_ = lt;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.TimestampRules.lt)
}
inline ::google::protobuf::Timestamp* TimestampRules::_internal_mutable_lt() {
  if (less_than_case() != kLt) {
    clear_less_than();
    set_has_lt();
    _impl_.less_than_.lt_ = CreateMaybeMessage< ::google::protobuf::Timestamp >(GetArenaForAllocation());
  }
  return _impl_.less_than_.lt_;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_lt() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_lt();
  // @@protoc_insertion_point(field_mutable:buf.validate.TimestampRules.lt)
  return _msg;
}

// .google.protobuf.Timestamp lte = 4 [json_name = "lte", (.buf.validate.priv.field) = {
inline bool TimestampRules::has_lte() const {
  return less_than_case() == kLte;
}
inline bool TimestampRules::_internal_has_lte() const {
  return less_than_case() == kLte;
}
inline void TimestampRules::set_has_lte() {
  _impl_._oneof_case_[0] = kLte;
}
inline ::google::protobuf::Timestamp* TimestampRules::release_lte() {
  // @@protoc_insertion_point(field_release:buf.validate.TimestampRules.lte)
  if (less_than_case() == kLte) {
    clear_has_less_than();
    ::google::protobuf::Timestamp* temp = _impl_.less_than_.lte_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.less_than_.lte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_lte() const {
  return less_than_case() == kLte
      ? *_impl_.less_than_.lte_
      : reinterpret_cast<::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::lte() const {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.lte)
  return _internal_lte();
}
inline ::google::protobuf::Timestamp* TimestampRules::unsafe_arena_release_lte() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.TimestampRules.lte)
  if (less_than_case() == kLte) {
    clear_has_less_than();
    ::google::protobuf::Timestamp* temp = _impl_.less_than_.lte_;
    _impl_.less_than_.lte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TimestampRules::unsafe_arena_set_allocated_lte(::google::protobuf::Timestamp* lte) {
  clear_less_than();
  if (lte) {
    set_has_lte();
    _impl_.less_than_.lte_ = lte;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.TimestampRules.lte)
}
inline ::google::protobuf::Timestamp* TimestampRules::_internal_mutable_lte() {
  if (less_than_case() != kLte) {
    clear_less_than();
    set_has_lte();
    _impl_.less_than_.lte_ = CreateMaybeMessage< ::google::protobuf::Timestamp >(GetArenaForAllocation());
  }
  return _impl_.less_than_.lte_;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_lte() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_lte();
  // @@protoc_insertion_point(field_mutable:buf.validate.TimestampRules.lte)
  return _msg;
}

// bool lt_now = 7 [json_name = "ltNow", (.buf.validate.priv.field) = {
inline bool TimestampRules::has_lt_now() const {
  return less_than_case() == kLtNow;
}
inline void TimestampRules::set_has_lt_now() {
  _impl_._oneof_case_[0] = kLtNow;
}
inline void TimestampRules::clear_lt_now() {
  if (less_than_case() == kLtNow) {
    _impl_.less_than_.lt_now_ = false;
    clear_has_less_than();
  }
}
inline bool TimestampRules::lt_now() const {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.lt_now)
  return _internal_lt_now();
}
inline void TimestampRules::set_lt_now(bool value) {
  _internal_set_lt_now(value);
  // @@protoc_insertion_point(field_set:buf.validate.TimestampRules.lt_now)
}
inline bool TimestampRules::_internal_lt_now() const {
  if (less_than_case() == kLtNow) {
    return _impl_.less_than_.lt_now_;
  }
  return false;
}
inline void TimestampRules::_internal_set_lt_now(bool value) {
  if (less_than_case() != kLtNow) {
    clear_less_than();
    set_has_lt_now();
  }
  _impl_.less_than_.lt_now_ = value;
}

// .google.protobuf.Timestamp gt = 5 [json_name = "gt", (.buf.validate.priv.field) = {
inline bool TimestampRules::has_gt() const {
  return greater_than_case() == kGt;
}
inline bool TimestampRules::_internal_has_gt() const {
  return greater_than_case() == kGt;
}
inline void TimestampRules::set_has_gt() {
  _impl_._oneof_case_[1] = kGt;
}
inline ::google::protobuf::Timestamp* TimestampRules::release_gt() {
  // @@protoc_insertion_point(field_release:buf.validate.TimestampRules.gt)
  if (greater_than_case() == kGt) {
    clear_has_greater_than();
    ::google::protobuf::Timestamp* temp = _impl_.greater_than_.gt_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.greater_than_.gt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_gt() const {
  return greater_than_case() == kGt
      ? *_impl_.greater_than_.gt_
      : reinterpret_cast<::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::gt() const {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.gt)
  return _internal_gt();
}
inline ::google::protobuf::Timestamp* TimestampRules::unsafe_arena_release_gt() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.TimestampRules.gt)
  if (greater_than_case() == kGt) {
    clear_has_greater_than();
    ::google::protobuf::Timestamp* temp = _impl_.greater_than_.gt_;
    _impl_.greater_than_.gt_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TimestampRules::unsafe_arena_set_allocated_gt(::google::protobuf::Timestamp* gt) {
  clear_greater_than();
  if (gt) {
    set_has_gt();
    _impl_.greater_than_.gt_ = gt;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.TimestampRules.gt)
}
inline ::google::protobuf::Timestamp* TimestampRules::_internal_mutable_gt() {
  if (greater_than_case() != kGt) {
    clear_greater_than();
    set_has_gt();
    _impl_.greater_than_.gt_ = CreateMaybeMessage< ::google::protobuf::Timestamp >(GetArenaForAllocation());
  }
  return _impl_.greater_than_.gt_;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_gt() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_gt();
  // @@protoc_insertion_point(field_mutable:buf.validate.TimestampRules.gt)
  return _msg;
}

// .google.protobuf.Timestamp gte = 6 [json_name = "gte", (.buf.validate.priv.field) = {
inline bool TimestampRules::has_gte() const {
  return greater_than_case() == kGte;
}
inline bool TimestampRules::_internal_has_gte() const {
  return greater_than_case() == kGte;
}
inline void TimestampRules::set_has_gte() {
  _impl_._oneof_case_[1] = kGte;
}
inline ::google::protobuf::Timestamp* TimestampRules::release_gte() {
  // @@protoc_insertion_point(field_release:buf.validate.TimestampRules.gte)
  if (greater_than_case() == kGte) {
    clear_has_greater_than();
    ::google::protobuf::Timestamp* temp = _impl_.greater_than_.gte_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.greater_than_.gte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Timestamp& TimestampRules::_internal_gte() const {
  return greater_than_case() == kGte
      ? *_impl_.greater_than_.gte_
      : reinterpret_cast<::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& TimestampRules::gte() const {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.gte)
  return _internal_gte();
}
inline ::google::protobuf::Timestamp* TimestampRules::unsafe_arena_release_gte() {
  // @@protoc_insertion_point(field_unsafe_arena_release:buf.validate.TimestampRules.gte)
  if (greater_than_case() == kGte) {
    clear_has_greater_than();
    ::google::protobuf::Timestamp* temp = _impl_.greater_than_.gte_;
    _impl_.greater_than_.gte_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TimestampRules::unsafe_arena_set_allocated_gte(::google::protobuf::Timestamp* gte) {
  clear_greater_than();
  if (gte) {
    set_has_gte();
    _impl_.greater_than_.gte_ = gte;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.TimestampRules.gte)
}
inline ::google::protobuf::Timestamp* TimestampRules::_internal_mutable_gte() {
  if (greater_than_case() != kGte) {
    clear_greater_than();
    set_has_gte();
    _impl_.greater_than_.gte_ = CreateMaybeMessage< ::google::protobuf::Timestamp >(GetArenaForAllocation());
  }
  return _impl_.greater_than_.gte_;
}
inline ::google::protobuf::Timestamp* TimestampRules::mutable_gte() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_gte();
  // @@protoc_insertion_point(field_mutable:buf.validate.TimestampRules.gte)
  return _msg;
}

// bool gt_now = 8 [json_name = "gtNow", (.buf.validate.priv.field) = {
inline bool TimestampRules::has_gt_now() const {
  return greater_than_case() == kGtNow;
}
inline void TimestampRules::set_has_gt_now() {
  _impl_._oneof_case_[1] = kGtNow;
}
inline void TimestampRules::clear_gt_now() {
  if (greater_than_case() == kGtNow) {
    _impl_.greater_than_.gt_now_ = false;
    clear_has_greater_than();
  }
}
inline bool TimestampRules::gt_now() const {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.gt_now)
  return _internal_gt_now();
}
inline void TimestampRules::set_gt_now(bool value) {
  _internal_set_gt_now(value);
  // @@protoc_insertion_point(field_set:buf.validate.TimestampRules.gt_now)
}
inline bool TimestampRules::_internal_gt_now() const {
  if (greater_than_case() == kGtNow) {
    return _impl_.greater_than_.gt_now_;
  }
  return false;
}
inline void TimestampRules::_internal_set_gt_now(bool value) {
  if (greater_than_case() != kGtNow) {
    clear_greater_than();
    set_has_gt_now();
  }
  _impl_.greater_than_.gt_now_ = value;
}

// optional .google.protobuf.Duration within = 9 [json_name = "within", (.buf.validate.priv.field) = {
inline bool TimestampRules::has_within() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.within_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& TimestampRules::_internal_within() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.within_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& TimestampRules::within() const {
  // @@protoc_insertion_point(field_get:buf.validate.TimestampRules.within)
  return _internal_within();
}
inline void TimestampRules::unsafe_arena_set_allocated_within(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.within_);
  }
  _impl_.within_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:buf.validate.TimestampRules.within)
}
inline ::google::protobuf::Duration* TimestampRules::release_within() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* released = _impl_.within_;
  _impl_.within_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* TimestampRules::unsafe_arena_release_within() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:buf.validate.TimestampRules.within)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* temp = _impl_.within_;
  _impl_.within_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* TimestampRules::_internal_mutable_within() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.within_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Duration>(GetArenaForAllocation());
    _impl_.within_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.within_;
}
inline ::google::protobuf::Duration* TimestampRules::mutable_within() {
  ::google::protobuf::Duration* _msg = _internal_mutable_within();
  // @@protoc_insertion_point(field_mutable:buf.validate.TimestampRules.within)
  return _msg;
}
inline void TimestampRules::set_allocated_within(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.within_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.within_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.within)
}

inline bool TimestampRules::has_less_than() const {
  return less_than_case() != LESS_THAN_NOT_SET;
}
inline void TimestampRules::clear_has_less_than() {
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}
inline bool TimestampRules::has_greater_than() const {
  return greater_than_case() != GREATER_THAN_NOT_SET;
}
inline void TimestampRules::clear_has_greater_than() {
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}
inline TimestampRules::LessThanCase TimestampRules::less_than_case() const {
  return TimestampRules::LessThanCase(_impl_._oneof_case_[0]);
}
inline TimestampRules::GreaterThanCase TimestampRules::greater_than_case() const {
  return TimestampRules::GreaterThanCase(_impl_._oneof_case_[1]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace validate
}  // namespace buf


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::buf::validate::KnownRegex> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::buf::validate::KnownRegex>() {
  return ::buf::validate::KnownRegex_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_buf_2fvalidate_2fvalidate_2eproto_2epb_2eh
