// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: buf/validate/validate.proto

#include "buf/validate/validate.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace buf {
namespace validate {
        template <typename>
PROTOBUF_CONSTEXPR MessageConstraints::MessageConstraints(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.cel_)*/ {},
      /*decltype(_impl_.disabled_)*/ false,
    } {}
struct MessageConstraintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MessageConstraintsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MessageConstraintsDefaultTypeInternal() {}
  union {
    MessageConstraints _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MessageConstraintsDefaultTypeInternal _MessageConstraints_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR OneofConstraints::OneofConstraints(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.required_)*/ false,
    } {}
struct OneofConstraintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OneofConstraintsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~OneofConstraintsDefaultTypeInternal() {}
  union {
    OneofConstraints _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OneofConstraintsDefaultTypeInternal _OneofConstraints_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR FieldConstraints::FieldConstraints(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.cel_)*/ {},
      /*decltype(_impl_.skipped_)*/ false,
      /*decltype(_impl_.required_)*/ false,
      /*decltype(_impl_.ignore_empty_)*/ false,
      /*decltype(_impl_.type_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct FieldConstraintsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FieldConstraintsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FieldConstraintsDefaultTypeInternal() {}
  union {
    FieldConstraints _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FieldConstraintsDefaultTypeInternal _FieldConstraints_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR FloatRules::FloatRules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /*decltype(_impl_.not_in_)*/ {},
      /*decltype(_impl_.const__)*/ 0,
      /*decltype(_impl_.finite_)*/ false,
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct FloatRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FloatRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FloatRulesDefaultTypeInternal() {}
  union {
    FloatRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FloatRulesDefaultTypeInternal _FloatRules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR DoubleRules::DoubleRules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /*decltype(_impl_.not_in_)*/ {},
      /*decltype(_impl_.const__)*/ 0,
      /*decltype(_impl_.finite_)*/ false,
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct DoubleRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoubleRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoubleRulesDefaultTypeInternal() {}
  union {
    DoubleRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoubleRulesDefaultTypeInternal _DoubleRules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Int32Rules::Int32Rules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /* _impl_._in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.not_in_)*/ {},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.const__)*/ 0,
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct Int32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Int32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Int32RulesDefaultTypeInternal() {}
  union {
    Int32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Int32RulesDefaultTypeInternal _Int32Rules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Int64Rules::Int64Rules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /* _impl_._in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.not_in_)*/ {},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.const__)*/ ::int64_t{0},
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct Int64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Int64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Int64RulesDefaultTypeInternal() {}
  union {
    Int64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Int64RulesDefaultTypeInternal _Int64Rules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR UInt32Rules::UInt32Rules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /* _impl_._in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.not_in_)*/ {},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.const__)*/ 0u,
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct UInt32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UInt32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UInt32RulesDefaultTypeInternal() {}
  union {
    UInt32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UInt32RulesDefaultTypeInternal _UInt32Rules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR UInt64Rules::UInt64Rules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /* _impl_._in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.not_in_)*/ {},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.const__)*/ ::uint64_t{0u},
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct UInt64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UInt64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UInt64RulesDefaultTypeInternal() {}
  union {
    UInt64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UInt64RulesDefaultTypeInternal _UInt64Rules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SInt32Rules::SInt32Rules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /* _impl_._in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.not_in_)*/ {},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.const__)*/ 0,
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct SInt32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SInt32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SInt32RulesDefaultTypeInternal() {}
  union {
    SInt32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SInt32RulesDefaultTypeInternal _SInt32Rules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SInt64Rules::SInt64Rules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /* _impl_._in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.not_in_)*/ {},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.const__)*/ ::int64_t{0},
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct SInt64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SInt64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SInt64RulesDefaultTypeInternal() {}
  union {
    SInt64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SInt64RulesDefaultTypeInternal _SInt64Rules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Fixed32Rules::Fixed32Rules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /*decltype(_impl_.not_in_)*/ {},
      /*decltype(_impl_.const__)*/ 0u,
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct Fixed32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fixed32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fixed32RulesDefaultTypeInternal() {}
  union {
    Fixed32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fixed32RulesDefaultTypeInternal _Fixed32Rules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR Fixed64Rules::Fixed64Rules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /*decltype(_impl_.not_in_)*/ {},
      /*decltype(_impl_.const__)*/ ::uint64_t{0u},
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct Fixed64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Fixed64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~Fixed64RulesDefaultTypeInternal() {}
  union {
    Fixed64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Fixed64RulesDefaultTypeInternal _Fixed64Rules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SFixed32Rules::SFixed32Rules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /*decltype(_impl_.not_in_)*/ {},
      /*decltype(_impl_.const__)*/ 0,
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct SFixed32RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SFixed32RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SFixed32RulesDefaultTypeInternal() {}
  union {
    SFixed32Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SFixed32RulesDefaultTypeInternal _SFixed32Rules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR SFixed64Rules::SFixed64Rules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /*decltype(_impl_.not_in_)*/ {},
      /*decltype(_impl_.const__)*/ ::int64_t{0},
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct SFixed64RulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SFixed64RulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SFixed64RulesDefaultTypeInternal() {}
  union {
    SFixed64Rules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SFixed64RulesDefaultTypeInternal _SFixed64Rules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR BoolRules::BoolRules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.const__)*/ false,
    } {}
struct BoolRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BoolRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BoolRulesDefaultTypeInternal() {}
  union {
    BoolRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoolRulesDefaultTypeInternal _BoolRules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR StringRules::StringRules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /*decltype(_impl_.not_in_)*/ {},
      /*decltype(_impl_.const__)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.pattern_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.prefix_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.suffix_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.contains_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.not_contains_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.min_len_)*/ ::uint64_t{0u},
      /*decltype(_impl_.max_len_)*/ ::uint64_t{0u},
      /*decltype(_impl_.min_bytes_)*/ ::uint64_t{0u},
      /*decltype(_impl_.max_bytes_)*/ ::uint64_t{0u},
      /*decltype(_impl_.len_)*/ ::uint64_t{0u},
      /*decltype(_impl_.len_bytes_)*/ ::uint64_t{0u},
      /*decltype(_impl_.strict_)*/ false,
      /*decltype(_impl_.well_known_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct StringRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StringRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StringRulesDefaultTypeInternal() {}
  union {
    StringRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringRulesDefaultTypeInternal _StringRules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR BytesRules::BytesRules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /*decltype(_impl_.not_in_)*/ {},
      /*decltype(_impl_.const__)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.pattern_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.prefix_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.suffix_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.contains_)*/ {
          &::_pbi::fixed_address_empty_string,
          ::_pbi::ConstantInitialized{},
      },
      /*decltype(_impl_.min_len_)*/ ::uint64_t{0u},
      /*decltype(_impl_.max_len_)*/ ::uint64_t{0u},
      /*decltype(_impl_.len_)*/ ::uint64_t{0u},
      /*decltype(_impl_.well_known_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct BytesRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BytesRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~BytesRulesDefaultTypeInternal() {}
  union {
    BytesRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BytesRulesDefaultTypeInternal _BytesRules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR EnumRules::EnumRules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /* _impl_._in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.not_in_)*/ {},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      /*decltype(_impl_.const__)*/ 0,
      /*decltype(_impl_.defined_only_)*/ false,
    } {}
struct EnumRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnumRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnumRulesDefaultTypeInternal() {}
  union {
    EnumRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnumRulesDefaultTypeInternal _EnumRules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR RepeatedRules::RepeatedRules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.items_)*/ nullptr,
      /*decltype(_impl_.min_items_)*/ ::uint64_t{0u},
      /*decltype(_impl_.max_items_)*/ ::uint64_t{0u},
      /*decltype(_impl_.unique_)*/ false,
    } {}
struct RepeatedRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RepeatedRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RepeatedRulesDefaultTypeInternal() {}
  union {
    RepeatedRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RepeatedRulesDefaultTypeInternal _RepeatedRules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR MapRules::MapRules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.keys_)*/ nullptr,
      /*decltype(_impl_.values_)*/ nullptr,
      /*decltype(_impl_.min_pairs_)*/ ::uint64_t{0u},
      /*decltype(_impl_.max_pairs_)*/ ::uint64_t{0u},
    } {}
struct MapRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapRulesDefaultTypeInternal() {}
  union {
    MapRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapRulesDefaultTypeInternal _MapRules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR AnyRules::AnyRules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.in_)*/ {},
      /*decltype(_impl_.not_in_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct AnyRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AnyRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AnyRulesDefaultTypeInternal() {}
  union {
    AnyRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AnyRulesDefaultTypeInternal _AnyRules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR DurationRules::DurationRules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.in_)*/ {},
      /*decltype(_impl_.not_in_)*/ {},
      /*decltype(_impl_.const__)*/ nullptr,
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct DurationRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DurationRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DurationRulesDefaultTypeInternal() {}
  union {
    DurationRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DurationRulesDefaultTypeInternal _DurationRules_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR TimestampRules::TimestampRules(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.const__)*/ nullptr,
      /*decltype(_impl_.within_)*/ nullptr,
      /*decltype(_impl_.less_than_)*/ {},
      /*decltype(_impl_.greater_than_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
    } {}
struct TimestampRulesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimestampRulesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimestampRulesDefaultTypeInternal() {}
  union {
    TimestampRules _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimestampRulesDefaultTypeInternal _TimestampRules_default_instance_;
}  // namespace validate
}  // namespace buf
static ::_pb::Metadata file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[24];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_buf_2fvalidate_2fvalidate_2eproto[1];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_buf_2fvalidate_2fvalidate_2eproto = nullptr;
const ::uint32_t TableStruct_buf_2fvalidate_2fvalidate_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::buf::validate::MessageConstraints, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::MessageConstraints, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::MessageConstraints, _impl_.disabled_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::MessageConstraints, _impl_.cel_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::OneofConstraints, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::OneofConstraints, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::OneofConstraints, _impl_.required_),
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_.cel_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_.skipped_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_.required_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_.ignore_empty_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_.type_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_.finite_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_.finite_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::BoolRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::BoolRules, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::BoolRules, _impl_.const__),
    0,
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.const__),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.min_len_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.max_len_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.len_bytes_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.min_bytes_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.max_bytes_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.pattern_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.prefix_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.suffix_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.contains_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.not_contains_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.not_in_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.strict_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_.well_known_),
    0,
    10,
    6,
    7,
    11,
    8,
    9,
    1,
    2,
    3,
    4,
    5,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    12,
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.const__),
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.len_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.min_len_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.max_len_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.pattern_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.prefix_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.suffix_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.contains_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.not_in_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_.well_known_),
    0,
    7,
    5,
    6,
    1,
    2,
    3,
    4,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _impl_.const__),
    PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _impl_.defined_only_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::EnumRules, _impl_.not_in_),
    0,
    1,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _impl_.min_items_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _impl_.max_items_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _impl_.unique_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::RepeatedRules, _impl_.items_),
    1,
    2,
    3,
    0,
    PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _impl_.min_pairs_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _impl_.max_pairs_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _impl_.keys_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::MapRules, _impl_.values_),
    2,
    3,
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::buf::validate::AnyRules, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::AnyRules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::AnyRules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_.in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_.not_in_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_.const__),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_.within_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_.less_than_),
    PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_.greater_than_),
    0,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    ~0u,
    1,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, 10, -1, sizeof(::buf::validate::MessageConstraints)},
        {12, 21, -1, sizeof(::buf::validate::OneofConstraints)},
        {22, -1, -1, sizeof(::buf::validate::FieldConstraints)},
        {56, 74, -1, sizeof(::buf::validate::FloatRules)},
        {82, 100, -1, sizeof(::buf::validate::DoubleRules)},
        {108, 125, -1, sizeof(::buf::validate::Int32Rules)},
        {132, 149, -1, sizeof(::buf::validate::Int64Rules)},
        {156, 173, -1, sizeof(::buf::validate::UInt32Rules)},
        {180, 197, -1, sizeof(::buf::validate::UInt64Rules)},
        {204, 221, -1, sizeof(::buf::validate::SInt32Rules)},
        {228, 245, -1, sizeof(::buf::validate::SInt64Rules)},
        {252, 269, -1, sizeof(::buf::validate::Fixed32Rules)},
        {276, 293, -1, sizeof(::buf::validate::Fixed64Rules)},
        {300, 317, -1, sizeof(::buf::validate::SFixed32Rules)},
        {324, 341, -1, sizeof(::buf::validate::SFixed64Rules)},
        {348, 357, -1, sizeof(::buf::validate::BoolRules)},
        {358, 392, -1, sizeof(::buf::validate::StringRules)},
        {417, 439, -1, sizeof(::buf::validate::BytesRules)},
        {452, 464, -1, sizeof(::buf::validate::EnumRules)},
        {468, 480, -1, sizeof(::buf::validate::RepeatedRules)},
        {484, 496, -1, sizeof(::buf::validate::MapRules)},
        {500, -1, -1, sizeof(::buf::validate::AnyRules)},
        {510, 527, -1, sizeof(::buf::validate::DurationRules)},
        {534, 552, -1, sizeof(::buf::validate::TimestampRules)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::buf::validate::_MessageConstraints_default_instance_._instance,
    &::buf::validate::_OneofConstraints_default_instance_._instance,
    &::buf::validate::_FieldConstraints_default_instance_._instance,
    &::buf::validate::_FloatRules_default_instance_._instance,
    &::buf::validate::_DoubleRules_default_instance_._instance,
    &::buf::validate::_Int32Rules_default_instance_._instance,
    &::buf::validate::_Int64Rules_default_instance_._instance,
    &::buf::validate::_UInt32Rules_default_instance_._instance,
    &::buf::validate::_UInt64Rules_default_instance_._instance,
    &::buf::validate::_SInt32Rules_default_instance_._instance,
    &::buf::validate::_SInt64Rules_default_instance_._instance,
    &::buf::validate::_Fixed32Rules_default_instance_._instance,
    &::buf::validate::_Fixed64Rules_default_instance_._instance,
    &::buf::validate::_SFixed32Rules_default_instance_._instance,
    &::buf::validate::_SFixed64Rules_default_instance_._instance,
    &::buf::validate::_BoolRules_default_instance_._instance,
    &::buf::validate::_StringRules_default_instance_._instance,
    &::buf::validate::_BytesRules_default_instance_._instance,
    &::buf::validate::_EnumRules_default_instance_._instance,
    &::buf::validate::_RepeatedRules_default_instance_._instance,
    &::buf::validate::_MapRules_default_instance_._instance,
    &::buf::validate::_AnyRules_default_instance_._instance,
    &::buf::validate::_DurationRules_default_instance_._instance,
    &::buf::validate::_TimestampRules_default_instance_._instance,
};
const char descriptor_table_protodef_buf_2fvalidate_2fvalidate_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\033buf/validate/validate.proto\022\014buf.valid"
    "ate\032\035buf/validate/expression.proto\032\037buf/"
    "validate/priv/private.proto\032 google/prot"
    "obuf/descriptor.proto\032\036google/protobuf/d"
    "uration.proto\032\037google/protobuf/timestamp"
    ".proto\"n\n\022MessageConstraints\022\037\n\010disabled"
    "\030\001 \001(\010H\000R\010disabled\210\001\001\022*\n\003cel\030\003 \003(\0132\030.buf"
    ".validate.ConstraintR\003celB\013\n\t_disabled\"@"
    "\n\020OneofConstraints\022\037\n\010required\030\001 \001(\010H\000R\010"
    "required\210\001\001B\013\n\t_required\"\365\t\n\020FieldConstr"
    "aints\022*\n\003cel\030\027 \003(\0132\030.buf.validate.Constr"
    "aintR\003cel\022\030\n\007skipped\030\030 \001(\010R\007skipped\022\032\n\010r"
    "equired\030\031 \001(\010R\010required\022!\n\014ignore_empty\030"
    "\032 \001(\010R\013ignoreEmpty\0220\n\005float\030\001 \001(\0132\030.buf."
    "validate.FloatRulesH\000R\005float\0223\n\006double\030\002"
    " \001(\0132\031.buf.validate.DoubleRulesH\000R\006doubl"
    "e\0220\n\005int32\030\003 \001(\0132\030.buf.validate.Int32Rul"
    "esH\000R\005int32\0220\n\005int64\030\004 \001(\0132\030.buf.validat"
    "e.Int64RulesH\000R\005int64\0223\n\006uint32\030\005 \001(\0132\031."
    "buf.validate.UInt32RulesH\000R\006uint32\0223\n\006ui"
    "nt64\030\006 \001(\0132\031.buf.validate.UInt64RulesH\000R"
    "\006uint64\0223\n\006sint32\030\007 \001(\0132\031.buf.validate.S"
    "Int32RulesH\000R\006sint32\0223\n\006sint64\030\010 \001(\0132\031.b"
    "uf.validate.SInt64RulesH\000R\006sint64\0226\n\007fix"
    "ed32\030\t \001(\0132\032.buf.validate.Fixed32RulesH\000"
    "R\007fixed32\0226\n\007fixed64\030\n \001(\0132\032.buf.validat"
    "e.Fixed64RulesH\000R\007fixed64\0229\n\010sfixed32\030\013 "
    "\001(\0132\033.buf.validate.SFixed32RulesH\000R\010sfix"
    "ed32\0229\n\010sfixed64\030\014 \001(\0132\033.buf.validate.SF"
    "ixed64RulesH\000R\010sfixed64\022-\n\004bool\030\r \001(\0132\027."
    "buf.validate.BoolRulesH\000R\004bool\0223\n\006string"
    "\030\016 \001(\0132\031.buf.validate.StringRulesH\000R\006str"
    "ing\0220\n\005bytes\030\017 \001(\0132\030.buf.validate.BytesR"
    "ulesH\000R\005bytes\022-\n\004enum\030\020 \001(\0132\027.buf.valida"
    "te.EnumRulesH\000R\004enum\0229\n\010repeated\030\022 \001(\0132\033"
    ".buf.validate.RepeatedRulesH\000R\010repeated\022"
    "*\n\003map\030\023 \001(\0132\026.buf.validate.MapRulesH\000R\003"
    "map\022*\n\003any\030\024 \001(\0132\026.buf.validate.AnyRules"
    "H\000R\003any\0229\n\010duration\030\025 \001(\0132\033.buf.validate"
    ".DurationRulesH\000R\010duration\022<\n\ttimestamp\030"
    "\026 \001(\0132\034.buf.validate.TimestampRulesH\000R\tt"
    "imestampB\006\n\004type\"\242\027\n\nFloatRules\022u\n\005const"
    "\030\001 \001(\002BZ\302HW\nU\n\013float.const\032Fthis != rule"
    "s.const \? \'value must equal %s\'.format(["
    "rules.const]) : \'\'H\002R\005const\210\001\001\022\243\001\n\002lt\030\002 "
    "\001(\002B\220\001\302H\214\001\n\211\001\n\010float.lt\032}!has(rules.gte)"
    " && !has(rules.gt) && (this.isNan() || t"
    "his >= rules.lt)\? \'value must be less th"
    "an %s\'.format([rules.lt]) : \'\'H\000R\002lt\022\264\001\n"
    "\003lte\030\003 \001(\002B\237\001\302H\233\001\n\230\001\n\tfloat.lte\032\212\001!has(r"
    "ules.gte) && !has(rules.gt) && (this.isN"
    "an() || this > rules.lte)\? \'value must b"
    "e less than or equal to %s\'.format([rule"
    "s.lte]) : \'\'H\000R\003lte\022\363\007\n\002gt\030\004 \001(\002B\340\007\302H\334\007\n"
    "\215\001\n\010float.gt\032\200\001!has(rules.lt) && !has(ru"
    "les.lte) && (this.isNan() || this <= rul"
    "es.gt)\? \'value must be greater than %s\'."
    "format([rules.gt]) : \'\'\n\303\001\n\013float.gt_lt\032"
    "\263\001has(rules.lt) && rules.lt >= rules.gt "
    "&& (this.isNan() || this >= rules.lt || "
    "this <= rules.gt)\? \'value must be greate"
    "r than %s and less than %s\'.format([rule"
    "s.gt, rules.lt]) : \'\'\n\315\001\n\025float.gt_lt_ex"
    "clusive\032\263\001has(rules.lt) && rules.lt < ru"
    "les.gt && (this.isNan() || (rules.lt <= "
    "this && this <= rules.gt))\? \'value must "
    "be greater than %s or less than %s\'.form"
    "at([rules.gt, rules.lt]) : \'\'\n\323\001\n\014float."
    "gt_lte\032\302\001has(rules.lte) && rules.lte >= "
    "rules.gt && (this.isNan() || this > rule"
    "s.lte || this <= rules.gt)\? \'value must "
    "be greater than %s and less than or equa"
    "l to %s\'.format([rules.gt, rules.lte]) :"
    " \'\'\n\335\001\n\026float.gt_lte_exclusive\032\302\001has(rul"
    "es.lte) && rules.lte < rules.gt && (this"
    ".isNan() || (rules.lte < this && this <="
    " rules.gt))\? \'value must be greater than"
    " %s or less than or equal to %s\'.format("
    "[rules.gt, rules.lte]) : \'\'H\001R\002gt\022\277\010\n\003gt"
    "e\030\005 \001(\002B\252\010\302H\246\010\n\233\001\n\tfloat.gte\032\215\001!has(rule"
    "s.lt) && !has(rules.lte) && (this.isNan("
    ") || this < rules.gte)\? \'value must be g"
    "reater than or equal to %s\'.format([rule"
    "s.gte]) : \'\'\n\322\001\n\014float.gte_lt\032\301\001has(rule"
    "s.lt) && rules.lt >= rules.gte && (this."
    "isNan() || this >= rules.lt || this < ru"
    "les.gte)\? \'value must be greater than or"
    " equal to %s and less than %s\'.format([r"
    "ules.gte, rules.lt]) : \'\'\n\334\001\n\026float.gte_"
    "lt_exclusive\032\301\001has(rules.lt) && rules.lt"
    " < rules.gte && (this.isNan() || (rules."
    "lt <= this && this < rules.gte))\? \'value"
    " must be greater than or equal to %s or "
    "less than %s\'.format([rules.gte, rules.l"
    "t]) : \'\'\n\342\001\n\rfloat.gte_lte\032\320\001has(rules.l"
    "te) && rules.lte >= rules.gte && (this.i"
    "sNan() || this > rules.lte || this < rul"
    "es.gte)\? \'value must be greater than or "
    "equal to %s and less than or equal to %s"
    "\'.format([rules.gte, rules.lte]) : \'\'\n\354\001"
    "\n\027float.gte_lte_exclusive\032\320\001has(rules.lt"
    "e) && rules.lte < rules.gte && (this.isN"
    "an() || (rules.lte < this && this < rule"
    "s.gte))\? \'value must be greater than or "
    "equal to %s or less than or equal to %s\'"
    ".format([rules.gte, rules.lte]) : \'\'H\001R\003"
    "gte\022y\n\002in\030\006 \003(\002Bi\302Hf\nd\n\010float.in\032X!(this"
    " in dyn(rules)[\'in\']) \? \'value must be i"
    "n list %s\'.format([dyn(rules)[\'in\']]) : "
    "\'\'R\002in\022}\n\006not_in\030\007 \003(\002Bf\302Hc\na\n\014float.not"
    "_in\032Qthis in rules.not_in \? \'value must "
    "not be in list %s\'.format([rules.not_in]"
    ") : \'\'R\005notIn\022g\n\006finite\030\010 \001(\010BO\302HL\nJ\n\014fl"
    "oat.finite\032:this.isNan() || this.isInf()"
    " \? \'value must be finite\' : \'\'R\006finiteB\013"
    "\n\tless_thanB\016\n\014greater_thanB\010\n\006_const\"\263\027"
    "\n\013DoubleRules\022v\n\005const\030\001 \001(\001B[\302HX\nV\n\014dou"
    "ble.const\032Fthis != rules.const \? \'value "
    "must equal %s\'.format([rules.const]) : \'"
    "\'H\002R\005const\210\001\001\022\244\001\n\002lt\030\002 \001(\001B\221\001\302H\215\001\n\212\001\n\tdo"
    "uble.lt\032}!has(rules.gte) && !has(rules.g"
    "t) && (this.isNan() || this >= rules.lt)"
    "\? \'value must be less than %s\'.format([r"
    "ules.lt]) : \'\'H\000R\002lt\022\265\001\n\003lte\030\003 \001(\001B\240\001\302H\234"
    "\001\n\231\001\n\ndouble.lte\032\212\001!has(rules.gte) && !h"
    "as(rules.gt) && (this.isNan() || this > "
    "rules.lte)\? \'value must be less than or "
    "equal to %s\'.format([rules.lte]) : \'\'H\000R"
    "\003lte\022\370\007\n\002gt\030\004 \001(\001B\345\007\302H\341\007\n\216\001\n\tdouble.gt\032\200"
    "\001!has(rules.lt) && !has(rules.lte) && (t"
    "his.isNan() || this <= rules.gt)\? \'value"
    " must be greater than %s\'.format([rules."
    "gt]) : \'\'\n\304\001\n\014double.gt_lt\032\263\001has(rules.l"
    "t) && rules.lt >= rules.gt && (this.isNa"
    "n() || this >= rules.lt || this <= rules"
    ".gt)\? \'value must be greater than %s and"
    " less than %s\'.format([rules.gt, rules.l"
    "t]) : \'\'\n\316\001\n\026double.gt_lt_exclusive\032\263\001ha"
    "s(rules.lt) && rules.lt < rules.gt && (t"
    "his.isNan() || (rules.lt <= this && this"
    " <= rules.gt))\? \'value must be greater t"
    "han %s or less than %s\'.format([rules.gt"
    ", rules.lt]) : \'\'\n\324\001\n\rdouble.gt_lte\032\302\001ha"
    "s(rules.lte) && rules.lte >= rules.gt &&"
    " (this.isNan() || this > rules.lte || th"
    "is <= rules.gt)\? \'value must be greater "
    "than %s and less than or equal to %s\'.fo"
    "rmat([rules.gt, rules.lte]) : \'\'\n\336\001\n\027dou"
    "ble.gt_lte_exclusive\032\302\001has(rules.lte) &&"
    " rules.lte < rules.gt && (this.isNan() |"
    "| (rules.lte < this && this <= rules.gt)"
    ")\? \'value must be greater than %s or les"
    "s than or equal to %s\'.format([rules.gt,"
    " rules.lte]) : \'\'H\001R\002gt\022\304\010\n\003gte\030\005 \001(\001B\257\010"
    "\302H\253\010\n\234\001\n\ndouble.gte\032\215\001!has(rules.lt) && "
    "!has(rules.lte) && (this.isNan() || this"
    " < rules.gte)\? \'value must be greater th"
    "an or equal to %s\'.format([rules.gte]) :"
    " \'\'\n\323\001\n\rdouble.gte_lt\032\301\001has(rules.lt) &&"
    " rules.lt >= rules.gte && (this.isNan() "
    "|| this >= rules.lt || this < rules.gte)"
    "\? \'value must be greater than or equal t"
    "o %s and less than %s\'.format([rules.gte"
    ", rules.lt]) : \'\'\n\335\001\n\027double.gte_lt_excl"
    "usive\032\301\001has(rules.lt) && rules.lt < rule"
    "s.gte && (this.isNan() || (rules.lt <= t"
    "his && this < rules.gte))\? \'value must b"
    "e greater than or equal to %s or less th"
    "an %s\'.format([rules.gte, rules.lt]) : \'"
    "\'\n\343\001\n\016double.gte_lte\032\320\001has(rules.lte) &&"
    " rules.lte >= rules.gte && (this.isNan()"
    " || this > rules.lte || this < rules.gte"
    ")\? \'value must be greater than or equal "
    "to %s and less than or equal to %s\'.form"
    "at([rules.gte, rules.lte]) : \'\'\n\355\001\n\030doub"
    "le.gte_lte_exclusive\032\320\001has(rules.lte) &&"
    " rules.lte < rules.gte && (this.isNan() "
    "|| (rules.lte < this && this < rules.gte"
    "))\? \'value must be greater than or equal"
    " to %s or less than or equal to %s\'.form"
    "at([rules.gte, rules.lte]) : \'\'H\001R\003gte\022z"
    "\n\002in\030\006 \003(\001Bj\302Hg\ne\n\tdouble.in\032X!(this in "
    "dyn(rules)[\'in\']) \? \'value must be in li"
    "st %s\'.format([dyn(rules)[\'in\']]) : \'\'R\002"
    "in\022~\n\006not_in\030\007 \003(\001Bg\302Hd\nb\n\rdouble.not_in"
    "\032Qthis in rules.not_in \? \'value must not"
    " be in list %s\'.format([rules.not_in]) :"
    " \'\'R\005notIn\022h\n\006finite\030\010 \001(\010BP\302HM\nK\n\rdoubl"
    "e.finite\032:this.isNan() || this.isInf() \?"
    " \'value must be finite\' : \'\'R\006finiteB\013\n\t"
    "less_thanB\016\n\014greater_thanB\010\n\006_const\"\342\024\n\n"
    "Int32Rules\022u\n\005const\030\001 \001(\005BZ\302HW\nU\n\013int32."
    "const\032Fthis != rules.const \? \'value must"
    " equal %s\'.format([rules.const]) : \'\'H\002R"
    "\005const\210\001\001\022\216\001\n\002lt\030\002 \001(\005B|\302Hy\nw\n\010int32.lt\032"
    "k!has(rules.gte) && !has(rules.gt) && th"
    "is >= rules.lt\? \'value must be less than"
    " %s\'.format([rules.lt]) : \'\'H\000R\002lt\022\241\001\n\003l"
    "te\030\003 \001(\005B\214\001\302H\210\001\n\205\001\n\tint32.lte\032x!has(rule"
    "s.gte) && !has(rules.gt) && this > rules"
    ".lte\? \'value must be less than or equal "
    "to %s\'.format([rules.lte]) : \'\'H\000R\003lte\022\233"
    "\007\n\002gt\030\004 \001(\005B\210\007\302H\204\007\nz\n\010int32.gt\032n!has(rul"
    "es.lt) && !has(rules.lte) && this <= rul"
    "es.gt\? \'value must be greater than %s\'.f"
    "ormat([rules.gt]) : \'\'\n\263\001\n\013int32.gt_lt\032\243"
    "\001has(rules.lt) && rules.lt >= rules.gt &"
    "& (this >= rules.lt || this <= rules.gt)"
    "\? \'value must be greater than %s and les"
    "s than %s\'.format([rules.gt, rules.lt]) "
    ": \'\'\n\273\001\n\025int32.gt_lt_exclusive\032\241\001has(rul"
    "es.lt) && rules.lt < rules.gt && (rules."
    "lt <= this && this <= rules.gt)\? \'value "
    "must be greater than %s or less than %s\'"
    ".format([rules.gt, rules.lt]) : \'\'\n\303\001\n\014i"
    "nt32.gt_lte\032\262\001has(rules.lte) && rules.lt"
    "e >= rules.gt && (this > rules.lte || th"
    "is <= rules.gt)\? \'value must be greater "
    "than %s and less than or equal to %s\'.fo"
    "rmat([rules.gt, rules.lte]) : \'\'\n\313\001\n\026int"
    "32.gt_lte_exclusive\032\260\001has(rules.lte) && "
    "rules.lte < rules.gt && (rules.lte < thi"
    "s && this <= rules.gt)\? \'value must be g"
    "reater than %s or less than or equal to "
    "%s\'.format([rules.gt, rules.lte]) : \'\'H\001"
    "R\002gt\022\350\007\n\003gte\030\005 \001(\005B\323\007\302H\317\007\n\210\001\n\tint32.gte\032"
    "{!has(rules.lt) && !has(rules.lte) && th"
    "is < rules.gte\? \'value must be greater t"
    "han or equal to %s\'.format([rules.gte]) "
    ": \'\'\n\302\001\n\014int32.gte_lt\032\261\001has(rules.lt) &&"
    " rules.lt >= rules.gte && (this >= rules"
    ".lt || this < rules.gte)\? \'value must be"
    " greater than or equal to %s and less th"
    "an %s\'.format([rules.gte, rules.lt]) : \'"
    "\'\n\312\001\n\026int32.gte_lt_exclusive\032\257\001has(rules"
    ".lt) && rules.lt < rules.gte && (rules.l"
    "t <= this && this < rules.gte)\? \'value m"
    "ust be greater than or equal to %s or le"
    "ss than %s\'.format([rules.gte, rules.lt]"
    ") : \'\'\n\322\001\n\rint32.gte_lte\032\300\001has(rules.lte"
    ") && rules.lte >= rules.gte && (this > r"
    "ules.lte || this < rules.gte)\? \'value mu"
    "st be greater than or equal to %s and le"
    "ss than or equal to %s\'.format([rules.gt"
    "e, rules.lte]) : \'\'\n\332\001\n\027int32.gte_lte_ex"
    "clusive\032\276\001has(rules.lte) && rules.lte < "
    "rules.gte && (rules.lte < this && this <"
    " rules.gte)\? \'value must be greater than"
    " or equal to %s or less than or equal to"
    " %s\'.format([rules.gte, rules.lte]) : \'\'"
    "H\001R\003gte\022y\n\002in\030\006 \003(\005Bi\302Hf\nd\n\010int32.in\032X!("
    "this in dyn(rules)[\'in\']) \? \'value must "
    "be in list %s\'.format([dyn(rules)[\'in\']]"
    ") : \'\'R\002in\022}\n\006not_in\030\007 \003(\005Bf\302Hc\na\n\014int32"
    ".not_in\032Qthis in rules.not_in \? \'value m"
    "ust not be in list %s\'.format([rules.not"
    "_in]) : \'\'R\005notInB\013\n\tless_thanB\016\n\014greate"
    "r_thanB\010\n\006_const\"\342\024\n\nInt64Rules\022u\n\005const"
    "\030\001 \001(\003BZ\302HW\nU\n\013int64.const\032Fthis != rule"
    "s.const \? \'value must equal %s\'.format(["
    "rules.const]) : \'\'H\002R\005const\210\001\001\022\216\001\n\002lt\030\002 "
    "\001(\003B|\302Hy\nw\n\010int64.lt\032k!has(rules.gte) &&"
    " !has(rules.gt) && this >= rules.lt\? \'va"
    "lue must be less than %s\'.format([rules."
    "lt]) : \'\'H\000R\002lt\022\241\001\n\003lte\030\003 \001(\003B\214\001\302H\210\001\n\205\001\n"
    "\tint64.lte\032x!has(rules.gte) && !has(rule"
    "s.gt) && this > rules.lte\? \'value must b"
    "e less than or equal to %s\'.format([rule"
    "s.lte]) : \'\'H\000R\003lte\022\233\007\n\002gt\030\004 \001(\003B\210\007\302H\204\007\n"
    "z\n\010int64.gt\032n!has(rules.lt) && !has(rule"
    "s.lte) && this <= rules.gt\? \'value must "
    "be greater than %s\'.format([rules.gt]) :"
    " \'\'\n\263\001\n\013int64.gt_lt\032\243\001has(rules.lt) && r"
    "ules.lt >= rules.gt && (this >= rules.lt"
    " || this <= rules.gt)\? \'value must be gr"
    "eater than %s and less than %s\'.format(["
    "rules.gt, rules.lt]) : \'\'\n\273\001\n\025int64.gt_l"
    "t_exclusive\032\241\001has(rules.lt) && rules.lt "
    "< rules.gt && (rules.lt <= this && this "
    "<= rules.gt)\? \'value must be greater tha"
    "n %s or less than %s\'.format([rules.gt, "
    "rules.lt]) : \'\'\n\303\001\n\014int64.gt_lte\032\262\001has(r"
    "ules.lte) && rules.lte >= rules.gt && (t"
    "his > rules.lte || this <= rules.gt)\? \'v"
    "alue must be greater than %s and less th"
    "an or equal to %s\'.format([rules.gt, rul"
    "es.lte]) : \'\'\n\313\001\n\026int64.gt_lte_exclusive"
    "\032\260\001has(rules.lte) && rules.lte < rules.g"
    "t && (rules.lte < this && this <= rules."
    "gt)\? \'value must be greater than %s or l"
    "ess than or equal to %s\'.format([rules.g"
    "t, rules.lte]) : \'\'H\001R\002gt\022\350\007\n\003gte\030\005 \001(\003B"
    "\323\007\302H\317\007\n\210\001\n\tint64.gte\032{!has(rules.lt) && "
    "!has(rules.lte) && this < rules.gte\? \'va"
    "lue must be greater than or equal to %s\'"
    ".format([rules.gte]) : \'\'\n\302\001\n\014int64.gte_"
    "lt\032\261\001has(rules.lt) && rules.lt >= rules."
    "gte && (this >= rules.lt || this < rules"
    ".gte)\? \'value must be greater than or eq"
    "ual to %s and less than %s\'.format([rule"
    "s.gte, rules.lt]) : \'\'\n\312\001\n\026int64.gte_lt_"
    "exclusive\032\257\001has(rules.lt) && rules.lt < "
    "rules.gte && (rules.lt <= this && this <"
    " rules.gte)\? \'value must be greater than"
    " or equal to %s or less than %s\'.format("
    "[rules.gte, rules.lt]) : \'\'\n\322\001\n\rint64.gt"
    "e_lte\032\300\001has(rules.lte) && rules.lte >= r"
    "ules.gte && (this > rules.lte || this < "
    "rules.gte)\? \'value must be greater than "
    "or equal to %s and less than or equal to"
    " %s\'.format([rules.gte, rules.lte]) : \'\'"
    "\n\332\001\n\027int64.gte_lte_exclusive\032\276\001has(rules"
    ".lte) && rules.lte < rules.gte && (rules"
    ".lte < this && this < rules.gte)\? \'value"
    " must be greater than or equal to %s or "
    "less than or equal to %s\'.format([rules."
    "gte, rules.lte]) : \'\'H\001R\003gte\022y\n\002in\030\006 \003(\003"
    "Bi\302Hf\nd\n\010int64.in\032X!(this in dyn(rules)["
    "\'in\']) \? \'value must be in list %s\'.form"
    "at([dyn(rules)[\'in\']]) : \'\'R\002in\022}\n\006not_i"
    "n\030\007 \003(\003Bf\302Hc\na\n\014int64.not_in\032Qthis in ru"
    "les.not_in \? \'value must not be in list "
    "%s\'.format([rules.not_in]) : \'\'R\005notInB\013"
    "\n\tless_thanB\016\n\014greater_thanB\010\n\006_const\"\362\024"
    "\n\013UInt32Rules\022v\n\005const\030\001 \001(\rB[\302HX\nV\n\014uin"
    "t32.const\032Fthis != rules.const \? \'value "
    "must equal %s\'.format([rules.const]) : \'"
    "\'H\002R\005const\210\001\001\022\217\001\n\002lt\030\002 \001(\rB}\302Hz\nx\n\tuint3"
    "2.lt\032k!has(rules.gte) && !has(rules.gt) "
    "&& this >= rules.lt\? \'value must be less"
    " than %s\'.format([rules.lt]) : \'\'H\000R\002lt\022"
    "\242\001\n\003lte\030\003 \001(\rB\215\001\302H\211\001\n\206\001\n\nuint32.lte\032x!ha"
    "s(rules.gte) && !has(rules.gt) && this >"
    " rules.lte\? \'value must be less than or "
    "equal to %s\'.format([rules.lte]) : \'\'H\000R"
    "\003lte\022\240\007\n\002gt\030\004 \001(\rB\215\007\302H\211\007\n{\n\tuint32.gt\032n!"
    "has(rules.lt) && !has(rules.lte) && this"
    " <= rules.gt\? \'value must be greater tha"
    "n %s\'.format([rules.gt]) : \'\'\n\264\001\n\014uint32"
    ".gt_lt\032\243\001has(rules.lt) && rules.lt >= ru"
    "les.gt && (this >= rules.lt || this <= r"
    "ules.gt)\? \'value must be greater than %s"
    " and less than %s\'.format([rules.gt, rul"
    "es.lt]) : \'\'\n\274\001\n\026uint32.gt_lt_exclusive\032"
    "\241\001has(rules.lt) && rules.lt < rules.gt &"
    "& (rules.lt <= this && this <= rules.gt)"
    "\? \'value must be greater than %s or less"
    " than %s\'.format([rules.gt, rules.lt]) :"
    " \'\'\n\304\001\n\ruint32.gt_lte\032\262\001has(rules.lte) &"
    "& rules.lte >= rules.gt && (this > rules"
    ".lte || this <= rules.gt)\? \'value must b"
    "e greater than %s and less than or equal"
    " to %s\'.format([rules.gt, rules.lte]) : "
    "\'\'\n\314\001\n\027uint32.gt_lte_exclusive\032\260\001has(rul"
    "es.lte) && rules.lte < rules.gt && (rule"
    "s.lte < this && this <= rules.gt)\? \'valu"
    "e must be greater than %s or less than o"
    "r equal to %s\'.format([rules.gt, rules.l"
    "te]) : \'\'H\001R\002gt\022\355\007\n\003gte\030\005 \001(\rB\330\007\302H\324\007\n\211\001\n"
    "\nuint32.gte\032{!has(rules.lt) && !has(rule"
    "s.lte) && this < rules.gte\? \'value must "
    "be greater than or equal to %s\'.format(["
    "rules.gte]) : \'\'\n\303\001\n\ruint32.gte_lt\032\261\001has"
    "(rules.lt) && rules.lt >= rules.gte && ("
    "this >= rules.lt || this < rules.gte)\? \'"
    "value must be greater than or equal to %"
    "s and less than %s\'.format([rules.gte, r"
    "ules.lt]) : \'\'\n\313\001\n\027uint32.gte_lt_exclusi"
    "ve\032\257\001has(rules.lt) && rules.lt < rules.g"
    "te && (rules.lt <= this && this < rules."
    "gte)\? \'value must be greater than or equ"
    "al to %s or less than %s\'.format([rules."
    "gte, rules.lt]) : \'\'\n\323\001\n\016uint32.gte_lte\032"
    "\300\001has(rules.lte) && rules.lte >= rules.g"
    "te && (this > rules.lte || this < rules."
    "gte)\? \'value must be greater than or equ"
    "al to %s and less than or equal to %s\'.f"
    "ormat([rules.gte, rules.lte]) : \'\'\n\333\001\n\030u"
    "int32.gte_lte_exclusive\032\276\001has(rules.lte)"
    " && rules.lte < rules.gte && (rules.lte "
    "< this && this < rules.gte)\? \'value must"
    " be greater than or equal to %s or less "
    "than or equal to %s\'.format([rules.gte, "
    "rules.lte]) : \'\'H\001R\003gte\022z\n\002in\030\006 \003(\rBj\302Hg"
    "\ne\n\tuint32.in\032X!(this in dyn(rules)[\'in\'"
    "]) \? \'value must be in list %s\'.format(["
    "dyn(rules)[\'in\']]) : \'\'R\002in\022~\n\006not_in\030\007 "
    "\003(\rBg\302Hd\nb\n\ruint32.not_in\032Qthis in rules"
    ".not_in \? \'value must not be in list %s\'"
    ".format([rules.not_in]) : \'\'R\005notInB\013\n\tl"
    "ess_thanB\016\n\014greater_thanB\010\n\006_const\"\362\024\n\013U"
    "Int64Rules\022v\n\005const\030\001 \001(\004B[\302HX\nV\n\014uint64"
    ".const\032Fthis != rules.const \? \'value mus"
    "t equal %s\'.format([rules.const]) : \'\'H\002"
    "R\005const\210\001\001\022\217\001\n\002lt\030\002 \001(\004B}\302Hz\nx\n\tuint64.l"
    "t\032k!has(rules.gte) && !has(rules.gt) && "
    "this >= rules.lt\? \'value must be less th"
    "an %s\'.format([rules.lt]) : \'\'H\000R\002lt\022\242\001\n"
    "\003lte\030\003 \001(\004B\215\001\302H\211\001\n\206\001\n\nuint64.lte\032x!has(r"
    "ules.gte) && !has(rules.gt) && this > ru"
    "les.lte\? \'value must be less than or equ"
    "al to %s\'.format([rules.lte]) : \'\'H\000R\003lt"
    "e\022\240\007\n\002gt\030\004 \001(\004B\215\007\302H\211\007\n{\n\tuint64.gt\032n!has"
    "(rules.lt) && !has(rules.lte) && this <="
    " rules.gt\? \'value must be greater than %"
    "s\'.format([rules.gt]) : \'\'\n\264\001\n\014uint64.gt"
    "_lt\032\243\001has(rules.lt) && rules.lt >= rules"
    ".gt && (this >= rules.lt || this <= rule"
    "s.gt)\? \'value must be greater than %s an"
    "d less than %s\'.format([rules.gt, rules."
    "lt]) : \'\'\n\274\001\n\026uint64.gt_lt_exclusive\032\241\001h"
    "as(rules.lt) && rules.lt < rules.gt && ("
    "rules.lt <= this && this <= rules.gt)\? \'"
    "value must be greater than %s or less th"
    "an %s\'.format([rules.gt, rules.lt]) : \'\'"
    "\n\304\001\n\ruint64.gt_lte\032\262\001has(rules.lte) && r"
    "ules.lte >= rules.gt && (this > rules.lt"
    "e || this <= rules.gt)\? \'value must be g"
    "reater than %s and less than or equal to"
    " %s\'.format([rules.gt, rules.lte]) : \'\'\n"
    "\314\001\n\027uint64.gt_lte_exclusive\032\260\001has(rules."
    "lte) && rules.lte < rules.gt && (rules.l"
    "te < this && this <= rules.gt)\? \'value m"
    "ust be greater than %s or less than or e"
    "qual to %s\'.format([rules.gt, rules.lte]"
    ") : \'\'H\001R\002gt\022\355\007\n\003gte\030\005 \001(\004B\330\007\302H\324\007\n\211\001\n\nui"
    "nt64.gte\032{!has(rules.lt) && !has(rules.l"
    "te) && this < rules.gte\? \'value must be "
    "greater than or equal to %s\'.format([rul"
    "es.gte]) : \'\'\n\303\001\n\ruint64.gte_lt\032\261\001has(ru"
    "les.lt) && rules.lt >= rules.gte && (thi"
    "s >= rules.lt || this < rules.gte)\? \'val"
    "ue must be greater than or equal to %s a"
    "nd less than %s\'.format([rules.gte, rule"
    "s.lt]) : \'\'\n\313\001\n\027uint64.gte_lt_exclusive\032"
    "\257\001has(rules.lt) && rules.lt < rules.gte "
    "&& (rules.lt <= this && this < rules.gte"
    ")\? \'value must be greater than or equal "
    "to %s or less than %s\'.format([rules.gte"
    ", rules.lt]) : \'\'\n\323\001\n\016uint64.gte_lte\032\300\001h"
    "as(rules.lte) && rules.lte >= rules.gte "
    "&& (this > rules.lte || this < rules.gte"
    ")\? \'value must be greater than or equal "
    "to %s and less than or equal to %s\'.form"
    "at([rules.gte, rules.lte]) : \'\'\n\333\001\n\030uint"
    "64.gte_lte_exclusive\032\276\001has(rules.lte) &&"
    " rules.lte < rules.gte && (rules.lte < t"
    "his && this < rules.gte)\? \'value must be"
    " greater than or equal to %s or less tha"
    "n or equal to %s\'.format([rules.gte, rul"
    "es.lte]) : \'\'H\001R\003gte\022z\n\002in\030\006 \003(\004Bj\302Hg\ne\n"
    "\tuint64.in\032X!(this in dyn(rules)[\'in\']) "
    "\? \'value must be in list %s\'.format([dyn"
    "(rules)[\'in\']]) : \'\'R\002in\022~\n\006not_in\030\007 \003(\004"
    "Bg\302Hd\nb\n\ruint64.not_in\032Qthis in rules.no"
    "t_in \? \'value must not be in list %s\'.fo"
    "rmat([rules.not_in]) : \'\'R\005notInB\013\n\tless"
    "_thanB\016\n\014greater_thanB\010\n\006_const\"\362\024\n\013SInt"
    "32Rules\022v\n\005const\030\001 \001(\021B[\302HX\nV\n\014sint32.co"
    "nst\032Fthis != rules.const \? \'value must e"
    "qual %s\'.format([rules.const]) : \'\'H\002R\005c"
    "onst\210\001\001\022\217\001\n\002lt\030\002 \001(\021B}\302Hz\nx\n\tsint32.lt\032k"
    "!has(rules.gte) && !has(rules.gt) && thi"
    "s >= rules.lt\? \'value must be less than "
    "%s\'.format([rules.lt]) : \'\'H\000R\002lt\022\242\001\n\003lt"
    "e\030\003 \001(\021B\215\001\302H\211\001\n\206\001\n\nsint32.lte\032x!has(rule"
    "s.gte) && !has(rules.gt) && this > rules"
    ".lte\? \'value must be less than or equal "
    "to %s\'.format([rules.lte]) : \'\'H\000R\003lte\022\240"
    "\007\n\002gt\030\004 \001(\021B\215\007\302H\211\007\n{\n\tsint32.gt\032n!has(ru"
    "les.lt) && !has(rules.lte) && this <= ru"
    "les.gt\? \'value must be greater than %s\'."
    "format([rules.gt]) : \'\'\n\264\001\n\014sint32.gt_lt"
    "\032\243\001has(rules.lt) && rules.lt >= rules.gt"
    " && (this >= rules.lt || this <= rules.g"
    "t)\? \'value must be greater than %s and l"
    "ess than %s\'.format([rules.gt, rules.lt]"
    ") : \'\'\n\274\001\n\026sint32.gt_lt_exclusive\032\241\001has("
    "rules.lt) && rules.lt < rules.gt && (rul"
    "es.lt <= this && this <= rules.gt)\? \'val"
    "ue must be greater than %s or less than "
    "%s\'.format([rules.gt, rules.lt]) : \'\'\n\304\001"
    "\n\rsint32.gt_lte\032\262\001has(rules.lte) && rule"
    "s.lte >= rules.gt && (this > rules.lte |"
    "| this <= rules.gt)\? \'value must be grea"
    "ter than %s and less than or equal to %s"
    "\'.format([rules.gt, rules.lte]) : \'\'\n\314\001\n"
    "\027sint32.gt_lte_exclusive\032\260\001has(rules.lte"
    ") && rules.lte < rules.gt && (rules.lte "
    "< this && this <= rules.gt)\? \'value must"
    " be greater than %s or less than or equa"
    "l to %s\'.format([rules.gt, rules.lte]) :"
    " \'\'H\001R\002gt\022\355\007\n\003gte\030\005 \001(\021B\330\007\302H\324\007\n\211\001\n\nsint3"
    "2.gte\032{!has(rules.lt) && !has(rules.lte)"
    " && this < rules.gte\? \'value must be gre"
    "ater than or equal to %s\'.format([rules."
    "gte]) : \'\'\n\303\001\n\rsint32.gte_lt\032\261\001has(rules"
    ".lt) && rules.lt >= rules.gte && (this >"
    "= rules.lt || this < rules.gte)\? \'value "
    "must be greater than or equal to %s and "
    "less than %s\'.format([rules.gte, rules.l"
    "t]) : \'\'\n\313\001\n\027sint32.gte_lt_exclusive\032\257\001h"
    "as(rules.lt) && rules.lt < rules.gte && "
    "(rules.lt <= this && this < rules.gte)\? "
    "\'value must be greater than or equal to "
    "%s or less than %s\'.format([rules.gte, r"
    "ules.lt]) : \'\'\n\323\001\n\016sint32.gte_lte\032\300\001has("
    "rules.lte) && rules.lte >= rules.gte && "
    "(this > rules.lte || this < rules.gte)\? "
    "\'value must be greater than or equal to "
    "%s and less than or equal to %s\'.format("
    "[rules.gte, rules.lte]) : \'\'\n\333\001\n\030sint32."
    "gte_lte_exclusive\032\276\001has(rules.lte) && ru"
    "les.lte < rules.gte && (rules.lte < this"
    " && this < rules.gte)\? \'value must be gr"
    "eater than or equal to %s or less than o"
    "r equal to %s\'.format([rules.gte, rules."
    "lte]) : \'\'H\001R\003gte\022z\n\002in\030\006 \003(\021Bj\302Hg\ne\n\tsi"
    "nt32.in\032X!(this in dyn(rules)[\'in\']) \? \'"
    "value must be in list %s\'.format([dyn(ru"
    "les)[\'in\']]) : \'\'R\002in\022~\n\006not_in\030\007 \003(\021Bg\302"
    "Hd\nb\n\rsint32.not_in\032Qthis in rules.not_i"
    "n \? \'value must not be in list %s\'.forma"
    "t([rules.not_in]) : \'\'R\005notInB\013\n\tless_th"
    "anB\016\n\014greater_thanB\010\n\006_const\"\362\024\n\013SInt64R"
    "ules\022v\n\005const\030\001 \001(\022B[\302HX\nV\n\014sint64.const"
    "\032Fthis != rules.const \? \'value must equa"
    "l %s\'.format([rules.const]) : \'\'H\002R\005cons"
    "t\210\001\001\022\217\001\n\002lt\030\002 \001(\022B}\302Hz\nx\n\tsint64.lt\032k!ha"
    "s(rules.gte) && !has(rules.gt) && this >"
    "= rules.lt\? \'value must be less than %s\'"
    ".format([rules.lt]) : \'\'H\000R\002lt\022\242\001\n\003lte\030\003"
    " \001(\022B\215\001\302H\211\001\n\206\001\n\nsint64.lte\032x!has(rules.g"
    "te) && !has(rules.gt) && this > rules.lt"
    "e\? \'value must be less than or equal to "
    "%s\'.format([rules.lte]) : \'\'H\000R\003lte\022\240\007\n\002"
    "gt\030\004 \001(\022B\215\007\302H\211\007\n{\n\tsint64.gt\032n!has(rules"
    ".lt) && !has(rules.lte) && this <= rules"
    ".gt\? \'value must be greater than %s\'.for"
    "mat([rules.gt]) : \'\'\n\264\001\n\014sint64.gt_lt\032\243\001"
    "has(rules.lt) && rules.lt >= rules.gt &&"
    " (this >= rules.lt || this <= rules.gt)\?"
    " \'value must be greater than %s and less"
    " than %s\'.format([rules.gt, rules.lt]) :"
    " \'\'\n\274\001\n\026sint64.gt_lt_exclusive\032\241\001has(rul"
    "es.lt) && rules.lt < rules.gt && (rules."
    "lt <= this && this <= rules.gt)\? \'value "
    "must be greater than %s or less than %s\'"
    ".format([rules.gt, rules.lt]) : \'\'\n\304\001\n\rs"
    "int64.gt_lte\032\262\001has(rules.lte) && rules.l"
    "te >= rules.gt && (this > rules.lte || t"
    "his <= rules.gt)\? \'value must be greater"
    " than %s and less than or equal to %s\'.f"
    "ormat([rules.gt, rules.lte]) : \'\'\n\314\001\n\027si"
    "nt64.gt_lte_exclusive\032\260\001has(rules.lte) &"
    "& rules.lte < rules.gt && (rules.lte < t"
    "his && this <= rules.gt)\? \'value must be"
    " greater than %s or less than or equal t"
    "o %s\'.format([rules.gt, rules.lte]) : \'\'"
    "H\001R\002gt\022\355\007\n\003gte\030\005 \001(\022B\330\007\302H\324\007\n\211\001\n\nsint64.g"
    "te\032{!has(rules.lt) && !has(rules.lte) &&"
    " this < rules.gte\? \'value must be greate"
    "r than or equal to %s\'.format([rules.gte"
    "]) : \'\'\n\303\001\n\rsint64.gte_lt\032\261\001has(rules.lt"
    ") && rules.lt >= rules.gte && (this >= r"
    "ules.lt || this < rules.gte)\? \'value mus"
    "t be greater than or equal to %s and les"
    "s than %s\'.format([rules.gte, rules.lt])"
    " : \'\'\n\313\001\n\027sint64.gte_lt_exclusive\032\257\001has("
    "rules.lt) && rules.lt < rules.gte && (ru"
    "les.lt <= this && this < rules.gte)\? \'va"
    "lue must be greater than or equal to %s "
    "or less than %s\'.format([rules.gte, rule"
    "s.lt]) : \'\'\n\323\001\n\016sint64.gte_lte\032\300\001has(rul"
    "es.lte) && rules.lte >= rules.gte && (th"
    "is > rules.lte || this < rules.gte)\? \'va"
    "lue must be greater than or equal to %s "
    "and less than or equal to %s\'.format([ru"
    "les.gte, rules.lte]) : \'\'\n\333\001\n\030sint64.gte"
    "_lte_exclusive\032\276\001has(rules.lte) && rules"
    ".lte < rules.gte && (rules.lte < this &&"
    " this < rules.gte)\? \'value must be great"
    "er than or equal to %s or less than or e"
    "qual to %s\'.format([rules.gte, rules.lte"
    "]) : \'\'H\001R\003gte\022z\n\002in\030\006 \003(\022Bj\302Hg\ne\n\tsint6"
    "4.in\032X!(this in dyn(rules)[\'in\']) \? \'val"
    "ue must be in list %s\'.format([dyn(rules"
    ")[\'in\']]) : \'\'R\002in\022~\n\006not_in\030\007 \003(\022Bg\302Hd\n"
    "b\n\rsint64.not_in\032Qthis in rules.not_in \?"
    " \'value must not be in list %s\'.format(["
    "rules.not_in]) : \'\'R\005notInB\013\n\tless_thanB"
    "\016\n\014greater_thanB\010\n\006_const\"\202\025\n\014Fixed32Rul"
    "es\022w\n\005const\030\001 \001(\007B\\\302HY\nW\n\rfixed32.const\032"
    "Fthis != rules.const \? \'value must equal"
    " %s\'.format([rules.const]) : \'\'H\002R\005const"
    "\210\001\001\022\220\001\n\002lt\030\002 \001(\007B~\302H{\ny\n\nfixed32.lt\032k!ha"
    "s(rules.gte) && !has(rules.gt) && this >"
    "= rules.lt\? \'value must be less than %s\'"
    ".format([rules.lt]) : \'\'H\000R\002lt\022\243\001\n\003lte\030\003"
    " \001(\007B\216\001\302H\212\001\n\207\001\n\013fixed32.lte\032x!has(rules."
    "gte) && !has(rules.gt) && this > rules.l"
    "te\? \'value must be less than or equal to"
    " %s\'.format([rules.lte]) : \'\'H\000R\003lte\022\245\007\n"
    "\002gt\030\004 \001(\007B\222\007\302H\216\007\n|\n\nfixed32.gt\032n!has(rul"
    "es.lt) && !has(rules.lte) && this <= rul"
    "es.gt\? \'value must be greater than %s\'.f"
    "ormat([rules.gt]) : \'\'\n\265\001\n\rfixed32.gt_lt"
    "\032\243\001has(rules.lt) && rules.lt >= rules.gt"
    " && (this >= rules.lt || this <= rules.g"
    "t)\? \'value must be greater than %s and l"
    "ess than %s\'.format([rules.gt, rules.lt]"
    ") : \'\'\n\275\001\n\027fixed32.gt_lt_exclusive\032\241\001has"
    "(rules.lt) && rules.lt < rules.gt && (ru"
    "les.lt <= this && this <= rules.gt)\? \'va"
    "lue must be greater than %s or less than"
    " %s\'.format([rules.gt, rules.lt]) : \'\'\n\305"
    "\001\n\016fixed32.gt_lte\032\262\001has(rules.lte) && ru"
    "les.lte >= rules.gt && (this > rules.lte"
    " || this <= rules.gt)\? \'value must be gr"
    "eater than %s and less than or equal to "
    "%s\'.format([rules.gt, rules.lte]) : \'\'\n\315"
    "\001\n\030fixed32.gt_lte_exclusive\032\260\001has(rules."
    "lte) && rules.lte < rules.gt && (rules.l"
    "te < this && this <= rules.gt)\? \'value m"
    "ust be greater than %s or less than or e"
    "qual to %s\'.format([rules.gt, rules.lte]"
    ") : \'\'H\001R\002gt\022\362\007\n\003gte\030\005 \001(\007B\335\007\302H\331\007\n\212\001\n\013fi"
    "xed32.gte\032{!has(rules.lt) && !has(rules."
    "lte) && this < rules.gte\? \'value must be"
    " greater than or equal to %s\'.format([ru"
    "les.gte]) : \'\'\n\304\001\n\016fixed32.gte_lt\032\261\001has("
    "rules.lt) && rules.lt >= rules.gte && (t"
    "his >= rules.lt || this < rules.gte)\? \'v"
    "alue must be greater than or equal to %s"
    " and less than %s\'.format([rules.gte, ru"
    "les.lt]) : \'\'\n\314\001\n\030fixed32.gte_lt_exclusi"
    "ve\032\257\001has(rules.lt) && rules.lt < rules.g"
    "te && (rules.lt <= this && this < rules."
    "gte)\? \'value must be greater than or equ"
    "al to %s or less than %s\'.format([rules."
    "gte, rules.lt]) : \'\'\n\324\001\n\017fixed32.gte_lte"
    "\032\300\001has(rules.lte) && rules.lte >= rules."
    "gte && (this > rules.lte || this < rules"
    ".gte)\? \'value must be greater than or eq"
    "ual to %s and less than or equal to %s\'."
    "format([rules.gte, rules.lte]) : \'\'\n\334\001\n\031"
    "fixed32.gte_lte_exclusive\032\276\001has(rules.lt"
    "e) && rules.lte < rules.gte && (rules.lt"
    "e < this && this < rules.gte)\? \'value mu"
    "st be greater than or equal to %s or les"
    "s than or equal to %s\'.format([rules.gte"
    ", rules.lte]) : \'\'H\001R\003gte\022{\n\002in\030\006 \003(\007Bk\302"
    "Hh\nf\n\nfixed32.in\032X!(this in dyn(rules)[\'"
    "in\']) \? \'value must be in list %s\'.forma"
    "t([dyn(rules)[\'in\']]) : \'\'R\002in\022\177\n\006not_in"
    "\030\007 \003(\007Bh\302He\nc\n\016fixed32.not_in\032Qthis in r"
    "ules.not_in \? \'value must not be in list"
    " %s\'.format([rules.not_in]) : \'\'R\005notInB"
    "\013\n\tless_thanB\016\n\014greater_thanB\010\n\006_const\"\202"
    "\025\n\014Fixed64Rules\022w\n\005const\030\001 \001(\006B\\\302HY\nW\n\rf"
    "ixed64.const\032Fthis != rules.const \? \'val"
    "ue must equal %s\'.format([rules.const]) "
    ": \'\'H\002R\005const\210\001\001\022\220\001\n\002lt\030\002 \001(\006B~\302H{\ny\n\nfi"
    "xed64.lt\032k!has(rules.gte) && !has(rules."
    "gt) && this >= rules.lt\? \'value must be "
    "less than %s\'.format([rules.lt]) : \'\'H\000R"
    "\002lt\022\243\001\n\003lte\030\003 \001(\006B\216\001\302H\212\001\n\207\001\n\013fixed64.lte"
    "\032x!has(rules.gte) && !has(rules.gt) && t"
    "his > rules.lte\? \'value must be less tha"
    "n or equal to %s\'.format([rules.lte]) : "
    "\'\'H\000R\003lte\022\245\007\n\002gt\030\004 \001(\006B\222\007\302H\216\007\n|\n\nfixed64"
    ".gt\032n!has(rules.lt) && !has(rules.lte) &"
    "& this <= rules.gt\? \'value must be great"
    "er than %s\'.format([rules.gt]) : \'\'\n\265\001\n\r"
    "fixed64.gt_lt\032\243\001has(rules.lt) && rules.l"
    "t >= rules.gt && (this >= rules.lt || th"
    "is <= rules.gt)\? \'value must be greater "
    "than %s and less than %s\'.format([rules."
    "gt, rules.lt]) : \'\'\n\275\001\n\027fixed64.gt_lt_ex"
    "clusive\032\241\001has(rules.lt) && rules.lt < ru"
    "les.gt && (rules.lt <= this && this <= r"
    "ules.gt)\? \'value must be greater than %s"
    " or less than %s\'.format([rules.gt, rule"
    "s.lt]) : \'\'\n\305\001\n\016fixed64.gt_lte\032\262\001has(rul"
    "es.lte) && rules.lte >= rules.gt && (thi"
    "s > rules.lte || this <= rules.gt)\? \'val"
    "ue must be greater than %s and less than"
    " or equal to %s\'.format([rules.gt, rules"
    ".lte]) : \'\'\n\315\001\n\030fixed64.gt_lte_exclusive"
    "\032\260\001has(rules.lte) && rules.lte < rules.g"
    "t && (rules.lte < this && this <= rules."
    "gt)\? \'value must be greater than %s or l"
    "ess than or equal to %s\'.format([rules.g"
    "t, rules.lte]) : \'\'H\001R\002gt\022\362\007\n\003gte\030\005 \001(\006B"
    "\335\007\302H\331\007\n\212\001\n\013fixed64.gte\032{!has(rules.lt) &"
    "& !has(rules.lte) && this < rules.gte\? \'"
    "value must be greater than or equal to %"
    "s\'.format([rules.gte]) : \'\'\n\304\001\n\016fixed64."
    "gte_lt\032\261\001has(rules.lt) && rules.lt >= ru"
    "les.gte && (this >= rules.lt || this < r"
    "ules.gte)\? \'value must be greater than o"
    "r equal to %s and less than %s\'.format(["
    "rules.gte, rules.lt]) : \'\'\n\314\001\n\030fixed64.g"
    "te_lt_exclusive\032\257\001has(rules.lt) && rules"
    ".lt < rules.gte && (rules.lt <= this && "
    "this < rules.gte)\? \'value must be greate"
    "r than or equal to %s or less than %s\'.f"
    "ormat([rules.gte, rules.lt]) : \'\'\n\324\001\n\017fi"
    "xed64.gte_lte\032\300\001has(rules.lte) && rules."
    "lte >= rules.gte && (this > rules.lte ||"
    " this < rules.gte)\? \'value must be great"
    "er than or equal to %s and less than or "
    "equal to %s\'.format([rules.gte, rules.lt"
    "e]) : \'\'\n\334\001\n\031fixed64.gte_lte_exclusive\032\276"
    "\001has(rules.lte) && rules.lte < rules.gte"
    " && (rules.lte < this && this < rules.gt"
    "e)\? \'value must be greater than or equal"
    " to %s or less than or equal to %s\'.form"
    "at([rules.gte, rules.lte]) : \'\'H\001R\003gte\022{"
    "\n\002in\030\006 \003(\006Bk\302Hh\nf\n\nfixed64.in\032X!(this in"
    " dyn(rules)[\'in\']) \? \'value must be in l"
    "ist %s\'.format([dyn(rules)[\'in\']]) : \'\'R"
    "\002in\022\177\n\006not_in\030\007 \003(\006Bh\302He\nc\n\016fixed64.not_"
    "in\032Qthis in rules.not_in \? \'value must n"
    "ot be in list %s\'.format([rules.not_in])"
    " : \'\'R\005notInB\013\n\tless_thanB\016\n\014greater_tha"
    "nB\010\n\006_const\"\223\025\n\rSFixed32Rules\022x\n\005const\030\001"
    " \001(\017B]\302HZ\nX\n\016sfixed32.const\032Fthis != rul"
    "es.const \? \'value must equal %s\'.format("
    "[rules.const]) : \'\'H\002R\005const\210\001\001\022\221\001\n\002lt\030\002"
    " \001(\017B\177\302H|\nz\n\013sfixed32.lt\032k!has(rules.gte"
    ") && !has(rules.gt) && this >= rules.lt\?"
    " \'value must be less than %s\'.format([ru"
    "les.lt]) : \'\'H\000R\002lt\022\244\001\n\003lte\030\003 \001(\017B\217\001\302H\213\001"
    "\n\210\001\n\014sfixed32.lte\032x!has(rules.gte) && !h"
    "as(rules.gt) && this > rules.lte\? \'value"
    " must be less than or equal to %s\'.forma"
    "t([rules.lte]) : \'\'H\000R\003lte\022\252\007\n\002gt\030\004 \001(\017B"
    "\227\007\302H\223\007\n}\n\013sfixed32.gt\032n!has(rules.lt) &&"
    " !has(rules.lte) && this <= rules.gt\? \'v"
    "alue must be greater than %s\'.format([ru"
    "les.gt]) : \'\'\n\266\001\n\016sfixed32.gt_lt\032\243\001has(r"
    "ules.lt) && rules.lt >= rules.gt && (thi"
    "s >= rules.lt || this <= rules.gt)\? \'val"
    "ue must be greater than %s and less than"
    " %s\'.format([rules.gt, rules.lt]) : \'\'\n\276"
    "\001\n\030sfixed32.gt_lt_exclusive\032\241\001has(rules."
    "lt) && rules.lt < rules.gt && (rules.lt "
    "<= this && this <= rules.gt)\? \'value mus"
    "t be greater than %s or less than %s\'.fo"
    "rmat([rules.gt, rules.lt]) : \'\'\n\306\001\n\017sfix"
    "ed32.gt_lte\032\262\001has(rules.lte) && rules.lt"
    "e >= rules.gt && (this > rules.lte || th"
    "is <= rules.gt)\? \'value must be greater "
    "than %s and less than or equal to %s\'.fo"
    "rmat([rules.gt, rules.lte]) : \'\'\n\316\001\n\031sfi"
    "xed32.gt_lte_exclusive\032\260\001has(rules.lte) "
    "&& rules.lte < rules.gt && (rules.lte < "
    "this && this <= rules.gt)\? \'value must b"
    "e greater than %s or less than or equal "
    "to %s\'.format([rules.gt, rules.lte]) : \'"
    "\'H\001R\002gt\022\367\007\n\003gte\030\005 \001(\017B\342\007\302H\336\007\n\213\001\n\014sfixed3"
    "2.gte\032{!has(rules.lt) && !has(rules.lte)"
    " && this < rules.gte\? \'value must be gre"
    "ater than or equal to %s\'.format([rules."
    "gte]) : \'\'\n\305\001\n\017sfixed32.gte_lt\032\261\001has(rul"
    "es.lt) && rules.lt >= rules.gte && (this"
    " >= rules.lt || this < rules.gte)\? \'valu"
    "e must be greater than or equal to %s an"
    "d less than %s\'.format([rules.gte, rules"
    ".lt]) : \'\'\n\315\001\n\031sfixed32.gte_lt_exclusive"
    "\032\257\001has(rules.lt) && rules.lt < rules.gte"
    " && (rules.lt <= this && this < rules.gt"
    "e)\? \'value must be greater than or equal"
    " to %s or less than %s\'.format([rules.gt"
    "e, rules.lt]) : \'\'\n\325\001\n\020sfixed32.gte_lte\032"
    "\300\001has(rules.lte) && rules.lte >= rules.g"
    "te && (this > rules.lte || this < rules."
    "gte)\? \'value must be greater than or equ"
    "al to %s and less than or equal to %s\'.f"
    "ormat([rules.gte, rules.lte]) : \'\'\n\335\001\n\032s"
    "fixed32.gte_lte_exclusive\032\276\001has(rules.lt"
    "e) && rules.lte < rules.gte && (rules.lt"
    "e < this && this < rules.gte)\? \'value mu"
    "st be greater than or equal to %s or les"
    "s than or equal to %s\'.format([rules.gte"
    ", rules.lte]) : \'\'H\001R\003gte\022|\n\002in\030\006 \003(\017Bl\302"
    "Hi\ng\n\013sfixed32.in\032X!(this in dyn(rules)["
    "\'in\']) \? \'value must be in list %s\'.form"
    "at([dyn(rules)[\'in\']]) : \'\'R\002in\022\200\001\n\006not_"
    "in\030\007 \003(\017Bi\302Hf\nd\n\017sfixed32.not_in\032Qthis i"
    "n rules.not_in \? \'value must not be in l"
    "ist %s\'.format([rules.not_in]) : \'\'R\005not"
    "InB\013\n\tless_thanB\016\n\014greater_thanB\010\n\006_cons"
    "t\"\223\025\n\rSFixed64Rules\022x\n\005const\030\001 \001(\020B]\302HZ\n"
    "X\n\016sfixed64.const\032Fthis != rules.const \?"
    " \'value must equal %s\'.format([rules.con"
    "st]) : \'\'H\002R\005const\210\001\001\022\221\001\n\002lt\030\002 \001(\020B\177\302H|\n"
    "z\n\013sfixed64.lt\032k!has(rules.gte) && !has("
    "rules.gt) && this >= rules.lt\? \'value mu"
    "st be less than %s\'.format([rules.lt]) :"
    " \'\'H\000R\002lt\022\244\001\n\003lte\030\003 \001(\020B\217\001\302H\213\001\n\210\001\n\014sfixe"
    "d64.lte\032x!has(rules.gte) && !has(rules.g"
    "t) && this > rules.lte\? \'value must be l"
    "ess than or equal to %s\'.format([rules.l"
    "te]) : \'\'H\000R\003lte\022\252\007\n\002gt\030\004 \001(\020B\227\007\302H\223\007\n}\n\013"
    "sfixed64.gt\032n!has(rules.lt) && !has(rule"
    "s.lte) && this <= rules.gt\? \'value must "
    "be greater than %s\'.format([rules.gt]) :"
    " \'\'\n\266\001\n\016sfixed64.gt_lt\032\243\001has(rules.lt) &"
    "& rules.lt >= rules.gt && (this >= rules"
    ".lt || this <= rules.gt)\? \'value must be"
    " greater than %s and less than %s\'.forma"
    "t([rules.gt, rules.lt]) : \'\'\n\276\001\n\030sfixed6"
    "4.gt_lt_exclusive\032\241\001has(rules.lt) && rul"
    "es.lt < rules.gt && (rules.lt <= this &&"
    " this <= rules.gt)\? \'value must be great"
    "er than %s or less than %s\'.format([rule"
    "s.gt, rules.lt]) : \'\'\n\306\001\n\017sfixed64.gt_lt"
    "e\032\262\001has(rules.lte) && rules.lte >= rules"
    ".gt && (this > rules.lte || this <= rule"
    "s.gt)\? \'value must be greater than %s an"
    "d less than or equal to %s\'.format([rule"
    "s.gt, rules.lte]) : \'\'\n\316\001\n\031sfixed64.gt_l"
    "te_exclusive\032\260\001has(rules.lte) && rules.l"
    "te < rules.gt && (rules.lte < this && th"
    "is <= rules.gt)\? \'value must be greater "
    "than %s or less than or equal to %s\'.for"
    "mat([rules.gt, rules.lte]) : \'\'H\001R\002gt\022\367\007"
    "\n\003gte\030\005 \001(\020B\342\007\302H\336\007\n\213\001\n\014sfixed64.gte\032{!ha"
    "s(rules.lt) && !has(rules.lte) && this <"
    " rules.gte\? \'value must be greater than "
    "or equal to %s\'.format([rules.gte]) : \'\'"
    "\n\305\001\n\017sfixed64.gte_lt\032\261\001has(rules.lt) && "
    "rules.lt >= rules.gte && (this >= rules."
    "lt || this < rules.gte)\? \'value must be "
    "greater than or equal to %s and less tha"
    "n %s\'.format([rules.gte, rules.lt]) : \'\'"
    "\n\315\001\n\031sfixed64.gte_lt_exclusive\032\257\001has(rul"
    "es.lt) && rules.lt < rules.gte && (rules"
    ".lt <= this && this < rules.gte)\? \'value"
    " must be greater than or equal to %s or "
    "less than %s\'.format([rules.gte, rules.l"
    "t]) : \'\'\n\325\001\n\020sfixed64.gte_lte\032\300\001has(rule"
    "s.lte) && rules.lte >= rules.gte && (thi"
    "s > rules.lte || this < rules.gte)\? \'val"
    "ue must be greater than or equal to %s a"
    "nd less than or equal to %s\'.format([rul"
    "es.gte, rules.lte]) : \'\'\n\335\001\n\032sfixed64.gt"
    "e_lte_exclusive\032\276\001has(rules.lte) && rule"
    "s.lte < rules.gte && (rules.lte < this &"
    "& this < rules.gte)\? \'value must be grea"
    "ter than or equal to %s or less than or "
    "equal to %s\'.format([rules.gte, rules.lt"
    "e]) : \'\'H\001R\003gte\022|\n\002in\030\006 \003(\020Bl\302Hi\ng\n\013sfix"
    "ed64.in\032X!(this in dyn(rules)[\'in\']) \? \'"
    "value must be in list %s\'.format([dyn(ru"
    "les)[\'in\']]) : \'\'R\002in\022\200\001\n\006not_in\030\007 \003(\020Bi"
    "\302Hf\nd\n\017sfixed64.not_in\032Qthis in rules.no"
    "t_in \? \'value must not be in list %s\'.fo"
    "rmat([rules.not_in]) : \'\'R\005notInB\013\n\tless"
    "_thanB\016\n\014greater_thanB\010\n\006_const\"\213\001\n\tBool"
    "Rules\022t\n\005const\030\001 \001(\010BY\302HV\nT\n\nbool.const\032"
    "Fthis != rules.const \? \'value must equal"
    " %s\'.format([rules.const]) : \'\'H\000R\005const"
    "\210\001\001B\010\n\006_const\"\274\036\n\013StringRules\022x\n\005const\030\001"
    " \001(\tB]\302HZ\nX\n\014string.const\032Hthis != rules"
    ".const \? \'value must equal `%s`\'.format("
    "[rules.const]) : \'\'H\001R\005const\210\001\001\022\210\001\n\003len\030"
    "\023 \001(\004Bq\302Hn\nl\n\nstring.len\032^uint(this.size"
    "()) != rules.len \? \'value length must be"
    " %s characters\'.format([rules.len]) : \'\'"
    "H\002R\003len\210\001\001\022\246\001\n\007min_len\030\002 \001(\004B\207\001\302H\203\001\n\200\001\n\016"
    "string.min_len\032nuint(this.size()) < rule"
    "s.min_len \? \'value length must be at lea"
    "st %s characters\'.format([rules.min_len]"
    ") : \'\'H\003R\006minLen\210\001\001\022\244\001\n\007max_len\030\003 \001(\004B\205\001"
    "\302H\201\001\n\177\n\016string.max_len\032muint(this.size()"
    ") > rules.max_len \? \'value length must b"
    "e at most %s characters\'.format([rules.m"
    "ax_len]) : \'\'H\004R\006maxLen\210\001\001\022\252\001\n\tlen_bytes"
    "\030\024 \001(\004B\207\001\302H\203\001\n\200\001\n\020string.len_bytes\032luint"
    "(bytes(this).size()) != rules.len_bytes "
    "\? \'value length must be %s bytes\'.format"
    "([rules.len_bytes]) : \'\'H\005R\010lenBytes\210\001\001\022"
    "\262\001\n\tmin_bytes\030\004 \001(\004B\217\001\302H\213\001\n\210\001\n\020string.mi"
    "n_bytes\032tuint(bytes(this).size()) < rule"
    "s.min_bytes \? \'value length must be at l"
    "east %s bytes\'.format([rules.min_bytes])"
    " : \'\'H\006R\010minBytes\210\001\001\022\261\001\n\tmax_bytes\030\005 \001(\004"
    "B\216\001\302H\212\001\n\207\001\n\020string.max_bytes\032suint(bytes"
    "(this).size()) > rules.max_bytes \? \'valu"
    "e length must be at most %s bytes\'.forma"
    "t([rules.max_bytes]) : \'\'H\007R\010maxBytes\210\001\001"
    "\022\233\001\n\007pattern\030\006 \001(\tB|\302Hy\nw\n\016string.patter"
    "n\032e!this.matches(rules.pattern) \? \'value"
    " does not match regex pattern `%s`\'.form"
    "at([rules.pattern]) : \'\'H\010R\007pattern\210\001\001\022\221"
    "\001\n\006prefix\030\007 \001(\tBt\302Hq\no\n\rstring.prefix\032^!"
    "this.startsWith(rules.prefix) \? \'value d"
    "oes not have prefix `%s`\'.format([rules."
    "prefix]) : \'\'H\tR\006prefix\210\001\001\022\217\001\n\006suffix\030\010 "
    "\001(\tBr\302Ho\nm\n\rstring.suffix\032\\!this.endsWit"
    "h(rules.suffix) \? \'value does not have s"
    "uffix `%s`\'.format([rules.suffix]) : \'\'H"
    "\nR\006suffix\210\001\001\022\237\001\n\010contains\030\t \001(\tB~\302H{\ny\n\017"
    "string.contains\032f!this.contains(rules.co"
    "ntains) \? \'value does not contain substr"
    "ing `%s`\'.format([rules.contains]) : \'\'H"
    "\013R\010contains\210\001\001\022\252\001\n\014not_contains\030\027 \001(\tB\201\001"
    "\302H~\n|\n\023string.not_contains\032ethis.contain"
    "s(rules.not_contains) \? \'value contains "
    "substring `%s`\'.format([rules.not_contai"
    "ns]) : \'\'H\014R\013notContains\210\001\001\022z\n\002in\030\n \003(\tB"
    "j\302Hg\ne\n\tstring.in\032X!(this in dyn(rules)["
    "\'in\']) \? \'value must be in list %s\'.form"
    "at([dyn(rules)[\'in\']]) : \'\'R\002in\022~\n\006not_i"
    "n\030\013 \003(\tBg\302Hd\nb\n\rstring.not_in\032Qthis in r"
    "ules.not_in \? \'value must not be in list"
    " %s\'.format([rules.not_in]) : \'\'R\005notIn\022"
    "`\n\005email\030\014 \001(\010BH\302HE\nC\n\014string.email\022#val"
    "ue must be a valid email address\032\016this.i"
    "sEmail()H\000R\005email\022g\n\010hostname\030\r \001(\010BI\302HF"
    "\nD\n\017string.hostname\022\036value must be a val"
    "id hostname\032\021this.isHostname()H\000R\010hostna"
    "me\022Q\n\002ip\030\016 \001(\010B\?\302H<\n:\n\tstring.ip\022 value "
    "must be a valid IP address\032\013this.isIp()H"
    "\000R\002ip\022Z\n\004ipv4\030\017 \001(\010BD\302HA\n\?\n\013string.ipv4\022"
    "\"value must be a valid IPv4 address\032\014thi"
    "s.isIp(4)H\000R\004ipv4\022Z\n\004ipv6\030\020 \001(\010BD\302HA\n\?\n\013"
    "string.ipv6\022\"value must be a valid IPv6 "
    "address\032\014this.isIp(6)H\000R\004ipv6\022N\n\003uri\030\021 \001"
    "(\010B:\302H7\n5\n\nstring.uri\022\031value must be a v"
    "alid URI\032\014this.isUri()H\000R\003uri\022\\\n\007uri_ref"
    "\030\022 \001(\010BA\302H>\n<\n\016string.uri_ref\022\031value mus"
    "t be a valid URI\032\017this.isUriRef()H\000R\006uri"
    "Ref\022\202\001\n\007address\030\025 \001(\010Bf\302Hc\na\n\016string.add"
    "ress\022-value must be a valid hostname, or"
    " ip address\032 this.isHostname() || this.i"
    "sIp()H\000R\007address\022\260\001\n\004uuid\030\026 \001(\010B\231\001\302H\225\001\n\222"
    "\001\n\013string.uuid\032\202\001!this.matches(\'^[0-9a-f"
    "A-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0"
    "-9a-fA-F]{4}-[0-9a-fA-F]{12}$\') \? \'value"
    " must be a valid UUID\' : \'\'H\000R\004uuid\022\254\004\n\020"
    "well_known_regex\030\030 \001(\0162\030.buf.validate.Kn"
    "ownRegexB\345\003\302H\341\003\n\353\001\n#string.well_known_re"
    "gex.header_name\032\303\001rules.well_known_regex"
    " == 1 && !this.matches(!has(rules.strict"
    ") || rules.strict \?\'^:\?[0-9a-zA-Z!#$%&\\\'"
    "*+-.^_|~\\x60]+$\' :\'^[^\\u0000\\u000A\\u000D"
    "]+$\') \? \'value must be a valid HTTP head"
    "er name\' : \'\'\n\360\001\n$string.well_known_rege"
    "x.header_value\032\307\001rules.well_known_regex "
    "== 2 && !this.matches(!has(rules.strict)"
    " || rules.strict \?\'^[^\\u0000-\\u0008\\u000"
    "A-\\u001F\\u007F]*$\' :\'^[^\\u0000\\u000A\\u00"
    "0D]*$\') \? \'value must be a valid HTTP he"
    "ader value\' : \'\'H\000R\016wellKnownRegex\022\033\n\006st"
    "rict\030\031 \001(\010H\rR\006strict\210\001\001B\014\n\nwell_knownB\010\n"
    "\006_constB\006\n\004_lenB\n\n\010_min_lenB\n\n\010_max_lenB"
    "\014\n\n_len_bytesB\014\n\n_min_bytesB\014\n\n_max_byte"
    "sB\n\n\010_patternB\t\n\007_prefixB\t\n\007_suffixB\013\n\t_"
    "containsB\017\n\r_not_containsB\t\n\007_strict\"\332\016\n"
    "\nBytesRules\022r\n\005const\030\001 \001(\014BW\302HT\nR\n\013bytes"
    ".const\032Cthis != rules.const \? \'value mus"
    "t be %x\'.format([rules.const]) : \'\'H\001R\005c"
    "onst\210\001\001\022\202\001\n\003len\030\r \001(\004Bk\302Hh\nf\n\tbytes.len\032"
    "Yuint(this.size()) != rules.len \? \'value"
    " length must be %s bytes\'.format([rules."
    "len]) : \'\'H\002R\003len\210\001\001\022\235\001\n\007min_len\030\002 \001(\004B\177"
    "\302H|\nz\n\rbytes.min_len\032iuint(this.size()) "
    "< rules.min_len \? \'value length must be "
    "at least %s bytes\'.format([rules.min_len"
    "]) : \'\'H\003R\006minLen\210\001\001\022\225\001\n\007max_len\030\003 \001(\004Bw"
    "\302Ht\nr\n\rbytes.max_len\032auint(this.size()) "
    "> rules.max_len \? \'value must be at most"
    " %s bytes\'.format([rules.max_len]) : \'\'H"
    "\004R\006maxLen\210\001\001\022\236\001\n\007pattern\030\004 \001(\tB\177\302H|\nz\n\rb"
    "ytes.pattern\032i!string(this).matches(rule"
    "s.pattern) \? \'value must match regex pat"
    "tern `%s`\'.format([rules.pattern]) : \'\'H"
    "\005R\007pattern\210\001\001\022\216\001\n\006prefix\030\005 \001(\014Bq\302Hn\nl\n\014b"
    "ytes.prefix\032\\!this.startsWith(rules.pref"
    "ix) \? \'value does not have prefix %x\'.fo"
    "rmat([rules.prefix]) : \'\'H\006R\006prefix\210\001\001\022\214"
    "\001\n\006suffix\030\006 \001(\014Bo\302Hl\nj\n\014bytes.suffix\032Z!t"
    "his.endsWith(rules.suffix) \? \'value does"
    " not have suffix %x\'.format([rules.suffi"
    "x]) : \'\'H\007R\006suffix\210\001\001\022\222\001\n\010contains\030\007 \001(\014"
    "Bq\302Hn\nl\n\016bytes.contains\032Z!this.contains("
    "rules.contains) \? \'value does not contai"
    "n %x\'.format([rules.contains]) : \'\'H\010R\010c"
    "ontains\210\001\001\022\233\001\n\002in\030\010 \003(\014B\212\001\302H\206\001\n\203\001\n\010bytes"
    ".in\032wdyn(rules)[\'in\'].size() > 0 && !(th"
    "is in dyn(rules)[\'in\']) \? \'value must be"
    " in list %s\'.format([dyn(rules)[\'in\']]) "
    ": \'\'R\002in\022}\n\006not_in\030\t \003(\014Bf\302Hc\na\n\014bytes.n"
    "ot_in\032Qthis in rules.not_in \? \'value mus"
    "t not be in list %s\'.format([rules.not_i"
    "n]) : \'\'R\005notIn\022r\n\002ip\030\n \001(\010B`\302H]\n[\n\010byte"
    "s.ip\032Othis.size() != 4 && this.size() !="
    " 16 \? \'value must be a valid IP address\'"
    " : \'\'H\000R\002ip\022e\n\004ipv4\030\013 \001(\010BO\302HL\nJ\n\nbytes."
    "ipv4\032<this.size() != 4 \? \'value must be "
    "a valid IPv4 address\' : \'\'H\000R\004ipv4\022f\n\004ip"
    "v6\030\014 \001(\010BP\302HM\nK\n\nbytes.ipv6\032=this.size()"
    " != 16 \? \'value must be a valid IPv6 add"
    "ress\' : \'\'H\000R\004ipv6B\014\n\nwell_knownB\010\n\006_con"
    "stB\006\n\004_lenB\n\n\010_min_lenB\n\n\010_max_lenB\n\n\010_p"
    "atternB\t\n\007_prefixB\t\n\007_suffixB\013\n\t_contain"
    "s\"\274\003\n\tEnumRules\022t\n\005const\030\001 \001(\005BY\302HV\nT\n\ne"
    "num.const\032Fthis != rules.const \? \'value "
    "must equal %s\'.format([rules.const]) : \'"
    "\'H\000R\005const\210\001\001\022&\n\014defined_only\030\002 \001(\010H\001R\013d"
    "efinedOnly\210\001\001\022x\n\002in\030\003 \003(\005Bh\302He\nc\n\007enum.i"
    "n\032X!(this in dyn(rules)[\'in\']) \? \'value "
    "must be in list %s\'.format([dyn(rules)[\'"
    "in\']]) : \'\'R\002in\022|\n\006not_in\030\004 \003(\005Be\302Hb\n`\n\013"
    "enum.not_in\032Qthis in rules.not_in \? \'val"
    "ue must not be in list %s\'.format([rules"
    ".not_in]) : \'\'R\005notInB\010\n\006_constB\017\n\r_defi"
    "ned_only\"\315\004\n\rRepeatedRules\022\255\001\n\tmin_items"
    "\030\001 \001(\004B\212\001\302H\206\001\n\203\001\n\022repeated.min_items\032mui"
    "nt(this.size()) < rules.min_items \? \'val"
    "ue must contain at least %d item(s)\'.for"
    "mat([rules.min_items]) : \'\'H\000R\010minItems\210"
    "\001\001\022\261\001\n\tmax_items\030\002 \001(\004B\216\001\302H\212\001\n\207\001\n\022repeat"
    "ed.max_items\032quint(this.size()) > rules."
    "max_items \? \'value must contain no more "
    "than %s item(s)\'.format([rules.max_items"
    "]) : \'\'H\001R\010maxItems\210\001\001\022l\n\006unique\030\003 \001(\010BO"
    "\302HL\nJ\n\017repeated.unique\022(repeated value m"
    "ust contain unique items\032\rthis.unique()H"
    "\002R\006unique\210\001\001\0229\n\005items\030\004 \001(\0132\036.buf.valida"
    "te.FieldConstraintsH\003R\005items\210\001\001B\014\n\n_min_"
    "itemsB\014\n\n_max_itemsB\t\n\007_uniqueB\010\n\006_items"
    "\"\361\003\n\010MapRules\022\236\001\n\tmin_pairs\030\001 \001(\004B|\302Hy\nw"
    "\n\rmap.min_pairs\032fuint(this.size()) < rul"
    "es.min_pairs \? \'map must be at least %d "
    "entries\'.format([rules.min_pairs]) : \'\'H"
    "\000R\010minPairs\210\001\001\022\235\001\n\tmax_pairs\030\002 \001(\004B{\302Hx\n"
    "v\n\rmap.max_pairs\032euint(this.size()) > ru"
    "les.max_pairs \? \'map must be at most %d "
    "entries\'.format([rules.max_pairs]) : \'\'H"
    "\001R\010maxPairs\210\001\001\0227\n\004keys\030\004 \001(\0132\036.buf.valid"
    "ate.FieldConstraintsH\002R\004keys\210\001\001\022;\n\006value"
    "s\030\005 \001(\0132\036.buf.validate.FieldConstraintsH"
    "\003R\006values\210\001\001B\014\n\n_min_pairsB\014\n\n_max_pairs"
    "B\007\n\005_keysB\t\n\007_values\"1\n\010AnyRules\022\016\n\002in\030\002"
    " \003(\tR\002in\022\025\n\006not_in\030\003 \003(\tR\005notIn\"\322\026\n\rDura"
    "tionRules\022\223\001\n\005const\030\002 \001(\0132\031.google.proto"
    "buf.DurationB]\302HZ\nX\n\016duration.const\032Fthi"
    "s != rules.const \? \'value must equal %s\'"
    ".format([rules.const]) : \'\'H\002R\005const\210\001\001\022"
    "\254\001\n\002lt\030\003 \001(\0132\031.google.protobuf.DurationB"
    "\177\302H|\nz\n\013duration.lt\032k!has(rules.gte) && "
    "!has(rules.gt) && this >= rules.lt\? \'val"
    "ue must be less than %s\'.format([rules.l"
    "t]) : \'\'H\000R\002lt\022\277\001\n\003lte\030\004 \001(\0132\031.google.pr"
    "otobuf.DurationB\217\001\302H\213\001\n\210\001\n\014duration.lte\032"
    "x!has(rules.gte) && !has(rules.gt) && th"
    "is > rules.lte\? \'value must be less than"
    " or equal to %s\'.format([rules.lte]) : \'"
    "\'H\000R\003lte\022\305\007\n\002gt\030\005 \001(\0132\031.google.protobuf."
    "DurationB\227\007\302H\223\007\n}\n\013duration.gt\032n!has(rul"
    "es.lt) && !has(rules.lte) && this <= rul"
    "es.gt\? \'value must be greater than %s\'.f"
    "ormat([rules.gt]) : \'\'\n\266\001\n\016duration.gt_l"
    "t\032\243\001has(rules.lt) && rules.lt >= rules.g"
    "t && (this >= rules.lt || this <= rules."
    "gt)\? \'value must be greater than %s and "
    "less than %s\'.format([rules.gt, rules.lt"
    "]) : \'\'\n\276\001\n\030duration.gt_lt_exclusive\032\241\001h"
    "as(rules.lt) && rules.lt < rules.gt && ("
    "rules.lt <= this && this <= rules.gt)\? \'"
    "value must be greater than %s or less th"
    "an %s\'.format([rules.gt, rules.lt]) : \'\'"
    "\n\306\001\n\017duration.gt_lte\032\262\001has(rules.lte) &&"
    " rules.lte >= rules.gt && (this > rules."
    "lte || this <= rules.gt)\? \'value must be"
    " greater than %s and less than or equal "
    "to %s\'.format([rules.gt, rules.lte]) : \'"
    "\'\n\316\001\n\031duration.gt_lte_exclusive\032\260\001has(ru"
    "les.lte) && rules.lte < rules.gt && (rul"
    "es.lte < this && this <= rules.gt)\? \'val"
    "ue must be greater than %s or less than "
    "or equal to %s\'.format([rules.gt, rules."
    "lte]) : \'\'H\001R\002gt\022\222\010\n\003gte\030\006 \001(\0132\031.google."
    "protobuf.DurationB\342\007\302H\336\007\n\213\001\n\014duration.gt"
    "e\032{!has(rules.lt) && !has(rules.lte) && "
    "this < rules.gte\? \'value must be greater"
    " than or equal to %s\'.format([rules.gte]"
    ") : \'\'\n\305\001\n\017duration.gte_lt\032\261\001has(rules.l"
    "t) && rules.lt >= rules.gte && (this >= "
    "rules.lt || this < rules.gte)\? \'value mu"
    "st be greater than or equal to %s and le"
    "ss than %s\'.format([rules.gte, rules.lt]"
    ") : \'\'\n\315\001\n\031duration.gte_lt_exclusive\032\257\001h"
    "as(rules.lt) && rules.lt < rules.gte && "
    "(rules.lt <= this && this < rules.gte)\? "
    "\'value must be greater than or equal to "
    "%s or less than %s\'.format([rules.gte, r"
    "ules.lt]) : \'\'\n\325\001\n\020duration.gte_lte\032\300\001ha"
    "s(rules.lte) && rules.lte >= rules.gte &"
    "& (this > rules.lte || this < rules.gte)"
    "\? \'value must be greater than or equal t"
    "o %s and less than or equal to %s\'.forma"
    "t([rules.gte, rules.lte]) : \'\'\n\335\001\n\032durat"
    "ion.gte_lte_exclusive\032\276\001has(rules.lte) &"
    "& rules.lte < rules.gte && (rules.lte < "
    "this && this < rules.gte)\? \'value must b"
    "e greater than or equal to %s or less th"
    "an or equal to %s\'.format([rules.gte, ru"
    "les.lte]) : \'\'H\001R\003gte\022\227\001\n\002in\030\007 \003(\0132\031.goo"
    "gle.protobuf.DurationBl\302Hi\ng\n\013duration.i"
    "n\032X!(this in dyn(rules)[\'in\']) \? \'value "
    "must be in list %s\'.format([dyn(rules)[\'"
    "in\']]) : \'\'R\002in\022\233\001\n\006not_in\030\010 \003(\0132\031.googl"
    "e.protobuf.DurationBi\302Hf\nd\n\017duration.not"
    "_in\032Qthis in rules.not_in \? \'value must "
    "not be in list %s\'.format([rules.not_in]"
    ") : \'\'R\005notInB\013\n\tless_thanB\016\n\014greater_th"
    "anB\010\n\006_const\"\312\027\n\016TimestampRules\022\225\001\n\005cons"
    "t\030\002 \001(\0132\032.google.protobuf.TimestampB^\302H["
    "\nY\n\017timestamp.const\032Fthis != rules.const"
    " \? \'value must equal %s\'.format([rules.c"
    "onst]) : \'\'H\002R\005const\210\001\001\022\257\001\n\002lt\030\003 \001(\0132\032.g"
    "oogle.protobuf.TimestampB\200\001\302H}\n{\n\014timest"
    "amp.lt\032k!has(rules.gte) && !has(rules.gt"
    ") && this >= rules.lt\? \'value must be le"
    "ss than %s\'.format([rules.lt]) : \'\'H\000R\002l"
    "t\022\301\001\n\003lte\030\004 \001(\0132\032.google.protobuf.Timest"
    "ampB\220\001\302H\214\001\n\211\001\n\rtimestamp.lte\032x!has(rules"
    ".gte) && !has(rules.gt) && this > rules."
    "lte\? \'value must be less than or equal t"
    "o %s\'.format([rules.lte]) : \'\'H\000R\003lte\022a\n"
    "\006lt_now\030\007 \001(\010BH\302HE\nC\n\020timestamp.lt_now\032/"
    "this > now \? \'value must be less than no"
    "w\' : \'\'H\000R\005ltNow\022\313\007\n\002gt\030\005 \001(\0132\032.google.p"
    "rotobuf.TimestampB\234\007\302H\230\007\n~\n\014timestamp.gt"
    "\032n!has(rules.lt) && !has(rules.lte) && t"
    "his <= rules.gt\? \'value must be greater "
    "than %s\'.format([rules.gt]) : \'\'\n\267\001\n\017tim"
    "estamp.gt_lt\032\243\001has(rules.lt) && rules.lt"
    " >= rules.gt && (this >= rules.lt || thi"
    "s <= rules.gt)\? \'value must be greater t"
    "han %s and less than %s\'.format([rules.g"
    "t, rules.lt]) : \'\'\n\277\001\n\031timestamp.gt_lt_e"
    "xclusive\032\241\001has(rules.lt) && rules.lt < r"
    "ules.gt && (rules.lt <= this && this <= "
    "rules.gt)\? \'value must be greater than %"
    "s or less than %s\'.format([rules.gt, rul"
    "es.lt]) : \'\'\n\307\001\n\020timestamp.gt_lte\032\262\001has("
    "rules.lte) && rules.lte >= rules.gt && ("
    "this > rules.lte || this <= rules.gt)\? \'"
    "value must be greater than %s and less t"
    "han or equal to %s\'.format([rules.gt, ru"
    "les.lte]) : \'\'\n\317\001\n\032timestamp.gt_lte_excl"
    "usive\032\260\001has(rules.lte) && rules.lte < ru"
    "les.gt && (rules.lte < this && this <= r"
    "ules.gt)\? \'value must be greater than %s"
    " or less than or equal to %s\'.format([ru"
    "les.gt, rules.lte]) : \'\'H\001R\002gt\022\230\010\n\003gte\030\006"
    " \001(\0132\032.google.protobuf.TimestampB\347\007\302H\343\007\n"
    "\214\001\n\rtimestamp.gte\032{!has(rules.lt) && !ha"
    "s(rules.lte) && this < rules.gte\? \'value"
    " must be greater than or equal to %s\'.fo"
    "rmat([rules.gte]) : \'\'\n\306\001\n\020timestamp.gte"
    "_lt\032\261\001has(rules.lt) && rules.lt >= rules"
    ".gte && (this >= rules.lt || this < rule"
    "s.gte)\? \'value must be greater than or e"
    "qual to %s and less than %s\'.format([rul"
    "es.gte, rules.lt]) : \'\'\n\316\001\n\032timestamp.gt"
    "e_lt_exclusive\032\257\001has(rules.lt) && rules."
    "lt < rules.gte && (rules.lt <= this && t"
    "his < rules.gte)\? \'value must be greater"
    " than or equal to %s or less than %s\'.fo"
    "rmat([rules.gte, rules.lt]) : \'\'\n\326\001\n\021tim"
    "estamp.gte_lte\032\300\001has(rules.lte) && rules"
    ".lte >= rules.gte && (this > rules.lte |"
    "| this < rules.gte)\? \'value must be grea"
    "ter than or equal to %s and less than or"
    " equal to %s\'.format([rules.gte, rules.l"
    "te]) : \'\'\n\336\001\n\033timestamp.gte_lte_exclusiv"
    "e\032\276\001has(rules.lte) && rules.lte < rules."
    "gte && (rules.lte < this && this < rules"
    ".gte)\? \'value must be greater than or eq"
    "ual to %s or less than or equal to %s\'.f"
    "ormat([rules.gte, rules.lte]) : \'\'H\001R\003gt"
    "e\022d\n\006gt_now\030\010 \001(\010BK\302HH\nF\n\020timestamp.gt_n"
    "ow\0322this < now \? \'value must be greater "
    "than now\' : \'\'H\001R\005gtNow\022\305\001\n\006within\030\t \001(\013"
    "2\031.google.protobuf.DurationB\214\001\302H\210\001\n\205\001\n\020t"
    "imestamp.within\032qthis < now-rules.within"
    " || this > now+rules.within \? \'value mus"
    "t be within %s of now\'.format([rules.wit"
    "hin]) : \'\'H\003R\006within\210\001\001B\013\n\tless_thanB\016\n\014"
    "greater_thanB\010\n\006_constB\t\n\007_within*n\n\nKno"
    "wnRegex\022\033\n\027KNOWN_REGEX_UNSPECIFIED\020\000\022 \n\034"
    "KNOWN_REGEX_HTTP_HEADER_NAME\020\001\022!\n\035KNOWN_"
    "REGEX_HTTP_HEADER_VALUE\020\002:_\n\007message\022\037.g"
    "oogle.protobuf.MessageOptions\030\207\t \001(\0132 .b"
    "uf.validate.MessageConstraintsR\007message\210"
    "\001\001:W\n\005oneof\022\035.google.protobuf.OneofOptio"
    "ns\030\207\t \001(\0132\036.buf.validate.OneofConstraint"
    "sR\005oneof\210\001\001:W\n\005field\022\035.google.protobuf.F"
    "ieldOptions\030\207\t \001(\0132\036.buf.validate.FieldC"
    "onstraintsR\005field\210\001\001B\273\001\n\020com.buf.validat"
    "eB\rValidateProtoP\001ZGbuf.build/gen/go/buf"
    "build/protovalidate/protocolbuffers/go/b"
    "uf/validate\242\002\003BVX\252\002\014Buf.Validate\312\002\014Buf\\V"
    "alidate\342\002\030Buf\\Validate\\GPBMetadata\352\002\rBuf"
    "::Validateb\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_buf_2fvalidate_2fvalidate_2eproto_deps[5] =
    {
        &::descriptor_table_buf_2fvalidate_2fexpression_2eproto,
        &::descriptor_table_buf_2fvalidate_2fpriv_2fprivate_2eproto,
        &::descriptor_table_google_2fprotobuf_2fdescriptor_2eproto,
        &::descriptor_table_google_2fprotobuf_2fduration_2eproto,
        &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
};
static ::absl::once_flag descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_buf_2fvalidate_2fvalidate_2eproto = {
    false,
    false,
    48498,
    descriptor_table_protodef_buf_2fvalidate_2fvalidate_2eproto,
    "buf/validate/validate.proto",
    &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
    descriptor_table_buf_2fvalidate_2fvalidate_2eproto_deps,
    5,
    24,
    schemas,
    file_default_instances,
    TableStruct_buf_2fvalidate_2fvalidate_2eproto::offsets,
    file_level_metadata_buf_2fvalidate_2fvalidate_2eproto,
    file_level_enum_descriptors_buf_2fvalidate_2fvalidate_2eproto,
    file_level_service_descriptors_buf_2fvalidate_2fvalidate_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter() {
  return &descriptor_table_buf_2fvalidate_2fvalidate_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_buf_2fvalidate_2fvalidate_2eproto(&descriptor_table_buf_2fvalidate_2fvalidate_2eproto);
namespace buf {
namespace validate {
const ::google::protobuf::EnumDescriptor* KnownRegex_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_buf_2fvalidate_2fvalidate_2eproto);
  return file_level_enum_descriptors_buf_2fvalidate_2fvalidate_2eproto[0];
}
bool KnownRegex_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class MessageConstraints::_Internal {
 public:
  using HasBits = decltype(std::declval<MessageConstraints>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MessageConstraints, _impl_._has_bits_);
  static void set_has_disabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void MessageConstraints::clear_cel() {
  _internal_mutable_cel()->Clear();
}
MessageConstraints::MessageConstraints(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.MessageConstraints)
}
MessageConstraints::MessageConstraints(const MessageConstraints& from) : ::google::protobuf::Message() {
  MessageConstraints* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.cel_){from._impl_.cel_},
      decltype(_impl_.disabled_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.disabled_ = from._impl_.disabled_;

  // @@protoc_insertion_point(copy_constructor:buf.validate.MessageConstraints)
}
inline void MessageConstraints::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.cel_){arena},
      decltype(_impl_.disabled_){false},
  };
}
MessageConstraints::~MessageConstraints() {
  // @@protoc_insertion_point(destructor:buf.validate.MessageConstraints)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void MessageConstraints::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cel_.~RepeatedPtrField();
}
void MessageConstraints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void MessageConstraints::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.MessageConstraints)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_cel()->Clear();
  _impl_.disabled_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* MessageConstraints::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 2, 1, 0, 2> MessageConstraints::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MessageConstraints, _impl_._has_bits_),
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967290,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_MessageConstraints_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool disabled = 1 [json_name = "disabled"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(MessageConstraints, _impl_.disabled_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(MessageConstraints, _impl_.disabled_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated .buf.validate.Constraint cel = 3 [json_name = "cel"];
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(MessageConstraints, _impl_.cel_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool disabled = 1 [json_name = "disabled"];
    {PROTOBUF_FIELD_OFFSET(MessageConstraints, _impl_.disabled_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated .buf.validate.Constraint cel = 3 [json_name = "cel"];
    {PROTOBUF_FIELD_OFFSET(MessageConstraints, _impl_.cel_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::buf::validate::Constraint>()},
  }}, {{
  }},
};

::uint8_t* MessageConstraints::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.MessageConstraints)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool disabled = 1 [json_name = "disabled"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_disabled(), target);
  }

  // repeated .buf.validate.Constraint cel = 3 [json_name = "cel"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cel_size()); i < n; i++) {
    const auto& repfield = this->_internal_cel().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.MessageConstraints)
  return target;
}

::size_t MessageConstraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.MessageConstraints)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .buf.validate.Constraint cel = 3 [json_name = "cel"];
  total_size += 1UL * this->_internal_cel_size();
  for (const auto& msg : this->_internal_cel()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // optional bool disabled = 1 [json_name = "disabled"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData MessageConstraints::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    MessageConstraints::MergeImpl
};
const ::google::protobuf::Message::ClassData*MessageConstraints::GetClassData() const { return &_class_data_; }


void MessageConstraints::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<MessageConstraints*>(&to_msg);
  auto& from = static_cast<const MessageConstraints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.MessageConstraints)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_cel()->MergeFrom(from._internal_cel());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_disabled(from._internal_disabled());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MessageConstraints::CopyFrom(const MessageConstraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.MessageConstraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool MessageConstraints::IsInitialized() const {
  return true;
}

void MessageConstraints::InternalSwap(MessageConstraints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.cel_.InternalSwap(&other->_impl_.cel_);
        swap(_impl_.disabled_, other->_impl_.disabled_);
}

::google::protobuf::Metadata MessageConstraints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[0]);
}
// ===================================================================

class OneofConstraints::_Internal {
 public:
  using HasBits = decltype(std::declval<OneofConstraints>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(OneofConstraints, _impl_._has_bits_);
  static void set_has_required(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OneofConstraints::OneofConstraints(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.OneofConstraints)
}
OneofConstraints::OneofConstraints(const OneofConstraints& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:buf.validate.OneofConstraints)
}
inline void OneofConstraints::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.required_){false},
  };
}
OneofConstraints::~OneofConstraints() {
  // @@protoc_insertion_point(destructor:buf.validate.OneofConstraints)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void OneofConstraints::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void OneofConstraints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void OneofConstraints::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.OneofConstraints)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.required_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* OneofConstraints::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> OneofConstraints::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(OneofConstraints, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_OneofConstraints_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional bool required = 1 [json_name = "required"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(OneofConstraints, _impl_.required_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(OneofConstraints, _impl_.required_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool required = 1 [json_name = "required"];
    {PROTOBUF_FIELD_OFFSET(OneofConstraints, _impl_.required_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* OneofConstraints::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.OneofConstraints)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool required = 1 [json_name = "required"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_required(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.OneofConstraints)
  return target;
}

::size_t OneofConstraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.OneofConstraints)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool required = 1 [json_name = "required"];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData OneofConstraints::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    OneofConstraints::MergeImpl
};
const ::google::protobuf::Message::ClassData*OneofConstraints::GetClassData() const { return &_class_data_; }


void OneofConstraints::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<OneofConstraints*>(&to_msg);
  auto& from = static_cast<const OneofConstraints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.OneofConstraints)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_required(from._internal_required());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void OneofConstraints::CopyFrom(const OneofConstraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.OneofConstraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool OneofConstraints::IsInitialized() const {
  return true;
}

void OneofConstraints::InternalSwap(OneofConstraints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
        swap(_impl_.required_, other->_impl_.required_);
}

::google::protobuf::Metadata OneofConstraints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[1]);
}
// ===================================================================

class FieldConstraints::_Internal {
 public:
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::FieldConstraints, _impl_._oneof_case_);
  static const ::buf::validate::FloatRules& float_(const FieldConstraints* msg);
  static const ::buf::validate::DoubleRules& double_(const FieldConstraints* msg);
  static const ::buf::validate::Int32Rules& int32(const FieldConstraints* msg);
  static const ::buf::validate::Int64Rules& int64(const FieldConstraints* msg);
  static const ::buf::validate::UInt32Rules& uint32(const FieldConstraints* msg);
  static const ::buf::validate::UInt64Rules& uint64(const FieldConstraints* msg);
  static const ::buf::validate::SInt32Rules& sint32(const FieldConstraints* msg);
  static const ::buf::validate::SInt64Rules& sint64(const FieldConstraints* msg);
  static const ::buf::validate::Fixed32Rules& fixed32(const FieldConstraints* msg);
  static const ::buf::validate::Fixed64Rules& fixed64(const FieldConstraints* msg);
  static const ::buf::validate::SFixed32Rules& sfixed32(const FieldConstraints* msg);
  static const ::buf::validate::SFixed64Rules& sfixed64(const FieldConstraints* msg);
  static const ::buf::validate::BoolRules& bool_(const FieldConstraints* msg);
  static const ::buf::validate::StringRules& string(const FieldConstraints* msg);
  static const ::buf::validate::BytesRules& bytes(const FieldConstraints* msg);
  static const ::buf::validate::EnumRules& enum_(const FieldConstraints* msg);
  static const ::buf::validate::RepeatedRules& repeated(const FieldConstraints* msg);
  static const ::buf::validate::MapRules& map(const FieldConstraints* msg);
  static const ::buf::validate::AnyRules& any(const FieldConstraints* msg);
  static const ::buf::validate::DurationRules& duration(const FieldConstraints* msg);
  static const ::buf::validate::TimestampRules& timestamp(const FieldConstraints* msg);
};

const ::buf::validate::FloatRules& FieldConstraints::_Internal::float_(const FieldConstraints* msg) {
  return *msg->_impl_.type_.float__;
}
const ::buf::validate::DoubleRules& FieldConstraints::_Internal::double_(const FieldConstraints* msg) {
  return *msg->_impl_.type_.double__;
}
const ::buf::validate::Int32Rules& FieldConstraints::_Internal::int32(const FieldConstraints* msg) {
  return *msg->_impl_.type_.int32_;
}
const ::buf::validate::Int64Rules& FieldConstraints::_Internal::int64(const FieldConstraints* msg) {
  return *msg->_impl_.type_.int64_;
}
const ::buf::validate::UInt32Rules& FieldConstraints::_Internal::uint32(const FieldConstraints* msg) {
  return *msg->_impl_.type_.uint32_;
}
const ::buf::validate::UInt64Rules& FieldConstraints::_Internal::uint64(const FieldConstraints* msg) {
  return *msg->_impl_.type_.uint64_;
}
const ::buf::validate::SInt32Rules& FieldConstraints::_Internal::sint32(const FieldConstraints* msg) {
  return *msg->_impl_.type_.sint32_;
}
const ::buf::validate::SInt64Rules& FieldConstraints::_Internal::sint64(const FieldConstraints* msg) {
  return *msg->_impl_.type_.sint64_;
}
const ::buf::validate::Fixed32Rules& FieldConstraints::_Internal::fixed32(const FieldConstraints* msg) {
  return *msg->_impl_.type_.fixed32_;
}
const ::buf::validate::Fixed64Rules& FieldConstraints::_Internal::fixed64(const FieldConstraints* msg) {
  return *msg->_impl_.type_.fixed64_;
}
const ::buf::validate::SFixed32Rules& FieldConstraints::_Internal::sfixed32(const FieldConstraints* msg) {
  return *msg->_impl_.type_.sfixed32_;
}
const ::buf::validate::SFixed64Rules& FieldConstraints::_Internal::sfixed64(const FieldConstraints* msg) {
  return *msg->_impl_.type_.sfixed64_;
}
const ::buf::validate::BoolRules& FieldConstraints::_Internal::bool_(const FieldConstraints* msg) {
  return *msg->_impl_.type_.bool__;
}
const ::buf::validate::StringRules& FieldConstraints::_Internal::string(const FieldConstraints* msg) {
  return *msg->_impl_.type_.string_;
}
const ::buf::validate::BytesRules& FieldConstraints::_Internal::bytes(const FieldConstraints* msg) {
  return *msg->_impl_.type_.bytes_;
}
const ::buf::validate::EnumRules& FieldConstraints::_Internal::enum_(const FieldConstraints* msg) {
  return *msg->_impl_.type_.enum__;
}
const ::buf::validate::RepeatedRules& FieldConstraints::_Internal::repeated(const FieldConstraints* msg) {
  return *msg->_impl_.type_.repeated_;
}
const ::buf::validate::MapRules& FieldConstraints::_Internal::map(const FieldConstraints* msg) {
  return *msg->_impl_.type_.map_;
}
const ::buf::validate::AnyRules& FieldConstraints::_Internal::any(const FieldConstraints* msg) {
  return *msg->_impl_.type_.any_;
}
const ::buf::validate::DurationRules& FieldConstraints::_Internal::duration(const FieldConstraints* msg) {
  return *msg->_impl_.type_.duration_;
}
const ::buf::validate::TimestampRules& FieldConstraints::_Internal::timestamp(const FieldConstraints* msg) {
  return *msg->_impl_.type_.timestamp_;
}
void FieldConstraints::clear_cel() {
  _internal_mutable_cel()->Clear();
}
void FieldConstraints::set_allocated_float_(::buf::validate::FloatRules* float_) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (float_) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(float_);
    if (message_arena != submessage_arena) {
      float_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, float_, submessage_arena);
    }
    set_has_float_();
    _impl_.type_.float__ = float_;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.float)
}
void FieldConstraints::set_allocated_double_(::buf::validate::DoubleRules* double_) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (double_) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(double_);
    if (message_arena != submessage_arena) {
      double_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, double_, submessage_arena);
    }
    set_has_double_();
    _impl_.type_.double__ = double_;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.double)
}
void FieldConstraints::set_allocated_int32(::buf::validate::Int32Rules* int32) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (int32) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(int32);
    if (message_arena != submessage_arena) {
      int32 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, int32, submessage_arena);
    }
    set_has_int32();
    _impl_.type_.int32_ = int32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.int32)
}
void FieldConstraints::set_allocated_int64(::buf::validate::Int64Rules* int64) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (int64) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(int64);
    if (message_arena != submessage_arena) {
      int64 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, int64, submessage_arena);
    }
    set_has_int64();
    _impl_.type_.int64_ = int64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.int64)
}
void FieldConstraints::set_allocated_uint32(::buf::validate::UInt32Rules* uint32) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (uint32) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(uint32);
    if (message_arena != submessage_arena) {
      uint32 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uint32, submessage_arena);
    }
    set_has_uint32();
    _impl_.type_.uint32_ = uint32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.uint32)
}
void FieldConstraints::set_allocated_uint64(::buf::validate::UInt64Rules* uint64) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (uint64) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(uint64);
    if (message_arena != submessage_arena) {
      uint64 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uint64, submessage_arena);
    }
    set_has_uint64();
    _impl_.type_.uint64_ = uint64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.uint64)
}
void FieldConstraints::set_allocated_sint32(::buf::validate::SInt32Rules* sint32) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (sint32) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(sint32);
    if (message_arena != submessage_arena) {
      sint32 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sint32, submessage_arena);
    }
    set_has_sint32();
    _impl_.type_.sint32_ = sint32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.sint32)
}
void FieldConstraints::set_allocated_sint64(::buf::validate::SInt64Rules* sint64) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (sint64) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(sint64);
    if (message_arena != submessage_arena) {
      sint64 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sint64, submessage_arena);
    }
    set_has_sint64();
    _impl_.type_.sint64_ = sint64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.sint64)
}
void FieldConstraints::set_allocated_fixed32(::buf::validate::Fixed32Rules* fixed32) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (fixed32) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(fixed32);
    if (message_arena != submessage_arena) {
      fixed32 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fixed32, submessage_arena);
    }
    set_has_fixed32();
    _impl_.type_.fixed32_ = fixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.fixed32)
}
void FieldConstraints::set_allocated_fixed64(::buf::validate::Fixed64Rules* fixed64) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (fixed64) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(fixed64);
    if (message_arena != submessage_arena) {
      fixed64 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fixed64, submessage_arena);
    }
    set_has_fixed64();
    _impl_.type_.fixed64_ = fixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.fixed64)
}
void FieldConstraints::set_allocated_sfixed32(::buf::validate::SFixed32Rules* sfixed32) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (sfixed32) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(sfixed32);
    if (message_arena != submessage_arena) {
      sfixed32 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sfixed32, submessage_arena);
    }
    set_has_sfixed32();
    _impl_.type_.sfixed32_ = sfixed32;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.sfixed32)
}
void FieldConstraints::set_allocated_sfixed64(::buf::validate::SFixed64Rules* sfixed64) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (sfixed64) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(sfixed64);
    if (message_arena != submessage_arena) {
      sfixed64 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sfixed64, submessage_arena);
    }
    set_has_sfixed64();
    _impl_.type_.sfixed64_ = sfixed64;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.sfixed64)
}
void FieldConstraints::set_allocated_bool_(::buf::validate::BoolRules* bool_) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (bool_) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(bool_);
    if (message_arena != submessage_arena) {
      bool_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bool_, submessage_arena);
    }
    set_has_bool_();
    _impl_.type_.bool__ = bool_;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.bool)
}
void FieldConstraints::set_allocated_string(::buf::validate::StringRules* string) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (string) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(string);
    if (message_arena != submessage_arena) {
      string = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, string, submessage_arena);
    }
    set_has_string();
    _impl_.type_.string_ = string;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.string)
}
void FieldConstraints::set_allocated_bytes(::buf::validate::BytesRules* bytes) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (bytes) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(bytes);
    if (message_arena != submessage_arena) {
      bytes = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bytes, submessage_arena);
    }
    set_has_bytes();
    _impl_.type_.bytes_ = bytes;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.bytes)
}
void FieldConstraints::set_allocated_enum_(::buf::validate::EnumRules* enum_) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (enum_) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(enum_);
    if (message_arena != submessage_arena) {
      enum_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, enum_, submessage_arena);
    }
    set_has_enum_();
    _impl_.type_.enum__ = enum_;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.enum)
}
void FieldConstraints::set_allocated_repeated(::buf::validate::RepeatedRules* repeated) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (repeated) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(repeated);
    if (message_arena != submessage_arena) {
      repeated = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, repeated, submessage_arena);
    }
    set_has_repeated();
    _impl_.type_.repeated_ = repeated;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.repeated)
}
void FieldConstraints::set_allocated_map(::buf::validate::MapRules* map) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (map) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(map);
    if (message_arena != submessage_arena) {
      map = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map, submessage_arena);
    }
    set_has_map();
    _impl_.type_.map_ = map;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.map)
}
void FieldConstraints::set_allocated_any(::buf::validate::AnyRules* any) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (any) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(any);
    if (message_arena != submessage_arena) {
      any = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, any, submessage_arena);
    }
    set_has_any();
    _impl_.type_.any_ = any;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.any)
}
void FieldConstraints::set_allocated_duration(::buf::validate::DurationRules* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (duration) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(duration);
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
    _impl_.type_.duration_ = duration;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.duration)
}
void FieldConstraints::set_allocated_timestamp(::buf::validate::TimestampRules* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_type();
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::InternalGetOwningArena(timestamp);
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    set_has_timestamp();
    _impl_.type_.timestamp_ = timestamp;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.FieldConstraints.timestamp)
}
FieldConstraints::FieldConstraints(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.FieldConstraints)
}
FieldConstraints::FieldConstraints(const FieldConstraints& from) : ::google::protobuf::Message() {
  FieldConstraints* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cel_){from._impl_.cel_},
      decltype(_impl_.skipped_){},
      decltype(_impl_.required_){},
      decltype(_impl_.ignore_empty_){},
      decltype(_impl_.type_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  ::memcpy(&_impl_.skipped_, &from._impl_.skipped_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.ignore_empty_) -
    reinterpret_cast<char*>(&_impl_.skipped_)) + sizeof(_impl_.ignore_empty_));
  clear_has_type();
  switch (from.type_case()) {
    case kFloat: {
      _this->_internal_mutable_float_()->::buf::validate::FloatRules::MergeFrom(
          from._internal_float_());
      break;
    }
    case kDouble: {
      _this->_internal_mutable_double_()->::buf::validate::DoubleRules::MergeFrom(
          from._internal_double_());
      break;
    }
    case kInt32: {
      _this->_internal_mutable_int32()->::buf::validate::Int32Rules::MergeFrom(
          from._internal_int32());
      break;
    }
    case kInt64: {
      _this->_internal_mutable_int64()->::buf::validate::Int64Rules::MergeFrom(
          from._internal_int64());
      break;
    }
    case kUint32: {
      _this->_internal_mutable_uint32()->::buf::validate::UInt32Rules::MergeFrom(
          from._internal_uint32());
      break;
    }
    case kUint64: {
      _this->_internal_mutable_uint64()->::buf::validate::UInt64Rules::MergeFrom(
          from._internal_uint64());
      break;
    }
    case kSint32: {
      _this->_internal_mutable_sint32()->::buf::validate::SInt32Rules::MergeFrom(
          from._internal_sint32());
      break;
    }
    case kSint64: {
      _this->_internal_mutable_sint64()->::buf::validate::SInt64Rules::MergeFrom(
          from._internal_sint64());
      break;
    }
    case kFixed32: {
      _this->_internal_mutable_fixed32()->::buf::validate::Fixed32Rules::MergeFrom(
          from._internal_fixed32());
      break;
    }
    case kFixed64: {
      _this->_internal_mutable_fixed64()->::buf::validate::Fixed64Rules::MergeFrom(
          from._internal_fixed64());
      break;
    }
    case kSfixed32: {
      _this->_internal_mutable_sfixed32()->::buf::validate::SFixed32Rules::MergeFrom(
          from._internal_sfixed32());
      break;
    }
    case kSfixed64: {
      _this->_internal_mutable_sfixed64()->::buf::validate::SFixed64Rules::MergeFrom(
          from._internal_sfixed64());
      break;
    }
    case kBool: {
      _this->_internal_mutable_bool_()->::buf::validate::BoolRules::MergeFrom(
          from._internal_bool_());
      break;
    }
    case kString: {
      _this->_internal_mutable_string()->::buf::validate::StringRules::MergeFrom(
          from._internal_string());
      break;
    }
    case kBytes: {
      _this->_internal_mutable_bytes()->::buf::validate::BytesRules::MergeFrom(
          from._internal_bytes());
      break;
    }
    case kEnum: {
      _this->_internal_mutable_enum_()->::buf::validate::EnumRules::MergeFrom(
          from._internal_enum_());
      break;
    }
    case kRepeated: {
      _this->_internal_mutable_repeated()->::buf::validate::RepeatedRules::MergeFrom(
          from._internal_repeated());
      break;
    }
    case kMap: {
      _this->_internal_mutable_map()->::buf::validate::MapRules::MergeFrom(
          from._internal_map());
      break;
    }
    case kAny: {
      _this->_internal_mutable_any()->::buf::validate::AnyRules::MergeFrom(
          from._internal_any());
      break;
    }
    case kDuration: {
      _this->_internal_mutable_duration()->::buf::validate::DurationRules::MergeFrom(
          from._internal_duration());
      break;
    }
    case kTimestamp: {
      _this->_internal_mutable_timestamp()->::buf::validate::TimestampRules::MergeFrom(
          from._internal_timestamp());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.FieldConstraints)
}
inline void FieldConstraints::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.cel_){arena},
      decltype(_impl_.skipped_){false},
      decltype(_impl_.required_){false},
      decltype(_impl_.ignore_empty_){false},
      decltype(_impl_.type_){},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_type();
}
FieldConstraints::~FieldConstraints() {
  // @@protoc_insertion_point(destructor:buf.validate.FieldConstraints)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void FieldConstraints::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cel_.~RepeatedPtrField();
  if (has_type()) {
    clear_type();
  }
}
void FieldConstraints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FieldConstraints::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.FieldConstraints)
  switch (type_case()) {
    case kFloat: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.float__;
      }
      break;
    }
    case kDouble: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.double__;
      }
      break;
    }
    case kInt32: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.int32_;
      }
      break;
    }
    case kInt64: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.int64_;
      }
      break;
    }
    case kUint32: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.uint32_;
      }
      break;
    }
    case kUint64: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.uint64_;
      }
      break;
    }
    case kSint32: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.sint32_;
      }
      break;
    }
    case kSint64: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.sint64_;
      }
      break;
    }
    case kFixed32: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.fixed32_;
      }
      break;
    }
    case kFixed64: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.fixed64_;
      }
      break;
    }
    case kSfixed32: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.sfixed32_;
      }
      break;
    }
    case kSfixed64: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.sfixed64_;
      }
      break;
    }
    case kBool: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.bool__;
      }
      break;
    }
    case kString: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.string_;
      }
      break;
    }
    case kBytes: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.bytes_;
      }
      break;
    }
    case kEnum: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.enum__;
      }
      break;
    }
    case kRepeated: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.repeated_;
      }
      break;
    }
    case kMap: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.map_;
      }
      break;
    }
    case kAny: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.any_;
      }
      break;
    }
    case kDuration: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.duration_;
      }
      break;
    }
    case kTimestamp: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.type_.timestamp_;
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}


PROTOBUF_NOINLINE void FieldConstraints::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.FieldConstraints)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_cel()->Clear();
  ::memset(&_impl_.skipped_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ignore_empty_) -
      reinterpret_cast<char*>(&_impl_.skipped_)) + sizeof(_impl_.ignore_empty_));
  clear_type();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* FieldConstraints::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 25, 22, 0, 2> FieldConstraints::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    26, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4227923968,  // skipmap
    offsetof(decltype(_table_), field_entries),
    25,  // num_field_entries
    22,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_FieldConstraints_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // bool skipped = 24 [json_name = "skipped"];
    {::_pbi::TcParser::FastV8S2,
     {448, 63, 0, PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.skipped_)}},
    // bool required = 25 [json_name = "required"];
    {::_pbi::TcParser::FastV8S2,
     {456, 63, 0, PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.required_)}},
    // bool ignore_empty = 26 [json_name = "ignoreEmpty"];
    {::_pbi::TcParser::FastV8S2,
     {464, 63, 0, PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.ignore_empty_)}},
    // repeated .buf.validate.Constraint cel = 23 [json_name = "cel"];
    {::_pbi::TcParser::FastMtR2,
     {442, 63, 21, PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.cel_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .buf.validate.FloatRules float = 1 [json_name = "float"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.float__), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.DoubleRules double = 2 [json_name = "double"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.double__), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.Int32Rules int32 = 3 [json_name = "int32"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.int32_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.Int64Rules int64 = 4 [json_name = "int64"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.int64_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.UInt32Rules uint32 = 5 [json_name = "uint32"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.uint32_), _Internal::kOneofCaseOffset + 0, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.UInt64Rules uint64 = 6 [json_name = "uint64"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.uint64_), _Internal::kOneofCaseOffset + 0, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.SInt32Rules sint32 = 7 [json_name = "sint32"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.sint32_), _Internal::kOneofCaseOffset + 0, 6,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.SInt64Rules sint64 = 8 [json_name = "sint64"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.sint64_), _Internal::kOneofCaseOffset + 0, 7,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.Fixed32Rules fixed32 = 9 [json_name = "fixed32"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.fixed32_), _Internal::kOneofCaseOffset + 0, 8,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.Fixed64Rules fixed64 = 10 [json_name = "fixed64"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.fixed64_), _Internal::kOneofCaseOffset + 0, 9,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.SFixed32Rules sfixed32 = 11 [json_name = "sfixed32"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.sfixed32_), _Internal::kOneofCaseOffset + 0, 10,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.SFixed64Rules sfixed64 = 12 [json_name = "sfixed64"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.sfixed64_), _Internal::kOneofCaseOffset + 0, 11,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.BoolRules bool = 13 [json_name = "bool"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.bool__), _Internal::kOneofCaseOffset + 0, 12,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.StringRules string = 14 [json_name = "string"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.string_), _Internal::kOneofCaseOffset + 0, 13,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.BytesRules bytes = 15 [json_name = "bytes"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.bytes_), _Internal::kOneofCaseOffset + 0, 14,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.EnumRules enum = 16 [json_name = "enum"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.enum__), _Internal::kOneofCaseOffset + 0, 15,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.RepeatedRules repeated = 18 [json_name = "repeated"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.repeated_), _Internal::kOneofCaseOffset + 0, 16,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.MapRules map = 19 [json_name = "map"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.map_), _Internal::kOneofCaseOffset + 0, 17,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.AnyRules any = 20 [json_name = "any"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.any_), _Internal::kOneofCaseOffset + 0, 18,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.DurationRules duration = 21 [json_name = "duration"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.duration_), _Internal::kOneofCaseOffset + 0, 19,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .buf.validate.TimestampRules timestamp = 22 [json_name = "timestamp"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.type_.timestamp_), _Internal::kOneofCaseOffset + 0, 20,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .buf.validate.Constraint cel = 23 [json_name = "cel"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.cel_), 0, 21,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool skipped = 24 [json_name = "skipped"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.skipped_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool required = 25 [json_name = "required"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.required_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
    // bool ignore_empty = 26 [json_name = "ignoreEmpty"];
    {PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.ignore_empty_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }}, {{
    {::_pbi::TcParser::GetTable<::buf::validate::FloatRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::DoubleRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::Int32Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::Int64Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::UInt32Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::UInt64Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::SInt32Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::SInt64Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::Fixed32Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::Fixed64Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::SFixed32Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::SFixed64Rules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::BoolRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::StringRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::BytesRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::EnumRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::RepeatedRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::MapRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::AnyRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::DurationRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::TimestampRules>()},
    {::_pbi::TcParser::GetTable<::buf::validate::Constraint>()},
  }}, {{
  }},
};

::uint8_t* FieldConstraints::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.FieldConstraints)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  switch (type_case()) {
    case kFloat: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(1, _Internal::float_(this),
          _Internal::float_(this).GetCachedSize(), target, stream);
      break;
    }
    case kDouble: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(2, _Internal::double_(this),
          _Internal::double_(this).GetCachedSize(), target, stream);
      break;
    }
    case kInt32: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::int32(this),
          _Internal::int32(this).GetCachedSize(), target, stream);
      break;
    }
    case kInt64: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::int64(this),
          _Internal::int64(this).GetCachedSize(), target, stream);
      break;
    }
    case kUint32: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::uint32(this),
          _Internal::uint32(this).GetCachedSize(), target, stream);
      break;
    }
    case kUint64: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::uint64(this),
          _Internal::uint64(this).GetCachedSize(), target, stream);
      break;
    }
    case kSint32: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::sint32(this),
          _Internal::sint32(this).GetCachedSize(), target, stream);
      break;
    }
    case kSint64: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::sint64(this),
          _Internal::sint64(this).GetCachedSize(), target, stream);
      break;
    }
    case kFixed32: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(9, _Internal::fixed32(this),
          _Internal::fixed32(this).GetCachedSize(), target, stream);
      break;
    }
    case kFixed64: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(10, _Internal::fixed64(this),
          _Internal::fixed64(this).GetCachedSize(), target, stream);
      break;
    }
    case kSfixed32: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(11, _Internal::sfixed32(this),
          _Internal::sfixed32(this).GetCachedSize(), target, stream);
      break;
    }
    case kSfixed64: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(12, _Internal::sfixed64(this),
          _Internal::sfixed64(this).GetCachedSize(), target, stream);
      break;
    }
    case kBool: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(13, _Internal::bool_(this),
          _Internal::bool_(this).GetCachedSize(), target, stream);
      break;
    }
    case kString: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(14, _Internal::string(this),
          _Internal::string(this).GetCachedSize(), target, stream);
      break;
    }
    case kBytes: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(15, _Internal::bytes(this),
          _Internal::bytes(this).GetCachedSize(), target, stream);
      break;
    }
    case kEnum: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(16, _Internal::enum_(this),
          _Internal::enum_(this).GetCachedSize(), target, stream);
      break;
    }
    case kRepeated: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(18, _Internal::repeated(this),
          _Internal::repeated(this).GetCachedSize(), target, stream);
      break;
    }
    case kMap: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(19, _Internal::map(this),
          _Internal::map(this).GetCachedSize(), target, stream);
      break;
    }
    case kAny: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(20, _Internal::any(this),
          _Internal::any(this).GetCachedSize(), target, stream);
      break;
    }
    case kDuration: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(21, _Internal::duration(this),
          _Internal::duration(this).GetCachedSize(), target, stream);
      break;
    }
    case kTimestamp: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(22, _Internal::timestamp(this),
          _Internal::timestamp(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // repeated .buf.validate.Constraint cel = 23 [json_name = "cel"];
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_cel_size()); i < n; i++) {
    const auto& repfield = this->_internal_cel().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(23, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool skipped = 24 [json_name = "skipped"];
  if (this->_internal_skipped() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        24, this->_internal_skipped(), target);
  }

  // bool required = 25 [json_name = "required"];
  if (this->_internal_required() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        25, this->_internal_required(), target);
  }

  // bool ignore_empty = 26 [json_name = "ignoreEmpty"];
  if (this->_internal_ignore_empty() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        26, this->_internal_ignore_empty(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.FieldConstraints)
  return target;
}

::size_t FieldConstraints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.FieldConstraints)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .buf.validate.Constraint cel = 23 [json_name = "cel"];
  total_size += 2UL * this->_internal_cel_size();
  for (const auto& msg : this->_internal_cel()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // bool skipped = 24 [json_name = "skipped"];
  if (this->_internal_skipped() != 0) {
    total_size += 3;
  }

  // bool required = 25 [json_name = "required"];
  if (this->_internal_required() != 0) {
    total_size += 3;
  }

  // bool ignore_empty = 26 [json_name = "ignoreEmpty"];
  if (this->_internal_ignore_empty() != 0) {
    total_size += 3;
  }

  switch (type_case()) {
    // .buf.validate.FloatRules float = 1 [json_name = "float"];
    case kFloat: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.float__);
      break;
    }
    // .buf.validate.DoubleRules double = 2 [json_name = "double"];
    case kDouble: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.double__);
      break;
    }
    // .buf.validate.Int32Rules int32 = 3 [json_name = "int32"];
    case kInt32: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.int32_);
      break;
    }
    // .buf.validate.Int64Rules int64 = 4 [json_name = "int64"];
    case kInt64: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.int64_);
      break;
    }
    // .buf.validate.UInt32Rules uint32 = 5 [json_name = "uint32"];
    case kUint32: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.uint32_);
      break;
    }
    // .buf.validate.UInt64Rules uint64 = 6 [json_name = "uint64"];
    case kUint64: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.uint64_);
      break;
    }
    // .buf.validate.SInt32Rules sint32 = 7 [json_name = "sint32"];
    case kSint32: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.sint32_);
      break;
    }
    // .buf.validate.SInt64Rules sint64 = 8 [json_name = "sint64"];
    case kSint64: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.sint64_);
      break;
    }
    // .buf.validate.Fixed32Rules fixed32 = 9 [json_name = "fixed32"];
    case kFixed32: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.fixed32_);
      break;
    }
    // .buf.validate.Fixed64Rules fixed64 = 10 [json_name = "fixed64"];
    case kFixed64: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.fixed64_);
      break;
    }
    // .buf.validate.SFixed32Rules sfixed32 = 11 [json_name = "sfixed32"];
    case kSfixed32: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.sfixed32_);
      break;
    }
    // .buf.validate.SFixed64Rules sfixed64 = 12 [json_name = "sfixed64"];
    case kSfixed64: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.sfixed64_);
      break;
    }
    // .buf.validate.BoolRules bool = 13 [json_name = "bool"];
    case kBool: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.bool__);
      break;
    }
    // .buf.validate.StringRules string = 14 [json_name = "string"];
    case kString: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.string_);
      break;
    }
    // .buf.validate.BytesRules bytes = 15 [json_name = "bytes"];
    case kBytes: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.bytes_);
      break;
    }
    // .buf.validate.EnumRules enum = 16 [json_name = "enum"];
    case kEnum: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.enum__);
      break;
    }
    // .buf.validate.RepeatedRules repeated = 18 [json_name = "repeated"];
    case kRepeated: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.repeated_);
      break;
    }
    // .buf.validate.MapRules map = 19 [json_name = "map"];
    case kMap: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.map_);
      break;
    }
    // .buf.validate.AnyRules any = 20 [json_name = "any"];
    case kAny: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.any_);
      break;
    }
    // .buf.validate.DurationRules duration = 21 [json_name = "duration"];
    case kDuration: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.duration_);
      break;
    }
    // .buf.validate.TimestampRules timestamp = 22 [json_name = "timestamp"];
    case kTimestamp: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.type_.timestamp_);
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData FieldConstraints::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    FieldConstraints::MergeImpl
};
const ::google::protobuf::Message::ClassData*FieldConstraints::GetClassData() const { return &_class_data_; }


void FieldConstraints::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<FieldConstraints*>(&to_msg);
  auto& from = static_cast<const FieldConstraints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.FieldConstraints)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_cel()->MergeFrom(from._internal_cel());
  if (from._internal_skipped() != 0) {
    _this->_internal_set_skipped(from._internal_skipped());
  }
  if (from._internal_required() != 0) {
    _this->_internal_set_required(from._internal_required());
  }
  if (from._internal_ignore_empty() != 0) {
    _this->_internal_set_ignore_empty(from._internal_ignore_empty());
  }
  switch (from.type_case()) {
    case kFloat: {
      _this->_internal_mutable_float_()->::buf::validate::FloatRules::MergeFrom(
          from._internal_float_());
      break;
    }
    case kDouble: {
      _this->_internal_mutable_double_()->::buf::validate::DoubleRules::MergeFrom(
          from._internal_double_());
      break;
    }
    case kInt32: {
      _this->_internal_mutable_int32()->::buf::validate::Int32Rules::MergeFrom(
          from._internal_int32());
      break;
    }
    case kInt64: {
      _this->_internal_mutable_int64()->::buf::validate::Int64Rules::MergeFrom(
          from._internal_int64());
      break;
    }
    case kUint32: {
      _this->_internal_mutable_uint32()->::buf::validate::UInt32Rules::MergeFrom(
          from._internal_uint32());
      break;
    }
    case kUint64: {
      _this->_internal_mutable_uint64()->::buf::validate::UInt64Rules::MergeFrom(
          from._internal_uint64());
      break;
    }
    case kSint32: {
      _this->_internal_mutable_sint32()->::buf::validate::SInt32Rules::MergeFrom(
          from._internal_sint32());
      break;
    }
    case kSint64: {
      _this->_internal_mutable_sint64()->::buf::validate::SInt64Rules::MergeFrom(
          from._internal_sint64());
      break;
    }
    case kFixed32: {
      _this->_internal_mutable_fixed32()->::buf::validate::Fixed32Rules::MergeFrom(
          from._internal_fixed32());
      break;
    }
    case kFixed64: {
      _this->_internal_mutable_fixed64()->::buf::validate::Fixed64Rules::MergeFrom(
          from._internal_fixed64());
      break;
    }
    case kSfixed32: {
      _this->_internal_mutable_sfixed32()->::buf::validate::SFixed32Rules::MergeFrom(
          from._internal_sfixed32());
      break;
    }
    case kSfixed64: {
      _this->_internal_mutable_sfixed64()->::buf::validate::SFixed64Rules::MergeFrom(
          from._internal_sfixed64());
      break;
    }
    case kBool: {
      _this->_internal_mutable_bool_()->::buf::validate::BoolRules::MergeFrom(
          from._internal_bool_());
      break;
    }
    case kString: {
      _this->_internal_mutable_string()->::buf::validate::StringRules::MergeFrom(
          from._internal_string());
      break;
    }
    case kBytes: {
      _this->_internal_mutable_bytes()->::buf::validate::BytesRules::MergeFrom(
          from._internal_bytes());
      break;
    }
    case kEnum: {
      _this->_internal_mutable_enum_()->::buf::validate::EnumRules::MergeFrom(
          from._internal_enum_());
      break;
    }
    case kRepeated: {
      _this->_internal_mutable_repeated()->::buf::validate::RepeatedRules::MergeFrom(
          from._internal_repeated());
      break;
    }
    case kMap: {
      _this->_internal_mutable_map()->::buf::validate::MapRules::MergeFrom(
          from._internal_map());
      break;
    }
    case kAny: {
      _this->_internal_mutable_any()->::buf::validate::AnyRules::MergeFrom(
          from._internal_any());
      break;
    }
    case kDuration: {
      _this->_internal_mutable_duration()->::buf::validate::DurationRules::MergeFrom(
          from._internal_duration());
      break;
    }
    case kTimestamp: {
      _this->_internal_mutable_timestamp()->::buf::validate::TimestampRules::MergeFrom(
          from._internal_timestamp());
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FieldConstraints::CopyFrom(const FieldConstraints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.FieldConstraints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool FieldConstraints::IsInitialized() const {
  return true;
}

void FieldConstraints::InternalSwap(FieldConstraints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.cel_.InternalSwap(&other->_impl_.cel_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.ignore_empty_)
      + sizeof(FieldConstraints::_impl_.ignore_empty_)
      - PROTOBUF_FIELD_OFFSET(FieldConstraints, _impl_.skipped_)>(
          reinterpret_cast<char*>(&_impl_.skipped_),
          reinterpret_cast<char*>(&other->_impl_.skipped_));
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata FieldConstraints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[2]);
}
// ===================================================================

class FloatRules::_Internal {
 public:
  using HasBits = decltype(std::declval<FloatRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FloatRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::FloatRules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FloatRules::FloatRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.FloatRules)
}
FloatRules::FloatRules(const FloatRules& from) : ::google::protobuf::Message() {
  FloatRules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      decltype(_impl_.const__){},
      decltype(_impl_.finite_){},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.finite_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.finite_));
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.FloatRules)
}
inline void FloatRules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      decltype(_impl_.not_in_){arena},
      decltype(_impl_.const__){0},
      decltype(_impl_.finite_){false},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
FloatRules::~FloatRules() {
  // @@protoc_insertion_point(destructor:buf.validate.FloatRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void FloatRules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void FloatRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FloatRules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.FloatRules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void FloatRules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.FloatRules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void FloatRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.FloatRules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  _impl_.const__ = 0;
  _impl_.finite_ = false;
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* FloatRules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 8, 0, 0, 2> FloatRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(FloatRules, _impl_._has_bits_),
    0, // no _extensions_
    8, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_FloatRules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // bool finite = 8 [json_name = "finite", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(FloatRules, _impl_.finite_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.finite_)}},
    // optional float const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.const__)}},
    // repeated float in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF32P1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.in_)}},
    // repeated float not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF32P1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional float const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // float gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFloat)},
    // repeated float in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
    // repeated float not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFloat)},
    // bool finite = 8 [json_name = "finite", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.finite_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* FloatRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.FloatRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated float in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  if (this->_internal_in_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_in(), target);
  }

  // repeated float not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  if (this->_internal_not_in_size() > 0) {
    target = stream->WriteFixedPacked(7, _internal_not_in(), target);
  }

  // bool finite = 8 [json_name = "finite", (.buf.validate.priv.field) = {
  if (this->_internal_finite() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_finite(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.FloatRules)
  return target;
}

::size_t FloatRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.FloatRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_in_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated float not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_not_in_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // optional float const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 5;
  }

  // bool finite = 8 [json_name = "finite", (.buf.validate.priv.field) = {
  if (this->_internal_finite() != 0) {
    total_size += 2;
  }

  switch (less_than_case()) {
    // float lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += 5;
      break;
    }
    // float lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += 5;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // float gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += 5;
      break;
    }
    // float gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += 5;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData FloatRules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    FloatRules::MergeImpl
};
const ::google::protobuf::Message::ClassData*FloatRules::GetClassData() const { return &_class_data_; }


void FloatRules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<FloatRules*>(&to_msg);
  auto& from = static_cast<const FloatRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.FloatRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_const_(from._internal_const_());
  }
  if (from._internal_finite() != 0) {
    _this->_internal_set_finite(from._internal_finite());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void FloatRules::CopyFrom(const FloatRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.FloatRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool FloatRules::IsInitialized() const {
  return true;
}

void FloatRules::InternalSwap(FloatRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.finite_)
      + sizeof(FloatRules::_impl_.finite_)
      - PROTOBUF_FIELD_OFFSET(FloatRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata FloatRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[3]);
}
// ===================================================================

class DoubleRules::_Internal {
 public:
  using HasBits = decltype(std::declval<DoubleRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::DoubleRules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DoubleRules::DoubleRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.DoubleRules)
}
DoubleRules::DoubleRules(const DoubleRules& from) : ::google::protobuf::Message() {
  DoubleRules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      decltype(_impl_.const__){},
      decltype(_impl_.finite_){},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.finite_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.finite_));
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.DoubleRules)
}
inline void DoubleRules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      decltype(_impl_.not_in_){arena},
      decltype(_impl_.const__){0},
      decltype(_impl_.finite_){false},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
DoubleRules::~DoubleRules() {
  // @@protoc_insertion_point(destructor:buf.validate.DoubleRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void DoubleRules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void DoubleRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DoubleRules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.DoubleRules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void DoubleRules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.DoubleRules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void DoubleRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.DoubleRules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  _impl_.const__ = 0;
  _impl_.finite_ = false;
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* DoubleRules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 8, 0, 0, 2> DoubleRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_._has_bits_),
    0, // no _extensions_
    8, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_DoubleRules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // bool finite = 8 [json_name = "finite", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(DoubleRules, _impl_.finite_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.finite_)}},
    // optional double const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.const__)}},
    // repeated double in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF64P1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.in_)}},
    // repeated double not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF64P1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional double const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kDouble)},
    // double lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kDouble)},
    // double lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kDouble)},
    // double gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kDouble)},
    // double gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kDouble)},
    // repeated double in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedDouble)},
    // repeated double not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedDouble)},
    // bool finite = 8 [json_name = "finite", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.finite_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* DoubleRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.DoubleRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated double in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  if (this->_internal_in_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_in(), target);
  }

  // repeated double not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  if (this->_internal_not_in_size() > 0) {
    target = stream->WriteFixedPacked(7, _internal_not_in(), target);
  }

  // bool finite = 8 [json_name = "finite", (.buf.validate.priv.field) = {
  if (this->_internal_finite() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_finite(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.DoubleRules)
  return target;
}

::size_t DoubleRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.DoubleRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_in_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated double not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_not_in_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // optional double const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 9;
  }

  // bool finite = 8 [json_name = "finite", (.buf.validate.priv.field) = {
  if (this->_internal_finite() != 0) {
    total_size += 2;
  }

  switch (less_than_case()) {
    // double lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += 9;
      break;
    }
    // double lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += 9;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // double gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += 9;
      break;
    }
    // double gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += 9;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData DoubleRules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    DoubleRules::MergeImpl
};
const ::google::protobuf::Message::ClassData*DoubleRules::GetClassData() const { return &_class_data_; }


void DoubleRules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<DoubleRules*>(&to_msg);
  auto& from = static_cast<const DoubleRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.DoubleRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_const_(from._internal_const_());
  }
  if (from._internal_finite() != 0) {
    _this->_internal_set_finite(from._internal_finite());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DoubleRules::CopyFrom(const DoubleRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.DoubleRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool DoubleRules::IsInitialized() const {
  return true;
}

void DoubleRules::InternalSwap(DoubleRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.finite_)
      + sizeof(DoubleRules::_impl_.finite_)
      - PROTOBUF_FIELD_OFFSET(DoubleRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata DoubleRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[4]);
}
// ===================================================================

class Int32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Int32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int32Rules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Int32Rules::Int32Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Int32Rules)
}
Int32Rules::Int32Rules(const Int32Rules& from) : ::google::protobuf::Message() {
  Int32Rules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.const__ = from._impl_.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.Int32Rules)
}
inline void Int32Rules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){arena},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){0},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
Int32Rules::~Int32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.Int32Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Int32Rules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void Int32Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Int32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Int32Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void Int32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Int32Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void Int32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Int32Rules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  _impl_.const__ = 0;
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Int32Rules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 7, 0, 0, 2> Int32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_._has_bits_),
    0, // no _extensions_
    7, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Int32Rules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Int32Rules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.const__)}},
    // repeated int32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastV32P1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.in_)}},
    // repeated int32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastV32P1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // int32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt32)},
    // int32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt32)},
    // int32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt32)},
    // int32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt32)},
    // repeated int32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Int32Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Int32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<1>(
            stream, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt32ToArrayWithField<2>(
              stream, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt32ToArrayWithField<3>(
              stream, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt32ToArrayWithField<4>(
              stream, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt32ToArrayWithField<5>(
              stream, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated int32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(6, _internal_in(),
                                                 byte_size, target);
    }
  }

  // repeated int32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._not_in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(7, _internal_not_in(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Int32Rules)
  return target;
}

::size_t Int32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Int32Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_in())
    ;
    _impl_._in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated int32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_not_in())
    ;
    _impl_._not_in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // optional int32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // int32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_lt());
      break;
    }
    // int32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // int32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_gt());
      break;
    }
    // int32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Int32Rules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Int32Rules::MergeImpl
};
const ::google::protobuf::Message::ClassData*Int32Rules::GetClassData() const { return &_class_data_; }


void Int32Rules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Int32Rules*>(&to_msg);
  auto& from = static_cast<const Int32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Int32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Int32Rules::CopyFrom(const Int32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Int32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Int32Rules::IsInitialized() const {
  return true;
}

void Int32Rules::InternalSwap(Int32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata Int32Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[5]);
}
// ===================================================================

class Int64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Int64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::Int64Rules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Int64Rules::Int64Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Int64Rules)
}
Int64Rules::Int64Rules(const Int64Rules& from) : ::google::protobuf::Message() {
  Int64Rules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.const__ = from._impl_.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.Int64Rules)
}
inline void Int64Rules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){arena},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){::int64_t{0}},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
Int64Rules::~Int64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.Int64Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Int64Rules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void Int64Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Int64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Int64Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void Int64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Int64Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void Int64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Int64Rules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  _impl_.const__ = ::int64_t{0};
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Int64Rules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 7, 0, 0, 2> Int64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_._has_bits_),
    0, // no _extensions_
    7, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Int64Rules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional int64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(Int64Rules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.const__)}},
    // repeated int64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastV64P1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.in_)}},
    // repeated int64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastV64P1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt64)},
    // int64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt64)},
    // int64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt64)},
    // int64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt64)},
    // int64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kInt64)},
    // repeated int64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
    // repeated int64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Int64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Int64Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Int64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt64ToArrayWithField<1>(
            stream, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt64ToArrayWithField<2>(
              stream, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt64ToArrayWithField<3>(
              stream, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt64ToArrayWithField<4>(
              stream, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = ::google::protobuf::internal::WireFormatLite::
          WriteInt64ToArrayWithField<5>(
              stream, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated int64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(6, _internal_in(),
                                                 byte_size, target);
    }
  }

  // repeated int64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._not_in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(7, _internal_not_in(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Int64Rules)
  return target;
}

::size_t Int64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Int64Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
        this->_internal_in())
    ;
    _impl_._in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated int64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int64Size(
        this->_internal_not_in())
    ;
    _impl_._not_in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // optional int64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // int64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_lt());
      break;
    }
    // int64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // int64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_gt());
      break;
    }
    // int64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Int64Rules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Int64Rules::MergeImpl
};
const ::google::protobuf::Message::ClassData*Int64Rules::GetClassData() const { return &_class_data_; }


void Int64Rules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Int64Rules*>(&to_msg);
  auto& from = static_cast<const Int64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Int64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Int64Rules::CopyFrom(const Int64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Int64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Int64Rules::IsInitialized() const {
  return true;
}

void Int64Rules::InternalSwap(Int64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata Int64Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[6]);
}
// ===================================================================

class UInt32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<UInt32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt32Rules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UInt32Rules::UInt32Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.UInt32Rules)
}
UInt32Rules::UInt32Rules(const UInt32Rules& from) : ::google::protobuf::Message() {
  UInt32Rules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.const__ = from._impl_.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.UInt32Rules)
}
inline void UInt32Rules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){arena},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){0u},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
UInt32Rules::~UInt32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.UInt32Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void UInt32Rules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void UInt32Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UInt32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.UInt32Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void UInt32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.UInt32Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void UInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.UInt32Rules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  _impl_.const__ = 0u;
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* UInt32Rules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 7, 0, 0, 2> UInt32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_._has_bits_),
    0, // no _extensions_
    7, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_UInt32Rules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(UInt32Rules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.const__)}},
    // repeated uint32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastV32P1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.in_)}},
    // repeated uint32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastV32P1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // uint32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // uint32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt32)},
    // repeated uint32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt32)},
    // repeated uint32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* UInt32Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.UInt32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated uint32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(6, _internal_in(),
                                                 byte_size, target);
    }
  }

  // repeated uint32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._not_in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(7, _internal_not_in(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.UInt32Rules)
  return target;
}

::size_t UInt32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.UInt32Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_in())
    ;
    _impl_._in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated uint32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt32Size(
        this->_internal_not_in())
    ;
    _impl_._not_in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // optional uint32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // uint32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lt());
      break;
    }
    // uint32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // uint32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gt());
      break;
    }
    // uint32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData UInt32Rules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    UInt32Rules::MergeImpl
};
const ::google::protobuf::Message::ClassData*UInt32Rules::GetClassData() const { return &_class_data_; }


void UInt32Rules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<UInt32Rules*>(&to_msg);
  auto& from = static_cast<const UInt32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.UInt32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UInt32Rules::CopyFrom(const UInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.UInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UInt32Rules::IsInitialized() const {
  return true;
}

void UInt32Rules::InternalSwap(UInt32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata UInt32Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[7]);
}
// ===================================================================

class UInt64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<UInt64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::UInt64Rules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UInt64Rules::UInt64Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.UInt64Rules)
}
UInt64Rules::UInt64Rules(const UInt64Rules& from) : ::google::protobuf::Message() {
  UInt64Rules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.const__ = from._impl_.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.UInt64Rules)
}
inline void UInt64Rules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){arena},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){::uint64_t{0u}},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
UInt64Rules::~UInt64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.UInt64Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void UInt64Rules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void UInt64Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UInt64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.UInt64Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void UInt64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.UInt64Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void UInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.UInt64Rules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  _impl_.const__ = ::uint64_t{0u};
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* UInt64Rules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 7, 0, 0, 2> UInt64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_._has_bits_),
    0, // no _extensions_
    7, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_UInt64Rules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(UInt64Rules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.const__)}},
    // repeated uint64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastV64P1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.in_)}},
    // repeated uint64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastV64P1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // uint64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt64)},
    // uint64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt64)},
    // uint64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt64)},
    // uint64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUInt64)},
    // repeated uint64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt64)},
    // repeated uint64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(UInt64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedUInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* UInt64Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.UInt64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated uint64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(6, _internal_in(),
                                                 byte_size, target);
    }
  }

  // repeated uint64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._not_in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(7, _internal_not_in(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.UInt64Rules)
  return target;
}

::size_t UInt64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.UInt64Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt64Size(
        this->_internal_in())
    ;
    _impl_._in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated uint64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::UInt64Size(
        this->_internal_not_in())
    ;
    _impl_._not_in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // optional uint64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // uint64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_lt());
      break;
    }
    // uint64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // uint64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_gt());
      break;
    }
    // uint64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData UInt64Rules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    UInt64Rules::MergeImpl
};
const ::google::protobuf::Message::ClassData*UInt64Rules::GetClassData() const { return &_class_data_; }


void UInt64Rules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<UInt64Rules*>(&to_msg);
  auto& from = static_cast<const UInt64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.UInt64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void UInt64Rules::CopyFrom(const UInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.UInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool UInt64Rules::IsInitialized() const {
  return true;
}

void UInt64Rules::InternalSwap(UInt64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata UInt64Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[8]);
}
// ===================================================================

class SInt32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SInt32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt32Rules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SInt32Rules::SInt32Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.SInt32Rules)
}
SInt32Rules::SInt32Rules(const SInt32Rules& from) : ::google::protobuf::Message() {
  SInt32Rules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.const__ = from._impl_.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.SInt32Rules)
}
inline void SInt32Rules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){arena},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){0},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
SInt32Rules::~SInt32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.SInt32Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SInt32Rules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void SInt32Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SInt32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SInt32Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void SInt32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SInt32Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void SInt32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.SInt32Rules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  _impl_.const__ = 0;
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SInt32Rules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 7, 0, 0, 2> SInt32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_._has_bits_),
    0, // no _extensions_
    7, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SInt32Rules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional sint32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastZ32S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.const__)}},
    // repeated sint32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastZ32P1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.in_)}},
    // repeated sint32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastZ32P1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional sint32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt32)},
    // sint32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt32)},
    // sint32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt32)},
    // sint32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt32)},
    // sint32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt32)},
    // repeated sint32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedSInt32)},
    // repeated sint32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedSInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* SInt32Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.SInt32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt32ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated sint32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteSInt32Packed(6, _internal_in(),
                                                 byte_size, target);
    }
  }

  // repeated sint32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._not_in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteSInt32Packed(7, _internal_not_in(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.SInt32Rules)
  return target;
}

::size_t SInt32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.SInt32Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sint32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::SInt32Size(
        this->_internal_in())
    ;
    _impl_._in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated sint32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::SInt32Size(
        this->_internal_not_in())
    ;
    _impl_._not_in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // optional sint32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // sint32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this->_internal_lt());
      break;
    }
    // sint32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // sint32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this->_internal_gt());
      break;
    }
    // sint32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SInt32Rules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SInt32Rules::MergeImpl
};
const ::google::protobuf::Message::ClassData*SInt32Rules::GetClassData() const { return &_class_data_; }


void SInt32Rules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SInt32Rules*>(&to_msg);
  auto& from = static_cast<const SInt32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.SInt32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SInt32Rules::CopyFrom(const SInt32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.SInt32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SInt32Rules::IsInitialized() const {
  return true;
}

void SInt32Rules::InternalSwap(SInt32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata SInt32Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[9]);
}
// ===================================================================

class SInt64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SInt64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::SInt64Rules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SInt64Rules::SInt64Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.SInt64Rules)
}
SInt64Rules::SInt64Rules(const SInt64Rules& from) : ::google::protobuf::Message() {
  SInt64Rules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.const__ = from._impl_.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.SInt64Rules)
}
inline void SInt64Rules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){arena},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){::int64_t{0}},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
SInt64Rules::~SInt64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.SInt64Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SInt64Rules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void SInt64Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SInt64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SInt64Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void SInt64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SInt64Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void SInt64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.SInt64Rules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  _impl_.const__ = ::int64_t{0};
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SInt64Rules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 7, 0, 0, 2> SInt64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_._has_bits_),
    0, // no _extensions_
    7, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SInt64Rules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional sint64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastZ64S1,
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.const__)}},
    // repeated sint64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastZ64P1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.in_)}},
    // repeated sint64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastZ64P1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional sint64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSInt64)},
    // sint64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt64)},
    // sint64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt64)},
    // sint64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt64)},
    // sint64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSInt64)},
    // repeated sint64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedSInt64)},
    // repeated sint64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SInt64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedSInt64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* SInt64Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.SInt64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSInt64ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated sint64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteSInt64Packed(6, _internal_in(),
                                                 byte_size, target);
    }
  }

  // repeated sint64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._not_in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteSInt64Packed(7, _internal_not_in(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.SInt64Rules)
  return target;
}

::size_t SInt64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.SInt64Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sint64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::SInt64Size(
        this->_internal_in())
    ;
    _impl_._in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated sint64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::SInt64Size(
        this->_internal_not_in())
    ;
    _impl_._not_in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // optional sint64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
        this->_internal_const_());
  }

  switch (less_than_case()) {
    // sint64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
          this->_internal_lt());
      break;
    }
    // sint64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
          this->_internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // sint64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
          this->_internal_gt());
      break;
    }
    // sint64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(
          this->_internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SInt64Rules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SInt64Rules::MergeImpl
};
const ::google::protobuf::Message::ClassData*SInt64Rules::GetClassData() const { return &_class_data_; }


void SInt64Rules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SInt64Rules*>(&to_msg);
  auto& from = static_cast<const SInt64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.SInt64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SInt64Rules::CopyFrom(const SInt64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.SInt64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SInt64Rules::IsInitialized() const {
  return true;
}

void SInt64Rules::InternalSwap(SInt64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata SInt64Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[10]);
}
// ===================================================================

class Fixed32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Fixed32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed32Rules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Fixed32Rules::Fixed32Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Fixed32Rules)
}
Fixed32Rules::Fixed32Rules(const Fixed32Rules& from) : ::google::protobuf::Message() {
  Fixed32Rules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      decltype(_impl_.const__){},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.const__ = from._impl_.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.Fixed32Rules)
}
inline void Fixed32Rules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      decltype(_impl_.not_in_){arena},
      decltype(_impl_.const__){0u},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
Fixed32Rules::~Fixed32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.Fixed32Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Fixed32Rules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void Fixed32Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Fixed32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Fixed32Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void Fixed32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Fixed32Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void Fixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Fixed32Rules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  _impl_.const__ = 0u;
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Fixed32Rules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 7, 0, 0, 2> Fixed32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_._has_bits_),
    0, // no _extensions_
    7, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Fixed32Rules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional fixed32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.const__)}},
    // repeated fixed32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF32P1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.in_)}},
    // repeated fixed32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF32P1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional fixed32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed32)},
    // fixed32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed32)},
    // fixed32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed32)},
    // fixed32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed32)},
    // fixed32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed32)},
    // repeated fixed32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFixed32)},
    // repeated fixed32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFixed32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Fixed32Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Fixed32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated fixed32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  if (this->_internal_in_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_in(), target);
  }

  // repeated fixed32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  if (this->_internal_not_in_size() > 0) {
    target = stream->WriteFixedPacked(7, _internal_not_in(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Fixed32Rules)
  return target;
}

::size_t Fixed32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Fixed32Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_in_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated fixed32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_not_in_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // optional fixed32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 5;
  }

  switch (less_than_case()) {
    // fixed32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += 5;
      break;
    }
    // fixed32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += 5;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // fixed32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += 5;
      break;
    }
    // fixed32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += 5;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Fixed32Rules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Fixed32Rules::MergeImpl
};
const ::google::protobuf::Message::ClassData*Fixed32Rules::GetClassData() const { return &_class_data_; }


void Fixed32Rules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Fixed32Rules*>(&to_msg);
  auto& from = static_cast<const Fixed32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Fixed32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Fixed32Rules::CopyFrom(const Fixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Fixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Fixed32Rules::IsInitialized() const {
  return true;
}

void Fixed32Rules::InternalSwap(Fixed32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata Fixed32Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[11]);
}
// ===================================================================

class Fixed64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<Fixed64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::Fixed64Rules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Fixed64Rules::Fixed64Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.Fixed64Rules)
}
Fixed64Rules::Fixed64Rules(const Fixed64Rules& from) : ::google::protobuf::Message() {
  Fixed64Rules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      decltype(_impl_.const__){},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.const__ = from._impl_.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.Fixed64Rules)
}
inline void Fixed64Rules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      decltype(_impl_.not_in_){arena},
      decltype(_impl_.const__){::uint64_t{0u}},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
Fixed64Rules::~Fixed64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.Fixed64Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Fixed64Rules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void Fixed64Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Fixed64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Fixed64Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void Fixed64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.Fixed64Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void Fixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.Fixed64Rules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  _impl_.const__ = ::uint64_t{0u};
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* Fixed64Rules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 7, 0, 0, 2> Fixed64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_._has_bits_),
    0, // no _extensions_
    7, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_Fixed64Rules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional fixed64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.const__)}},
    // repeated fixed64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF64P1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.in_)}},
    // repeated fixed64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF64P1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional fixed64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFixed64)},
    // fixed64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed64)},
    // fixed64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed64)},
    // fixed64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed64)},
    // fixed64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kFixed64)},
    // repeated fixed64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFixed64)},
    // repeated fixed64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(Fixed64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedFixed64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* Fixed64Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.Fixed64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed64ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated fixed64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  if (this->_internal_in_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_in(), target);
  }

  // repeated fixed64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  if (this->_internal_not_in_size() > 0) {
    target = stream->WriteFixedPacked(7, _internal_not_in(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.Fixed64Rules)
  return target;
}

::size_t Fixed64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.Fixed64Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_in_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated fixed64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_not_in_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // optional fixed64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 9;
  }

  switch (less_than_case()) {
    // fixed64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += 9;
      break;
    }
    // fixed64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += 9;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // fixed64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += 9;
      break;
    }
    // fixed64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += 9;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData Fixed64Rules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    Fixed64Rules::MergeImpl
};
const ::google::protobuf::Message::ClassData*Fixed64Rules::GetClassData() const { return &_class_data_; }


void Fixed64Rules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<Fixed64Rules*>(&to_msg);
  auto& from = static_cast<const Fixed64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.Fixed64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Fixed64Rules::CopyFrom(const Fixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.Fixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool Fixed64Rules::IsInitialized() const {
  return true;
}

void Fixed64Rules::InternalSwap(Fixed64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata Fixed64Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[12]);
}
// ===================================================================

class SFixed32Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SFixed32Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed32Rules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SFixed32Rules::SFixed32Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.SFixed32Rules)
}
SFixed32Rules::SFixed32Rules(const SFixed32Rules& from) : ::google::protobuf::Message() {
  SFixed32Rules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      decltype(_impl_.const__){},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.const__ = from._impl_.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.SFixed32Rules)
}
inline void SFixed32Rules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      decltype(_impl_.not_in_){arena},
      decltype(_impl_.const__){0},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
SFixed32Rules::~SFixed32Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.SFixed32Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SFixed32Rules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void SFixed32Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SFixed32Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SFixed32Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void SFixed32Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SFixed32Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void SFixed32Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.SFixed32Rules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  _impl_.const__ = 0;
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SFixed32Rules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 7, 0, 0, 2> SFixed32Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_._has_bits_),
    0, // no _extensions_
    7, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SFixed32Rules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional sfixed32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.const__)}},
    // repeated sfixed32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF32P1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.in_)}},
    // repeated sfixed32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF32P1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional sfixed32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed32)},
    // sfixed32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed32)},
    // sfixed32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed32)},
    // sfixed32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed32)},
    // sfixed32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed32)},
    // repeated sfixed32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedSFixed32)},
    // repeated sfixed32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed32Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedSFixed32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* SFixed32Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.SFixed32Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sfixed32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed32ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated sfixed32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  if (this->_internal_in_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_in(), target);
  }

  // repeated sfixed32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  if (this->_internal_not_in_size() > 0) {
    target = stream->WriteFixedPacked(7, _internal_not_in(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.SFixed32Rules)
  return target;
}

::size_t SFixed32Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.SFixed32Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sfixed32 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_in_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated sfixed32 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = std::size_t{4} *
        ::_pbi::FromIntSize(this->_internal_not_in_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // optional sfixed32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 5;
  }

  switch (less_than_case()) {
    // sfixed32 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += 5;
      break;
    }
    // sfixed32 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += 5;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // sfixed32 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += 5;
      break;
    }
    // sfixed32 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += 5;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SFixed32Rules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SFixed32Rules::MergeImpl
};
const ::google::protobuf::Message::ClassData*SFixed32Rules::GetClassData() const { return &_class_data_; }


void SFixed32Rules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SFixed32Rules*>(&to_msg);
  auto& from = static_cast<const SFixed32Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.SFixed32Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SFixed32Rules::CopyFrom(const SFixed32Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.SFixed32Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SFixed32Rules::IsInitialized() const {
  return true;
}

void SFixed32Rules::InternalSwap(SFixed32Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata SFixed32Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[13]);
}
// ===================================================================

class SFixed64Rules::_Internal {
 public:
  using HasBits = decltype(std::declval<SFixed64Rules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::SFixed64Rules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SFixed64Rules::SFixed64Rules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.SFixed64Rules)
}
SFixed64Rules::SFixed64Rules(const SFixed64Rules& from) : ::google::protobuf::Message() {
  SFixed64Rules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      decltype(_impl_.const__){},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _this->_impl_.const__ = from._impl_.const__;
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.SFixed64Rules)
}
inline void SFixed64Rules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      decltype(_impl_.not_in_){arena},
      decltype(_impl_.const__){::int64_t{0}},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
SFixed64Rules::~SFixed64Rules() {
  // @@protoc_insertion_point(destructor:buf.validate.SFixed64Rules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void SFixed64Rules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void SFixed64Rules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SFixed64Rules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SFixed64Rules)
  switch (less_than_case()) {
    case kLt: {
      // No need to clear
      break;
    }
    case kLte: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void SFixed64Rules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.SFixed64Rules)
  switch (greater_than_case()) {
    case kGt: {
      // No need to clear
      break;
    }
    case kGte: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void SFixed64Rules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.SFixed64Rules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  _impl_.const__ = ::int64_t{0};
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* SFixed64Rules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 7, 0, 0, 2> SFixed64Rules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_._has_bits_),
    0, // no _extensions_
    7, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_SFixed64Rules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional sfixed64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF64S1,
     {9, 0, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.const__)}},
    // repeated sfixed64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF64P1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.in_)}},
    // repeated sfixed64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastF64P1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional sfixed64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kSFixed64)},
    // sfixed64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed64)},
    // sfixed64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed64)},
    // sfixed64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed64)},
    // sfixed64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kSFixed64)},
    // repeated sfixed64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedSFixed64)},
    // repeated sfixed64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(SFixed64Rules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedSFixed64)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* SFixed64Rules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.SFixed64Rules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sfixed64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
        1, this->_internal_const_(), target);
  }

  switch (less_than_case()) {
    case kLt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
          2, this->_internal_lt(), target);
      break;
    }
    case kLte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
          3, this->_internal_lte(), target);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
          4, this->_internal_gt(), target);
      break;
    }
    case kGte: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteSFixed64ToArray(
          5, this->_internal_gte(), target);
      break;
    }
    default:
      break;
  }
  // repeated sfixed64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  if (this->_internal_in_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_in(), target);
  }

  // repeated sfixed64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  if (this->_internal_not_in_size() > 0) {
    target = stream->WriteFixedPacked(7, _internal_not_in(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.SFixed64Rules)
  return target;
}

::size_t SFixed64Rules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.SFixed64Rules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated sfixed64 in = 6 [json_name = "in", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_in_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated sfixed64 not_in = 7 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = std::size_t{8} *
        ::_pbi::FromIntSize(this->_internal_not_in_size())
    ;
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // optional sfixed64 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 9;
  }

  switch (less_than_case()) {
    // sfixed64 lt = 2 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += 9;
      break;
    }
    // sfixed64 lte = 3 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += 9;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // sfixed64 gt = 4 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += 9;
      break;
    }
    // sfixed64 gte = 5 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += 9;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData SFixed64Rules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    SFixed64Rules::MergeImpl
};
const ::google::protobuf::Message::ClassData*SFixed64Rules::GetClassData() const { return &_class_data_; }


void SFixed64Rules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<SFixed64Rules*>(&to_msg);
  auto& from = static_cast<const SFixed64Rules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.SFixed64Rules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_const_(from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_set_lt(from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_set_lte(from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_set_gt(from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_set_gte(from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SFixed64Rules::CopyFrom(const SFixed64Rules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.SFixed64Rules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool SFixed64Rules::IsInitialized() const {
  return true;
}

void SFixed64Rules::InternalSwap(SFixed64Rules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
        swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata SFixed64Rules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[14]);
}
// ===================================================================

class BoolRules::_Internal {
 public:
  using HasBits = decltype(std::declval<BoolRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BoolRules, _impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BoolRules::BoolRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.BoolRules)
}
BoolRules::BoolRules(const BoolRules& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:buf.validate.BoolRules)
}
inline void BoolRules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.const__){false},
  };
}
BoolRules::~BoolRules() {
  // @@protoc_insertion_point(destructor:buf.validate.BoolRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void BoolRules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void BoolRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void BoolRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.BoolRules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.const__ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* BoolRules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> BoolRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BoolRules, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_BoolRules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional bool const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(BoolRules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(BoolRules, _impl_.const__)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bool const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BoolRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* BoolRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.BoolRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_const_(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.BoolRules)
  return target;
}

::size_t BoolRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.BoolRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 2;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData BoolRules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    BoolRules::MergeImpl
};
const ::google::protobuf::Message::ClassData*BoolRules::GetClassData() const { return &_class_data_; }


void BoolRules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<BoolRules*>(&to_msg);
  auto& from = static_cast<const BoolRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.BoolRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_const_(from._internal_const_());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void BoolRules::CopyFrom(const BoolRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.BoolRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BoolRules::IsInitialized() const {
  return true;
}

void BoolRules::InternalSwap(BoolRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
        swap(_impl_.const__, other->_impl_.const__);
}

::google::protobuf::Metadata BoolRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[15]);
}
// ===================================================================

class StringRules::_Internal {
 public:
  using HasBits = decltype(std::declval<StringRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StringRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::StringRules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_min_len(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_max_len(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_len_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_min_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_max_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_suffix(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contains(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_not_contains(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_strict(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

StringRules::StringRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.StringRules)
}
StringRules::StringRules(const StringRules& from) : ::google::protobuf::Message() {
  StringRules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      decltype(_impl_.const__){},
      decltype(_impl_.pattern_){},
      decltype(_impl_.prefix_){},
      decltype(_impl_.suffix_){},
      decltype(_impl_.contains_){},
      decltype(_impl_.not_contains_){},
      decltype(_impl_.min_len_){},
      decltype(_impl_.max_len_){},
      decltype(_impl_.min_bytes_){},
      decltype(_impl_.max_bytes_){},
      decltype(_impl_.len_){},
      decltype(_impl_.len_bytes_){},
      decltype(_impl_.strict_){},
      decltype(_impl_.well_known_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.const__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.const__.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.const__.Set(from._internal_const_(), _this->GetArenaForAllocation());
  }
  _impl_.pattern_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.pattern_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.pattern_.Set(from._internal_pattern(), _this->GetArenaForAllocation());
  }
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.prefix_.Set(from._internal_prefix(), _this->GetArenaForAllocation());
  }
  _impl_.suffix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.suffix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.suffix_.Set(from._internal_suffix(), _this->GetArenaForAllocation());
  }
  _impl_.contains_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.contains_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.contains_.Set(from._internal_contains(), _this->GetArenaForAllocation());
  }
  _impl_.not_contains_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.not_contains_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.not_contains_.Set(from._internal_not_contains(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.min_len_, &from._impl_.min_len_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.strict_) -
    reinterpret_cast<char*>(&_impl_.min_len_)) + sizeof(_impl_.strict_));
  clear_has_well_known();
  switch (from.well_known_case()) {
    case kEmail: {
      _this->_internal_set_email(from._internal_email());
      break;
    }
    case kHostname: {
      _this->_internal_set_hostname(from._internal_hostname());
      break;
    }
    case kIp: {
      _this->_internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _this->_internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _this->_internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case kUri: {
      _this->_internal_set_uri(from._internal_uri());
      break;
    }
    case kUriRef: {
      _this->_internal_set_uri_ref(from._internal_uri_ref());
      break;
    }
    case kAddress: {
      _this->_internal_set_address(from._internal_address());
      break;
    }
    case kUuid: {
      _this->_internal_set_uuid(from._internal_uuid());
      break;
    }
    case kWellKnownRegex: {
      _this->_internal_set_well_known_regex(from._internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.StringRules)
}
inline void StringRules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      decltype(_impl_.not_in_){arena},
      decltype(_impl_.const__){},
      decltype(_impl_.pattern_){},
      decltype(_impl_.prefix_){},
      decltype(_impl_.suffix_){},
      decltype(_impl_.contains_){},
      decltype(_impl_.not_contains_){},
      decltype(_impl_.min_len_){::uint64_t{0u}},
      decltype(_impl_.max_len_){::uint64_t{0u}},
      decltype(_impl_.min_bytes_){::uint64_t{0u}},
      decltype(_impl_.max_bytes_){::uint64_t{0u}},
      decltype(_impl_.len_){::uint64_t{0u}},
      decltype(_impl_.len_bytes_){::uint64_t{0u}},
      decltype(_impl_.strict_){false},
      decltype(_impl_.well_known_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _impl_.const__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.const__.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pattern_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.pattern_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.suffix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.suffix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contains_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.contains_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.not_contains_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.not_contains_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_well_known();
}
StringRules::~StringRules() {
  // @@protoc_insertion_point(destructor:buf.validate.StringRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void StringRules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_in()->~RepeatedPtrField();
  _internal_mutable_not_in()->~RepeatedPtrField();
  _impl_.const__.Destroy();
  _impl_.pattern_.Destroy();
  _impl_.prefix_.Destroy();
  _impl_.suffix_.Destroy();
  _impl_.contains_.Destroy();
  _impl_.not_contains_.Destroy();
  if (has_well_known()) {
    clear_well_known();
  }
}
void StringRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StringRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.StringRules)
  switch (well_known_case()) {
    case kEmail: {
      // No need to clear
      break;
    }
    case kHostname: {
      // No need to clear
      break;
    }
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case kUri: {
      // No need to clear
      break;
    }
    case kUriRef: {
      // No need to clear
      break;
    }
    case kAddress: {
      // No need to clear
      break;
    }
    case kUuid: {
      // No need to clear
      break;
    }
    case kWellKnownRegex: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


PROTOBUF_NOINLINE void StringRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.StringRules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.const__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.suffix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.contains_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.not_contains_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.min_len_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.max_len_) -
        reinterpret_cast<char*>(&_impl_.min_len_)) + sizeof(_impl_.max_len_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.min_bytes_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.strict_) -
        reinterpret_cast<char*>(&_impl_.min_bytes_)) + sizeof(_impl_.strict_));
  }
  clear_well_known();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* StringRules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 25, 0, 109, 2> StringRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(StringRules, _impl_._has_bits_),
    0, // no _extensions_
    25, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4261412864,  // skipmap
    offsetof(decltype(_table_), field_entries),
    25,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_StringRules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional string const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.const__)}},
    // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StringRules, _impl_.min_len_), 6>(),
     {16, 6, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_len_)}},
    // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StringRules, _impl_.max_len_), 7>(),
     {24, 7, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.max_len_)}},
    // optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StringRules, _impl_.min_bytes_), 8>(),
     {32, 8, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_bytes_)}},
    // optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(StringRules, _impl_.max_bytes_), 9>(),
     {40, 9, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.max_bytes_)}},
    // optional string pattern = 6 [json_name = "pattern", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastUS1,
     {50, 1, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.pattern_)}},
    // optional string prefix = 7 [json_name = "prefix", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastUS1,
     {58, 2, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.prefix_)}},
    // optional string suffix = 8 [json_name = "suffix", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastUS1,
     {66, 3, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.suffix_)}},
    // optional string contains = 9 [json_name = "contains", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastUS1,
     {74, 4, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.contains_)}},
    // repeated string in = 10 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastUR1,
     {82, 63, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.in_)}},
    // repeated string not_in = 11 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastUR1,
     {90, 63, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.not_in_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint64 len = 19 [json_name = "len", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastV64S2,
     {408, 10, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.len_)}},
    // optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastV64S2,
     {416, 11, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.len_bytes_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional string not_contains = 23 [json_name = "notContains", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastUS2,
     {442, 5, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.not_contains_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional bool strict = 25 [json_name = "strict"];
    {::_pbi::TcParser::FastV8S2,
     {456, 12, 0, PROTOBUF_FIELD_OFFSET(StringRules, _impl_.strict_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_len_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.max_len_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_bytes_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.max_bytes_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional string pattern = 6 [json_name = "pattern", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.pattern_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string prefix = 7 [json_name = "prefix", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.prefix_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string suffix = 8 [json_name = "suffix", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.suffix_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string contains = 9 [json_name = "contains", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.contains_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated string in = 10 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // repeated string not_in = 11 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // bool email = 12 [json_name = "email", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.email_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool hostname = 13 [json_name = "hostname", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.hostname_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ip = 14 [json_name = "ip", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ip_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv4 = 15 [json_name = "ipv4", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ipv4_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv6 = 16 [json_name = "ipv6", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.ipv6_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool uri = 17 [json_name = "uri", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.uri_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool uri_ref = 18 [json_name = "uriRef", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.uri_ref_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // optional uint64 len = 19 [json_name = "len", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.len_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.len_bytes_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // bool address = 21 [json_name = "address", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.address_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool uuid = 22 [json_name = "uuid", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.uuid_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // optional string not_contains = 23 [json_name = "notContains", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.not_contains_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.well_known_.well_known_regex_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kOpenEnum)},
    // optional bool strict = 25 [json_name = "strict"];
    {PROTOBUF_FIELD_OFFSET(StringRules, _impl_.strict_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\30\5\0\0\0\0\7\6\6\10\2\6\0\0\0\0\0\0\0\0\0\0\0\14\0\0\0\0\0\0\0\0"
    "buf.validate.StringRules"
    "const"
    "pattern"
    "prefix"
    "suffix"
    "contains"
    "in"
    "not_in"
    "not_contains"
  }},
};

::uint8_t* StringRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.StringRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_const_();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "buf.validate.StringRules.const");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_min_len(), target);
  }

  // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_max_len(), target);
  }

  // optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_min_bytes(), target);
  }

  // optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_max_bytes(), target);
  }

  // optional string pattern = 6 [json_name = "pattern", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_pattern();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "buf.validate.StringRules.pattern");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // optional string prefix = 7 [json_name = "prefix", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_prefix();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "buf.validate.StringRules.prefix");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // optional string suffix = 8 [json_name = "suffix", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_suffix();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "buf.validate.StringRules.suffix");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // optional string contains = 9 [json_name = "contains", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_contains();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "buf.validate.StringRules.contains");
    target = stream->WriteStringMaybeAliased(9, _s, target);
  }

  // repeated string in = 10 [json_name = "in", (.buf.validate.priv.field) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    const auto& s = this->_internal_in().Get(i);
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "buf.validate.StringRules.in");
    target = stream->WriteString(10, s, target);
  }

  // repeated string not_in = 11 [json_name = "notIn", (.buf.validate.priv.field) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    const auto& s = this->_internal_not_in().Get(i);
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "buf.validate.StringRules.not_in");
    target = stream->WriteString(11, s, target);
  }

  switch (well_known_case()) {
    case kEmail: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          12, this->_internal_email(), target);
      break;
    }
    case kHostname: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          13, this->_internal_hostname(), target);
      break;
    }
    case kIp: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          14, this->_internal_ip(), target);
      break;
    }
    case kIpv4: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          15, this->_internal_ipv4(), target);
      break;
    }
    case kIpv6: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          16, this->_internal_ipv6(), target);
      break;
    }
    case kUri: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          17, this->_internal_uri(), target);
      break;
    }
    case kUriRef: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          18, this->_internal_uri_ref(), target);
      break;
    }
    default:
      break;
  }
  // optional uint64 len = 19 [json_name = "len", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        19, this->_internal_len(), target);
  }

  // optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        20, this->_internal_len_bytes(), target);
  }

  switch (well_known_case()) {
    case kAddress: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          21, this->_internal_address(), target);
      break;
    }
    case kUuid: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          22, this->_internal_uuid(), target);
      break;
    }
    default:
      break;
  }
  // optional string not_contains = 23 [json_name = "notContains", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000020u) {
    const std::string& _s = this->_internal_not_contains();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "buf.validate.StringRules.not_contains");
    target = stream->WriteStringMaybeAliased(23, _s, target);
  }

  // .buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.priv.field) = {
  if (well_known_case() == kWellKnownRegex) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        24, this->_internal_well_known_regex(), target);
  }

  // optional bool strict = 25 [json_name = "strict"];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        25, this->_internal_strict(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.StringRules)
  return target;
}

::size_t StringRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.StringRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string in = 10 [json_name = "in", (.buf.validate.priv.field) = {
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_in().size());
  for (int i = 0, n = _internal_in().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_in().Get(i));
  }
  // repeated string not_in = 11 [json_name = "notIn", (.buf.validate.priv.field) = {
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_not_in().size());
  for (int i = 0, n = _internal_not_in().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_not_in().Get(i));
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_const_());
    }

    // optional string pattern = 6 [json_name = "pattern", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_pattern());
    }

    // optional string prefix = 7 [json_name = "prefix", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_prefix());
    }

    // optional string suffix = 8 [json_name = "suffix", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_suffix());
    }

    // optional string contains = 9 [json_name = "contains", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_contains());
    }

    // optional string not_contains = 23 [json_name = "notContains", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_not_contains());
    }

    // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_min_len());
    }

    // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_max_len());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_min_bytes());
    }

    // optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_max_bytes());
    }

    // optional uint64 len = 19 [json_name = "len", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this->_internal_len());
    }

    // optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this->_internal_len_bytes());
    }

    // optional bool strict = 25 [json_name = "strict"];
    if (cached_has_bits & 0x00001000u) {
      total_size += 3;
    }

  }
  switch (well_known_case()) {
    // bool email = 12 [json_name = "email", (.buf.validate.priv.field) = {
    case kEmail: {
      total_size += 2;
      break;
    }
    // bool hostname = 13 [json_name = "hostname", (.buf.validate.priv.field) = {
    case kHostname: {
      total_size += 2;
      break;
    }
    // bool ip = 14 [json_name = "ip", (.buf.validate.priv.field) = {
    case kIp: {
      total_size += 2;
      break;
    }
    // bool ipv4 = 15 [json_name = "ipv4", (.buf.validate.priv.field) = {
    case kIpv4: {
      total_size += 2;
      break;
    }
    // bool ipv6 = 16 [json_name = "ipv6", (.buf.validate.priv.field) = {
    case kIpv6: {
      total_size += 3;
      break;
    }
    // bool uri = 17 [json_name = "uri", (.buf.validate.priv.field) = {
    case kUri: {
      total_size += 3;
      break;
    }
    // bool uri_ref = 18 [json_name = "uriRef", (.buf.validate.priv.field) = {
    case kUriRef: {
      total_size += 3;
      break;
    }
    // bool address = 21 [json_name = "address", (.buf.validate.priv.field) = {
    case kAddress: {
      total_size += 3;
      break;
    }
    // bool uuid = 22 [json_name = "uuid", (.buf.validate.priv.field) = {
    case kUuid: {
      total_size += 3;
      break;
    }
    // .buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.priv.field) = {
    case kWellKnownRegex: {
      total_size += 2 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData StringRules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    StringRules::MergeImpl
};
const ::google::protobuf::Message::ClassData*StringRules::GetClassData() const { return &_class_data_; }


void StringRules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<StringRules*>(&to_msg);
  auto& from = static_cast<const StringRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.StringRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_const_(from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_pattern(from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_prefix(from._internal_prefix());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_suffix(from._internal_suffix());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_contains(from._internal_contains());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_not_contains(from._internal_not_contains());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.min_len_ = from._impl_.min_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.max_len_ = from._impl_.max_len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.min_bytes_ = from._impl_.min_bytes_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.max_bytes_ = from._impl_.max_bytes_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.len_bytes_ = from._impl_.len_bytes_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.strict_ = from._impl_.strict_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.well_known_case()) {
    case kEmail: {
      _this->_internal_set_email(from._internal_email());
      break;
    }
    case kHostname: {
      _this->_internal_set_hostname(from._internal_hostname());
      break;
    }
    case kIp: {
      _this->_internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _this->_internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _this->_internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case kUri: {
      _this->_internal_set_uri(from._internal_uri());
      break;
    }
    case kUriRef: {
      _this->_internal_set_uri_ref(from._internal_uri_ref());
      break;
    }
    case kAddress: {
      _this->_internal_set_address(from._internal_address());
      break;
    }
    case kUuid: {
      _this->_internal_set_uuid(from._internal_uuid());
      break;
    }
    case kWellKnownRegex: {
      _this->_internal_set_well_known_regex(from._internal_well_known_regex());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void StringRules::CopyFrom(const StringRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.StringRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool StringRules::IsInitialized() const {
  return true;
}

void StringRules::InternalSwap(StringRules* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.const__, lhs_arena,
                                       &other->_impl_.const__, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.pattern_, lhs_arena,
                                       &other->_impl_.pattern_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.prefix_, lhs_arena,
                                       &other->_impl_.prefix_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.suffix_, lhs_arena,
                                       &other->_impl_.suffix_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.contains_, lhs_arena,
                                       &other->_impl_.contains_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.not_contains_, lhs_arena,
                                       &other->_impl_.not_contains_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StringRules, _impl_.strict_)
      + sizeof(StringRules::_impl_.strict_)
      - PROTOBUF_FIELD_OFFSET(StringRules, _impl_.min_len_)>(
          reinterpret_cast<char*>(&_impl_.min_len_),
          reinterpret_cast<char*>(&other->_impl_.min_len_));
  swap(_impl_.well_known_, other->_impl_.well_known_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata StringRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[16]);
}
// ===================================================================

class BytesRules::_Internal {
 public:
  using HasBits = decltype(std::declval<BytesRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(BytesRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::BytesRules, _impl_._oneof_case_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_len(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_min_len(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_max_len(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pattern(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_prefix(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_suffix(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contains(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

BytesRules::BytesRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.BytesRules)
}
BytesRules::BytesRules(const BytesRules& from) : ::google::protobuf::Message() {
  BytesRules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      decltype(_impl_.const__){},
      decltype(_impl_.pattern_){},
      decltype(_impl_.prefix_){},
      decltype(_impl_.suffix_){},
      decltype(_impl_.contains_){},
      decltype(_impl_.min_len_){},
      decltype(_impl_.max_len_){},
      decltype(_impl_.len_){},
      decltype(_impl_.well_known_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  _impl_.const__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.const__.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.const__.Set(from._internal_const_(), _this->GetArenaForAllocation());
  }
  _impl_.pattern_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.pattern_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.pattern_.Set(from._internal_pattern(), _this->GetArenaForAllocation());
  }
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.prefix_.Set(from._internal_prefix(), _this->GetArenaForAllocation());
  }
  _impl_.suffix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.suffix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.suffix_.Set(from._internal_suffix(), _this->GetArenaForAllocation());
  }
  _impl_.contains_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.contains_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.contains_.Set(from._internal_contains(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.min_len_, &from._impl_.min_len_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.len_) -
    reinterpret_cast<char*>(&_impl_.min_len_)) + sizeof(_impl_.len_));
  clear_has_well_known();
  switch (from.well_known_case()) {
    case kIp: {
      _this->_internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _this->_internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _this->_internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.BytesRules)
}
inline void BytesRules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      decltype(_impl_.not_in_){arena},
      decltype(_impl_.const__){},
      decltype(_impl_.pattern_){},
      decltype(_impl_.prefix_){},
      decltype(_impl_.suffix_){},
      decltype(_impl_.contains_){},
      decltype(_impl_.min_len_){::uint64_t{0u}},
      decltype(_impl_.max_len_){::uint64_t{0u}},
      decltype(_impl_.len_){::uint64_t{0u}},
      decltype(_impl_.well_known_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _impl_.const__.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.const__.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pattern_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.pattern_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.prefix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.prefix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.suffix_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.suffix_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contains_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.contains_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_well_known();
}
BytesRules::~BytesRules() {
  // @@protoc_insertion_point(destructor:buf.validate.BytesRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void BytesRules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_in()->~RepeatedPtrField();
  _internal_mutable_not_in()->~RepeatedPtrField();
  _impl_.const__.Destroy();
  _impl_.pattern_.Destroy();
  _impl_.prefix_.Destroy();
  _impl_.suffix_.Destroy();
  _impl_.contains_.Destroy();
  if (has_well_known()) {
    clear_well_known();
  }
}
void BytesRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BytesRules::clear_well_known() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.BytesRules)
  switch (well_known_case()) {
    case kIp: {
      // No need to clear
      break;
    }
    case kIpv4: {
      // No need to clear
      break;
    }
    case kIpv6: {
      // No need to clear
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = WELL_KNOWN_NOT_SET;
}


PROTOBUF_NOINLINE void BytesRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.BytesRules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.const__.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.pattern_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.prefix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.suffix_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.contains_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.min_len_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.len_) -
        reinterpret_cast<char*>(&_impl_.min_len_)) + sizeof(_impl_.len_));
  }
  clear_well_known();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* BytesRules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 13, 0, 47, 2> BytesRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(BytesRules, _impl_._has_bits_),
    0, // no _extensions_
    13, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294959104,  // skipmap
    offsetof(decltype(_table_), field_entries),
    13,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_BytesRules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional bytes const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastBS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.const__)}},
    // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(BytesRules, _impl_.min_len_), 5>(),
     {16, 5, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.min_len_)}},
    // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(BytesRules, _impl_.max_len_), 6>(),
     {24, 6, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.max_len_)}},
    // optional string pattern = 4 [json_name = "pattern", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastUS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.pattern_)}},
    // optional bytes prefix = 5 [json_name = "prefix", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastBS1,
     {42, 2, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.prefix_)}},
    // optional bytes suffix = 6 [json_name = "suffix", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastBS1,
     {50, 3, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.suffix_)}},
    // optional bytes contains = 7 [json_name = "contains", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastBS1,
     {58, 4, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.contains_)}},
    // repeated bytes in = 8 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastBR1,
     {66, 63, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.in_)}},
    // repeated bytes not_in = 9 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastBR1,
     {74, 63, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.not_in_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint64 len = 13 [json_name = "len", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(BytesRules, _impl_.len_), 7>(),
     {104, 7, 0, PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.len_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional bytes const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.min_len_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.max_len_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional string pattern = 4 [json_name = "pattern", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.pattern_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional bytes prefix = 5 [json_name = "prefix", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.prefix_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes suffix = 6 [json_name = "suffix", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.suffix_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // optional bytes contains = 7 [json_name = "contains", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.contains_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBytes | ::_fl::kRepAString)},
    // repeated bytes in = 8 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // repeated bytes not_in = 9 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kBytes | ::_fl::kRepSString)},
    // bool ip = 10 [json_name = "ip", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.well_known_.ip_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv4 = 11 [json_name = "ipv4", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.well_known_.ipv4_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool ipv6 = 12 [json_name = "ipv6", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.well_known_.ipv6_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // optional uint64 len = 13 [json_name = "len", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.len_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
    "\27\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0"
    "buf.validate.BytesRules"
    "pattern"
  }},
};

::uint8_t* BytesRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.BytesRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_const_();
    target = stream->WriteBytesMaybeAliased(1, _s, target);
  }

  // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_min_len(), target);
  }

  // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_max_len(), target);
  }

  // optional string pattern = 4 [json_name = "pattern", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_pattern();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "buf.validate.BytesRules.pattern");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional bytes prefix = 5 [json_name = "prefix", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_prefix();
    target = stream->WriteBytesMaybeAliased(5, _s, target);
  }

  // optional bytes suffix = 6 [json_name = "suffix", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_suffix();
    target = stream->WriteBytesMaybeAliased(6, _s, target);
  }

  // optional bytes contains = 7 [json_name = "contains", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_contains();
    target = stream->WriteBytesMaybeAliased(7, _s, target);
  }

  // repeated bytes in = 8 [json_name = "in", (.buf.validate.priv.field) = {
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    const auto& s = this->_internal_in().Get(i);
    target = stream->WriteBytes(8, s, target);
  }

  // repeated bytes not_in = 9 [json_name = "notIn", (.buf.validate.priv.field) = {
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    const auto& s = this->_internal_not_in().Get(i);
    target = stream->WriteBytes(9, s, target);
  }

  switch (well_known_case()) {
    case kIp: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          10, this->_internal_ip(), target);
      break;
    }
    case kIpv4: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          11, this->_internal_ipv4(), target);
      break;
    }
    case kIpv6: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          12, this->_internal_ipv6(), target);
      break;
    }
    default:
      break;
  }
  // optional uint64 len = 13 [json_name = "len", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        13, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.BytesRules)
  return target;
}

::size_t BytesRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.BytesRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes in = 8 [json_name = "in", (.buf.validate.priv.field) = {
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_in().size());
  for (int i = 0, n = _internal_in().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
        _internal_in().Get(i));
  }
  // repeated bytes not_in = 9 [json_name = "notIn", (.buf.validate.priv.field) = {
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_not_in().size());
  for (int i = 0, n = _internal_not_in().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
        _internal_not_in().Get(i));
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_const_());
    }

    // optional string pattern = 4 [json_name = "pattern", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this->_internal_pattern());
    }

    // optional bytes prefix = 5 [json_name = "prefix", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_prefix());
    }

    // optional bytes suffix = 6 [json_name = "suffix", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_suffix());
    }

    // optional bytes contains = 7 [json_name = "contains", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::BytesSize(
                                      this->_internal_contains());
    }

    // optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_min_len());
    }

    // optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_max_len());
    }

    // optional uint64 len = 13 [json_name = "len", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_len());
    }

  }
  switch (well_known_case()) {
    // bool ip = 10 [json_name = "ip", (.buf.validate.priv.field) = {
    case kIp: {
      total_size += 2;
      break;
    }
    // bool ipv4 = 11 [json_name = "ipv4", (.buf.validate.priv.field) = {
    case kIpv4: {
      total_size += 2;
      break;
    }
    // bool ipv6 = 12 [json_name = "ipv6", (.buf.validate.priv.field) = {
    case kIpv6: {
      total_size += 2;
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData BytesRules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    BytesRules::MergeImpl
};
const ::google::protobuf::Message::ClassData*BytesRules::GetClassData() const { return &_class_data_; }


void BytesRules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<BytesRules*>(&to_msg);
  auto& from = static_cast<const BytesRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.BytesRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_const_(from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_pattern(from._internal_pattern());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_prefix(from._internal_prefix());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_suffix(from._internal_suffix());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_contains(from._internal_contains());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.min_len_ = from._impl_.min_len_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.max_len_ = from._impl_.max_len_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.len_ = from._impl_.len_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.well_known_case()) {
    case kIp: {
      _this->_internal_set_ip(from._internal_ip());
      break;
    }
    case kIpv4: {
      _this->_internal_set_ipv4(from._internal_ipv4());
      break;
    }
    case kIpv6: {
      _this->_internal_set_ipv6(from._internal_ipv6());
      break;
    }
    case WELL_KNOWN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void BytesRules::CopyFrom(const BytesRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.BytesRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool BytesRules::IsInitialized() const {
  return true;
}

void BytesRules::InternalSwap(BytesRules* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.const__, lhs_arena,
                                       &other->_impl_.const__, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.pattern_, lhs_arena,
                                       &other->_impl_.pattern_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.prefix_, lhs_arena,
                                       &other->_impl_.prefix_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.suffix_, lhs_arena,
                                       &other->_impl_.suffix_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.contains_, lhs_arena,
                                       &other->_impl_.contains_, rhs_arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.len_)
      + sizeof(BytesRules::_impl_.len_)
      - PROTOBUF_FIELD_OFFSET(BytesRules, _impl_.min_len_)>(
          reinterpret_cast<char*>(&_impl_.min_len_),
          reinterpret_cast<char*>(&other->_impl_.min_len_));
  swap(_impl_.well_known_, other->_impl_.well_known_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata BytesRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[17]);
}
// ===================================================================

class EnumRules::_Internal {
 public:
  using HasBits = decltype(std::declval<EnumRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EnumRules, _impl_._has_bits_);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_defined_only(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

EnumRules::EnumRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.EnumRules)
}
EnumRules::EnumRules(const EnumRules& from) : ::google::protobuf::Message() {
  EnumRules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){},
      decltype(_impl_.defined_only_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  ::memcpy(&_impl_.const__, &from._impl_.const__,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.defined_only_) -
    reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.defined_only_));

  // @@protoc_insertion_point(copy_constructor:buf.validate.EnumRules)
}
inline void EnumRules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      /* _impl_._in_cached_byte_size_ = */ {0},
      decltype(_impl_.not_in_){arena},
      /* _impl_._not_in_cached_byte_size_ = */ {0},
      decltype(_impl_.const__){0},
      decltype(_impl_.defined_only_){false},
  };
}
EnumRules::~EnumRules() {
  // @@protoc_insertion_point(destructor:buf.validate.EnumRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void EnumRules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedField();
  _impl_.not_in_.~RepeatedField();
}
void EnumRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void EnumRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.EnumRules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.const__, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.defined_only_) -
        reinterpret_cast<char*>(&_impl_.const__)) + sizeof(_impl_.defined_only_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* EnumRules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> EnumRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(EnumRules, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_EnumRules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated int32 not_in = 4 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastV32P1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.not_in_)}},
    // optional int32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(EnumRules, _impl_.const__), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.const__)}},
    // optional bool defined_only = 2 [json_name = "definedOnly"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(EnumRules, _impl_.defined_only_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.defined_only_)}},
    // repeated int32 in = 3 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastV32P1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional int32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kInt32)},
    // optional bool defined_only = 2 [json_name = "definedOnly"];
    {PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.defined_only_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated int32 in = 3 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
    // repeated int32 not_in = 4 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.not_in_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedInt32)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* EnumRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.EnumRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
        WriteInt32ToArrayWithField<1>(
            stream, this->_internal_const_(), target);
  }

  // optional bool defined_only = 2 [json_name = "definedOnly"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_defined_only(), target);
  }

  // repeated int32 in = 3 [json_name = "in", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(3, _internal_in(),
                                                 byte_size, target);
    }
  }

  // repeated int32 not_in = 4 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    int byte_size = _impl_._not_in_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(4, _internal_not_in(),
                                                 byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.EnumRules)
  return target;
}

::size_t EnumRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.EnumRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 in = 3 [json_name = "in", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_in())
    ;
    _impl_._in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  // repeated int32 not_in = 4 [json_name = "notIn", (.buf.validate.priv.field) = {
  {
    std::size_t data_size = ::_pbi::WireFormatLite::Int32Size(
        this->_internal_not_in())
    ;
    _impl_._not_in_cached_byte_size_.Set(::_pbi::ToCachedSize(data_size));
    std::size_t tag_size = data_size == 0
        ? 0
        : 1 + ::_pbi::WireFormatLite::Int32Size(
                            static_cast<int32_t>(data_size))
    ;
    total_size += tag_size + data_size;
  }
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 const = 1 [json_name = "const", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_const_());
    }

    // optional bool defined_only = 2 [json_name = "definedOnly"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 2;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData EnumRules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    EnumRules::MergeImpl
};
const ::google::protobuf::Message::ClassData*EnumRules::GetClassData() const { return &_class_data_; }


void EnumRules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<EnumRules*>(&to_msg);
  auto& from = static_cast<const EnumRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.EnumRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.const__ = from._impl_.const__;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.defined_only_ = from._impl_.defined_only_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void EnumRules::CopyFrom(const EnumRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.EnumRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool EnumRules::IsInitialized() const {
  return true;
}

void EnumRules::InternalSwap(EnumRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.defined_only_)
      + sizeof(EnumRules::_impl_.defined_only_)
      - PROTOBUF_FIELD_OFFSET(EnumRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
}

::google::protobuf::Metadata EnumRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[18]);
}
// ===================================================================

class RepeatedRules::_Internal {
 public:
  using HasBits = decltype(std::declval<RepeatedRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_._has_bits_);
  static void set_has_min_items(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_items(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_unique(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::buf::validate::FieldConstraints& items(const RepeatedRules* msg);
  static void set_has_items(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::buf::validate::FieldConstraints& RepeatedRules::_Internal::items(const RepeatedRules* msg) {
  return *msg->_impl_.items_;
}
RepeatedRules::RepeatedRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.RepeatedRules)
}
RepeatedRules::RepeatedRules(const RepeatedRules& from) : ::google::protobuf::Message() {
  RepeatedRules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.items_){nullptr},
      decltype(_impl_.min_items_){},
      decltype(_impl_.max_items_){},
      decltype(_impl_.unique_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.items_ = new ::buf::validate::FieldConstraints(*from._impl_.items_);
  }
  ::memcpy(&_impl_.min_items_, &from._impl_.min_items_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.unique_) -
    reinterpret_cast<char*>(&_impl_.min_items_)) + sizeof(_impl_.unique_));

  // @@protoc_insertion_point(copy_constructor:buf.validate.RepeatedRules)
}
inline void RepeatedRules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.items_){nullptr},
      decltype(_impl_.min_items_){::uint64_t{0u}},
      decltype(_impl_.max_items_){::uint64_t{0u}},
      decltype(_impl_.unique_){false},
  };
}
RepeatedRules::~RepeatedRules() {
  // @@protoc_insertion_point(destructor:buf.validate.RepeatedRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void RepeatedRules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.items_;
}
void RepeatedRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void RepeatedRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.RepeatedRules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.items_ != nullptr);
    _impl_.items_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.min_items_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.unique_) -
        reinterpret_cast<char*>(&_impl_.min_items_)) + sizeof(_impl_.unique_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* RepeatedRules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 1, 0, 2> RepeatedRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_RepeatedRules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional .buf.validate.FieldConstraints items = 4 [json_name = "items"];
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.items_)}},
    // optional uint64 min_items = 1 [json_name = "minItems", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(RepeatedRules, _impl_.min_items_), 1>(),
     {8, 1, 0, PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.min_items_)}},
    // optional uint64 max_items = 2 [json_name = "maxItems", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(RepeatedRules, _impl_.max_items_), 2>(),
     {16, 2, 0, PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.max_items_)}},
    // optional bool unique = 3 [json_name = "unique", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(RepeatedRules, _impl_.unique_), 3>(),
     {24, 3, 0, PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.unique_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint64 min_items = 1 [json_name = "minItems", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.min_items_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_items = 2 [json_name = "maxItems", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.max_items_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional bool unique = 3 [json_name = "unique", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.unique_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional .buf.validate.FieldConstraints items = 4 [json_name = "items"];
    {PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.items_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::buf::validate::FieldConstraints>()},
  }}, {{
  }},
};

::uint8_t* RepeatedRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.RepeatedRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 min_items = 1 [json_name = "minItems", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_min_items(), target);
  }

  // optional uint64 max_items = 2 [json_name = "maxItems", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_max_items(), target);
  }

  // optional bool unique = 3 [json_name = "unique", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        3, this->_internal_unique(), target);
  }

  // optional .buf.validate.FieldConstraints items = 4 [json_name = "items"];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::items(this),
        _Internal::items(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.RepeatedRules)
  return target;
}

::size_t RepeatedRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.RepeatedRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .buf.validate.FieldConstraints items = 4 [json_name = "items"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.items_);
    }

    // optional uint64 min_items = 1 [json_name = "minItems", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_min_items());
    }

    // optional uint64 max_items = 2 [json_name = "maxItems", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_max_items());
    }

    // optional bool unique = 3 [json_name = "unique", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000008u) {
      total_size += 2;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData RepeatedRules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    RepeatedRules::MergeImpl
};
const ::google::protobuf::Message::ClassData*RepeatedRules::GetClassData() const { return &_class_data_; }


void RepeatedRules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<RepeatedRules*>(&to_msg);
  auto& from = static_cast<const RepeatedRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.RepeatedRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_items()->::buf::validate::FieldConstraints::MergeFrom(
          from._internal_items());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.min_items_ = from._impl_.min_items_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.max_items_ = from._impl_.max_items_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.unique_ = from._impl_.unique_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RepeatedRules::CopyFrom(const RepeatedRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.RepeatedRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool RepeatedRules::IsInitialized() const {
  return true;
}

void RepeatedRules::InternalSwap(RepeatedRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.unique_)
      + sizeof(RepeatedRules::_impl_.unique_)
      - PROTOBUF_FIELD_OFFSET(RepeatedRules, _impl_.items_)>(
          reinterpret_cast<char*>(&_impl_.items_),
          reinterpret_cast<char*>(&other->_impl_.items_));
}

::google::protobuf::Metadata RepeatedRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[19]);
}
// ===================================================================

class MapRules::_Internal {
 public:
  using HasBits = decltype(std::declval<MapRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(MapRules, _impl_._has_bits_);
  static void set_has_min_pairs(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_pairs(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::buf::validate::FieldConstraints& keys(const MapRules* msg);
  static void set_has_keys(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::buf::validate::FieldConstraints& values(const MapRules* msg);
  static void set_has_values(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::buf::validate::FieldConstraints& MapRules::_Internal::keys(const MapRules* msg) {
  return *msg->_impl_.keys_;
}
const ::buf::validate::FieldConstraints& MapRules::_Internal::values(const MapRules* msg) {
  return *msg->_impl_.values_;
}
MapRules::MapRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.MapRules)
}
MapRules::MapRules(const MapRules& from) : ::google::protobuf::Message() {
  MapRules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.keys_){nullptr},
      decltype(_impl_.values_){nullptr},
      decltype(_impl_.min_pairs_){},
      decltype(_impl_.max_pairs_){},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.keys_ = new ::buf::validate::FieldConstraints(*from._impl_.keys_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.values_ = new ::buf::validate::FieldConstraints(*from._impl_.values_);
  }
  ::memcpy(&_impl_.min_pairs_, &from._impl_.min_pairs_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.max_pairs_) -
    reinterpret_cast<char*>(&_impl_.min_pairs_)) + sizeof(_impl_.max_pairs_));

  // @@protoc_insertion_point(copy_constructor:buf.validate.MapRules)
}
inline void MapRules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.keys_){nullptr},
      decltype(_impl_.values_){nullptr},
      decltype(_impl_.min_pairs_){::uint64_t{0u}},
      decltype(_impl_.max_pairs_){::uint64_t{0u}},
  };
}
MapRules::~MapRules() {
  // @@protoc_insertion_point(destructor:buf.validate.MapRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void MapRules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.keys_;
  if (this != internal_default_instance()) delete _impl_.values_;
}
void MapRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void MapRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.MapRules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.keys_ != nullptr);
      _impl_.keys_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.values_ != nullptr);
      _impl_.values_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.min_pairs_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.max_pairs_) -
        reinterpret_cast<char*>(&_impl_.min_pairs_)) + sizeof(_impl_.max_pairs_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* MapRules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 4, 2, 0, 2> MapRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(MapRules, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967268,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_MapRules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // optional uint64 min_pairs = 1 [json_name = "minPairs", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(MapRules, _impl_.min_pairs_), 2>(),
     {8, 2, 0, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.min_pairs_)}},
    // optional uint64 max_pairs = 2 [json_name = "maxPairs", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(MapRules, _impl_.max_pairs_), 3>(),
     {16, 3, 0, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.max_pairs_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional .buf.validate.FieldConstraints keys = 4 [json_name = "keys"];
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.keys_)}},
    // optional .buf.validate.FieldConstraints values = 5 [json_name = "values"];
    {::_pbi::TcParser::FastMtS1,
     {42, 1, 1, PROTOBUF_FIELD_OFFSET(MapRules, _impl_.values_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // optional uint64 min_pairs = 1 [json_name = "minPairs", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.min_pairs_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 max_pairs = 2 [json_name = "maxPairs", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.max_pairs_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional .buf.validate.FieldConstraints keys = 4 [json_name = "keys"];
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.keys_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // optional .buf.validate.FieldConstraints values = 5 [json_name = "values"];
    {PROTOBUF_FIELD_OFFSET(MapRules, _impl_.values_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::buf::validate::FieldConstraints>()},
    {::_pbi::TcParser::GetTable<::buf::validate::FieldConstraints>()},
  }}, {{
  }},
};

::uint8_t* MapRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.MapRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 min_pairs = 1 [json_name = "minPairs", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_min_pairs(), target);
  }

  // optional uint64 max_pairs = 2 [json_name = "maxPairs", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_max_pairs(), target);
  }

  // optional .buf.validate.FieldConstraints keys = 4 [json_name = "keys"];
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::keys(this),
        _Internal::keys(this).GetCachedSize(), target, stream);
  }

  // optional .buf.validate.FieldConstraints values = 5 [json_name = "values"];
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::values(this),
        _Internal::values(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.MapRules)
  return target;
}

::size_t MapRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.MapRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .buf.validate.FieldConstraints keys = 4 [json_name = "keys"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.keys_);
    }

    // optional .buf.validate.FieldConstraints values = 5 [json_name = "values"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.values_);
    }

    // optional uint64 min_pairs = 1 [json_name = "minPairs", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_min_pairs());
    }

    // optional uint64 max_pairs = 2 [json_name = "maxPairs", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_max_pairs());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData MapRules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    MapRules::MergeImpl
};
const ::google::protobuf::Message::ClassData*MapRules::GetClassData() const { return &_class_data_; }


void MapRules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<MapRules*>(&to_msg);
  auto& from = static_cast<const MapRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.MapRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_keys()->::buf::validate::FieldConstraints::MergeFrom(
          from._internal_keys());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_values()->::buf::validate::FieldConstraints::MergeFrom(
          from._internal_values());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.min_pairs_ = from._impl_.min_pairs_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.max_pairs_ = from._impl_.max_pairs_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void MapRules::CopyFrom(const MapRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.MapRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool MapRules::IsInitialized() const {
  return true;
}

void MapRules::InternalSwap(MapRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MapRules, _impl_.max_pairs_)
      + sizeof(MapRules::_impl_.max_pairs_)
      - PROTOBUF_FIELD_OFFSET(MapRules, _impl_.keys_)>(
          reinterpret_cast<char*>(&_impl_.keys_),
          reinterpret_cast<char*>(&other->_impl_.keys_));
}

::google::protobuf::Metadata MapRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[20]);
}
// ===================================================================

class AnyRules::_Internal {
 public:
};

AnyRules::AnyRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.AnyRules)
}
AnyRules::AnyRules(const AnyRules& from) : ::google::protobuf::Message() {
  AnyRules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.in_){from._impl_.in_},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      /*decltype(_impl_._cached_size_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);

  // @@protoc_insertion_point(copy_constructor:buf.validate.AnyRules)
}
inline void AnyRules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.in_){arena},
      decltype(_impl_.not_in_){arena},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
AnyRules::~AnyRules() {
  // @@protoc_insertion_point(destructor:buf.validate.AnyRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AnyRules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_in()->~RepeatedPtrField();
  _internal_mutable_not_in()->~RepeatedPtrField();
}
void AnyRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void AnyRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.AnyRules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* AnyRules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 38, 2> AnyRules::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967289,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AnyRules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated string in = 2 [json_name = "in"];
    {::_pbi::TcParser::FastUR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.in_)}},
    // repeated string not_in = 3 [json_name = "notIn"];
    {::_pbi::TcParser::FastUR1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.not_in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated string in = 2 [json_name = "in"];
    {PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.in_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // repeated string not_in = 3 [json_name = "notIn"];
    {PROTOBUF_FIELD_OFFSET(AnyRules, _impl_.not_in_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
  }},
  // no aux_entries
  {{
    "\25\2\6\0\0\0\0\0"
    "buf.validate.AnyRules"
    "in"
    "not_in"
  }},
};

::uint8_t* AnyRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.AnyRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated string in = 2 [json_name = "in"];
  for (int i = 0, n = this->_internal_in_size(); i < n; ++i) {
    const auto& s = this->_internal_in().Get(i);
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "buf.validate.AnyRules.in");
    target = stream->WriteString(2, s, target);
  }

  // repeated string not_in = 3 [json_name = "notIn"];
  for (int i = 0, n = this->_internal_not_in_size(); i < n; ++i) {
    const auto& s = this->_internal_not_in().Get(i);
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "buf.validate.AnyRules.not_in");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.AnyRules)
  return target;
}

::size_t AnyRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.AnyRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string in = 2 [json_name = "in"];
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_in().size());
  for (int i = 0, n = _internal_in().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_in().Get(i));
  }
  // repeated string not_in = 3 [json_name = "notIn"];
  total_size += 1 * ::google::protobuf::internal::FromIntSize(_internal_not_in().size());
  for (int i = 0, n = _internal_not_in().size(); i < n; ++i) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
        _internal_not_in().Get(i));
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData AnyRules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    AnyRules::MergeImpl
};
const ::google::protobuf::Message::ClassData*AnyRules::GetClassData() const { return &_class_data_; }


void AnyRules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<AnyRules*>(&to_msg);
  auto& from = static_cast<const AnyRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.AnyRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AnyRules::CopyFrom(const AnyRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.AnyRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AnyRules::IsInitialized() const {
  return true;
}

void AnyRules::InternalSwap(AnyRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
}

::google::protobuf::Metadata AnyRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[21]);
}
// ===================================================================

class DurationRules::_Internal {
 public:
  using HasBits = decltype(std::declval<DurationRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(DurationRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::DurationRules, _impl_._oneof_case_);
  static const ::google::protobuf::Duration& const_(const DurationRules* msg);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::google::protobuf::Duration& lt(const DurationRules* msg);
  static const ::google::protobuf::Duration& lte(const DurationRules* msg);
  static const ::google::protobuf::Duration& gt(const DurationRules* msg);
  static const ::google::protobuf::Duration& gte(const DurationRules* msg);
};

const ::google::protobuf::Duration& DurationRules::_Internal::const_(const DurationRules* msg) {
  return *msg->_impl_.const__;
}
const ::google::protobuf::Duration& DurationRules::_Internal::lt(const DurationRules* msg) {
  return *msg->_impl_.less_than_.lt_;
}
const ::google::protobuf::Duration& DurationRules::_Internal::lte(const DurationRules* msg) {
  return *msg->_impl_.less_than_.lte_;
}
const ::google::protobuf::Duration& DurationRules::_Internal::gt(const DurationRules* msg) {
  return *msg->_impl_.greater_than_.gt_;
}
const ::google::protobuf::Duration& DurationRules::_Internal::gte(const DurationRules* msg) {
  return *msg->_impl_.greater_than_.gte_;
}
void DurationRules::clear_const_() {
  if (_impl_.const__ != nullptr) _impl_.const__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void DurationRules::set_allocated_lt(::google::protobuf::Duration* lt) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_less_than();
  if (lt) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(
                reinterpret_cast<::google::protobuf::MessageLite*>(lt));
    if (message_arena != submessage_arena) {
      lt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lt, submessage_arena);
    }
    set_has_lt();
    _impl_.less_than_.lt_ = lt;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.lt)
}
void DurationRules::clear_lt() {
  if (less_than_case() == kLt) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.less_than_.lt_;
    }
    clear_has_less_than();
  }
}
void DurationRules::set_allocated_lte(::google::protobuf::Duration* lte) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_less_than();
  if (lte) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(
                reinterpret_cast<::google::protobuf::MessageLite*>(lte));
    if (message_arena != submessage_arena) {
      lte = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lte, submessage_arena);
    }
    set_has_lte();
    _impl_.less_than_.lte_ = lte;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.lte)
}
void DurationRules::clear_lte() {
  if (less_than_case() == kLte) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.less_than_.lte_;
    }
    clear_has_less_than();
  }
}
void DurationRules::set_allocated_gt(::google::protobuf::Duration* gt) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_greater_than();
  if (gt) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(
                reinterpret_cast<::google::protobuf::MessageLite*>(gt));
    if (message_arena != submessage_arena) {
      gt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gt, submessage_arena);
    }
    set_has_gt();
    _impl_.greater_than_.gt_ = gt;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.gt)
}
void DurationRules::clear_gt() {
  if (greater_than_case() == kGt) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.greater_than_.gt_;
    }
    clear_has_greater_than();
  }
}
void DurationRules::set_allocated_gte(::google::protobuf::Duration* gte) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_greater_than();
  if (gte) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(
                reinterpret_cast<::google::protobuf::MessageLite*>(gte));
    if (message_arena != submessage_arena) {
      gte = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gte, submessage_arena);
    }
    set_has_gte();
    _impl_.greater_than_.gte_ = gte;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.DurationRules.gte)
}
void DurationRules::clear_gte() {
  if (greater_than_case() == kGte) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.greater_than_.gte_;
    }
    clear_has_greater_than();
  }
}
void DurationRules::clear_in() {
  _internal_mutable_in()->Clear();
}
void DurationRules::clear_not_in() {
  _internal_mutable_not_in()->Clear();
}
DurationRules::DurationRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.DurationRules)
}
DurationRules::DurationRules(const DurationRules& from) : ::google::protobuf::Message() {
  DurationRules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){from._impl_.in_},
      decltype(_impl_.not_in_){from._impl_.not_in_},
      decltype(_impl_.const__){nullptr},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.const__ = new ::google::protobuf::Duration(*from._impl_.const__);
  }
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_mutable_lt()->::google::protobuf::Duration::MergeFrom(
          from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_mutable_lte()->::google::protobuf::Duration::MergeFrom(
          from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_mutable_gt()->::google::protobuf::Duration::MergeFrom(
          from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_mutable_gte()->::google::protobuf::Duration::MergeFrom(
          from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.DurationRules)
}
inline void DurationRules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.in_){arena},
      decltype(_impl_.not_in_){arena},
      decltype(_impl_.const__){nullptr},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
DurationRules::~DurationRules() {
  // @@protoc_insertion_point(destructor:buf.validate.DurationRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void DurationRules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.in_.~RepeatedPtrField();
  _impl_.not_in_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.const__;
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void DurationRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DurationRules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.DurationRules)
  switch (less_than_case()) {
    case kLt: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.less_than_.lt_;
      }
      break;
    }
    case kLte: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.less_than_.lte_;
      }
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void DurationRules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.DurationRules)
  switch (greater_than_case()) {
    case kGt: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.greater_than_.gt_;
      }
      break;
    }
    case kGte: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.greater_than_.gte_;
      }
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void DurationRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.DurationRules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_in()->Clear();
  _internal_mutable_not_in()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.const__ != nullptr);
    _impl_.const__->Clear();
  }
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* DurationRules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 7, 7, 0, 2> DurationRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DurationRules, _impl_._has_bits_),
    0, // no _extensions_
    8, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967041,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_DurationRules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastMtR1,
     {66, 63, 6, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.not_in_)}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional .google.protobuf.Duration const = 2 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.const__)}},
    // repeated .google.protobuf.Duration in = 7 [json_name = "in", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastMtR1,
     {58, 63, 5, PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.in_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .google.protobuf.Duration const = 2 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Duration lt = 3 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Duration lte = 4 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Duration gt = 5 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Duration gte = 6 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Duration in = 7 [json_name = "in", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.in_), -1, 5,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(DurationRules, _impl_.not_in_), -1, 6,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
  }}, {{
  }},
};

::uint8_t* DurationRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.DurationRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .google.protobuf.Duration const = 2 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::const_(this),
        _Internal::const_(this).GetCachedSize(), target, stream);
  }

  switch (less_than_case()) {
    case kLt: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::lt(this),
          _Internal::lt(this).GetCachedSize(), target, stream);
      break;
    }
    case kLte: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::lte(this),
          _Internal::lte(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::gt(this),
          _Internal::gt(this).GetCachedSize(), target, stream);
      break;
    }
    case kGte: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::gte(this),
          _Internal::gte(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // repeated .google.protobuf.Duration in = 7 [json_name = "in", (.buf.validate.priv.field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_in_size()); i < n; i++) {
    const auto& repfield = this->_internal_in().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn", (.buf.validate.priv.field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_not_in_size()); i < n; i++) {
    const auto& repfield = this->_internal_not_in().Get(i);
    target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.DurationRules)
  return target;
}

::size_t DurationRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.DurationRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .google.protobuf.Duration in = 7 [json_name = "in", (.buf.validate.priv.field) = {
  total_size += 1UL * this->_internal_in_size();
  for (const auto& msg : this->_internal_in()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // repeated .google.protobuf.Duration not_in = 8 [json_name = "notIn", (.buf.validate.priv.field) = {
  total_size += 1UL * this->_internal_not_in_size();
  for (const auto& msg : this->_internal_not_in()) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
  }
  // optional .google.protobuf.Duration const = 2 [json_name = "const", (.buf.validate.priv.field) = {
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *_impl_.const__);
  }

  switch (less_than_case()) {
    // .google.protobuf.Duration lt = 3 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.less_than_.lt_);
      break;
    }
    // .google.protobuf.Duration lte = 4 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.less_than_.lte_);
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // .google.protobuf.Duration gt = 5 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.greater_than_.gt_);
      break;
    }
    // .google.protobuf.Duration gte = 6 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.greater_than_.gte_);
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData DurationRules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    DurationRules::MergeImpl
};
const ::google::protobuf::Message::ClassData*DurationRules::GetClassData() const { return &_class_data_; }


void DurationRules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<DurationRules*>(&to_msg);
  auto& from = static_cast<const DurationRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.DurationRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_in()->MergeFrom(from._internal_in());
  _this->_internal_mutable_not_in()->MergeFrom(from._internal_not_in());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_const_()->::google::protobuf::Duration::MergeFrom(
        from._internal_const_());
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_mutable_lt()->::google::protobuf::Duration::MergeFrom(
          from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_mutable_lte()->::google::protobuf::Duration::MergeFrom(
          from._internal_lte());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_mutable_gt()->::google::protobuf::Duration::MergeFrom(
          from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_mutable_gte()->::google::protobuf::Duration::MergeFrom(
          from._internal_gte());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DurationRules::CopyFrom(const DurationRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.DurationRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool DurationRules::IsInitialized() const {
  return true;
}

void DurationRules::InternalSwap(DurationRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.in_.InternalSwap(&other->_impl_.in_);
  _impl_.not_in_.InternalSwap(&other->_impl_.not_in_);
  swap(_impl_.const__, other->_impl_.const__);
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata DurationRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[22]);
}
// ===================================================================

class TimestampRules::_Internal {
 public:
  using HasBits = decltype(std::declval<TimestampRules>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::buf::validate::TimestampRules, _impl_._oneof_case_);
  static const ::google::protobuf::Timestamp& const_(const TimestampRules* msg);
  static void set_has_const_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::google::protobuf::Timestamp& lt(const TimestampRules* msg);
  static const ::google::protobuf::Timestamp& lte(const TimestampRules* msg);
  static const ::google::protobuf::Timestamp& gt(const TimestampRules* msg);
  static const ::google::protobuf::Timestamp& gte(const TimestampRules* msg);
  static const ::google::protobuf::Duration& within(const TimestampRules* msg);
  static void set_has_within(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::google::protobuf::Timestamp& TimestampRules::_Internal::const_(const TimestampRules* msg) {
  return *msg->_impl_.const__;
}
const ::google::protobuf::Timestamp& TimestampRules::_Internal::lt(const TimestampRules* msg) {
  return *msg->_impl_.less_than_.lt_;
}
const ::google::protobuf::Timestamp& TimestampRules::_Internal::lte(const TimestampRules* msg) {
  return *msg->_impl_.less_than_.lte_;
}
const ::google::protobuf::Timestamp& TimestampRules::_Internal::gt(const TimestampRules* msg) {
  return *msg->_impl_.greater_than_.gt_;
}
const ::google::protobuf::Timestamp& TimestampRules::_Internal::gte(const TimestampRules* msg) {
  return *msg->_impl_.greater_than_.gte_;
}
const ::google::protobuf::Duration& TimestampRules::_Internal::within(const TimestampRules* msg) {
  return *msg->_impl_.within_;
}
void TimestampRules::clear_const_() {
  if (_impl_.const__ != nullptr) _impl_.const__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void TimestampRules::set_allocated_lt(::google::protobuf::Timestamp* lt) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_less_than();
  if (lt) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(
                reinterpret_cast<::google::protobuf::MessageLite*>(lt));
    if (message_arena != submessage_arena) {
      lt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lt, submessage_arena);
    }
    set_has_lt();
    _impl_.less_than_.lt_ = lt;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.lt)
}
void TimestampRules::clear_lt() {
  if (less_than_case() == kLt) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.less_than_.lt_;
    }
    clear_has_less_than();
  }
}
void TimestampRules::set_allocated_lte(::google::protobuf::Timestamp* lte) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_less_than();
  if (lte) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(
                reinterpret_cast<::google::protobuf::MessageLite*>(lte));
    if (message_arena != submessage_arena) {
      lte = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lte, submessage_arena);
    }
    set_has_lte();
    _impl_.less_than_.lte_ = lte;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.lte)
}
void TimestampRules::clear_lte() {
  if (less_than_case() == kLte) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.less_than_.lte_;
    }
    clear_has_less_than();
  }
}
void TimestampRules::set_allocated_gt(::google::protobuf::Timestamp* gt) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_greater_than();
  if (gt) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(
                reinterpret_cast<::google::protobuf::MessageLite*>(gt));
    if (message_arena != submessage_arena) {
      gt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gt, submessage_arena);
    }
    set_has_gt();
    _impl_.greater_than_.gt_ = gt;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.gt)
}
void TimestampRules::clear_gt() {
  if (greater_than_case() == kGt) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.greater_than_.gt_;
    }
    clear_has_greater_than();
  }
}
void TimestampRules::set_allocated_gte(::google::protobuf::Timestamp* gte) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  clear_greater_than();
  if (gte) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(
                reinterpret_cast<::google::protobuf::MessageLite*>(gte));
    if (message_arena != submessage_arena) {
      gte = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gte, submessage_arena);
    }
    set_has_gte();
    _impl_.greater_than_.gte_ = gte;
  }
  // @@protoc_insertion_point(field_set_allocated:buf.validate.TimestampRules.gte)
}
void TimestampRules::clear_gte() {
  if (greater_than_case() == kGte) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.greater_than_.gte_;
    }
    clear_has_greater_than();
  }
}
void TimestampRules::clear_within() {
  if (_impl_.within_ != nullptr) _impl_.within_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
TimestampRules::TimestampRules(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:buf.validate.TimestampRules)
}
TimestampRules::TimestampRules(const TimestampRules& from) : ::google::protobuf::Message() {
  TimestampRules* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.const__){nullptr},
      decltype(_impl_.within_){nullptr},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.const__ = new ::google::protobuf::Timestamp(*from._impl_.const__);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.within_ = new ::google::protobuf::Duration(*from._impl_.within_);
  }
  clear_has_less_than();
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_mutable_lt()->::google::protobuf::Timestamp::MergeFrom(
          from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_mutable_lte()->::google::protobuf::Timestamp::MergeFrom(
          from._internal_lte());
      break;
    }
    case kLtNow: {
      _this->_internal_set_lt_now(from._internal_lt_now());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  clear_has_greater_than();
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_mutable_gt()->::google::protobuf::Timestamp::MergeFrom(
          from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_mutable_gte()->::google::protobuf::Timestamp::MergeFrom(
          from._internal_gte());
      break;
    }
    case kGtNow: {
      _this->_internal_set_gt_now(from._internal_gt_now());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }

  // @@protoc_insertion_point(copy_constructor:buf.validate.TimestampRules)
}
inline void TimestampRules::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.const__){nullptr},
      decltype(_impl_.within_){nullptr},
      decltype(_impl_.less_than_){},
      decltype(_impl_.greater_than_){},
      /*decltype(_impl_._oneof_case_)*/ {},
  };
  clear_has_less_than();
  clear_has_greater_than();
}
TimestampRules::~TimestampRules() {
  // @@protoc_insertion_point(destructor:buf.validate.TimestampRules)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void TimestampRules::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.const__;
  if (this != internal_default_instance()) delete _impl_.within_;
  if (has_less_than()) {
    clear_less_than();
  }
  if (has_greater_than()) {
    clear_greater_than();
  }
}
void TimestampRules::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimestampRules::clear_less_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.TimestampRules)
  switch (less_than_case()) {
    case kLt: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.less_than_.lt_;
      }
      break;
    }
    case kLte: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.less_than_.lte_;
      }
      break;
    }
    case kLtNow: {
      // No need to clear
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = LESS_THAN_NOT_SET;
}

void TimestampRules::clear_greater_than() {
// @@protoc_insertion_point(one_of_clear_start:buf.validate.TimestampRules)
  switch (greater_than_case()) {
    case kGt: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.greater_than_.gt_;
      }
      break;
    }
    case kGte: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.greater_than_.gte_;
      }
      break;
    }
    case kGtNow: {
      // No need to clear
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[1] = GREATER_THAN_NOT_SET;
}


PROTOBUF_NOINLINE void TimestampRules::Clear() {
// @@protoc_insertion_point(message_clear_start:buf.validate.TimestampRules)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.const__ != nullptr);
      _impl_.const__->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.within_ != nullptr);
      _impl_.within_->Clear();
    }
  }
  clear_less_than();
  clear_greater_than();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* TimestampRules::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 8, 6, 0, 2> TimestampRules::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_._has_bits_),
    0, // no _extensions_
    9, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294966785,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    6,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_TimestampRules_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // optional .google.protobuf.Timestamp const = 2 [json_name = "const", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastMtS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.const__)}},
    // optional .google.protobuf.Duration within = 9 [json_name = "within", (.buf.validate.priv.field) = {
    {::_pbi::TcParser::FastMtS1,
     {74, 1, 5, PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.within_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional .google.protobuf.Timestamp const = 2 [json_name = "const", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.const__), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Timestamp lt = 3 [json_name = "lt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.less_than_.lt_), _Internal::kOneofCaseOffset + 0, 1,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Timestamp lte = 4 [json_name = "lte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.less_than_.lte_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Timestamp gt = 5 [json_name = "gt", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.greater_than_.gt_), _Internal::kOneofCaseOffset + 4, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .google.protobuf.Timestamp gte = 6 [json_name = "gte", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.greater_than_.gte_), _Internal::kOneofCaseOffset + 4, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool lt_now = 7 [json_name = "ltNow", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.less_than_.lt_now_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // bool gt_now = 8 [json_name = "gtNow", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.greater_than_.gt_now_), _Internal::kOneofCaseOffset + 4, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kBool)},
    // optional .google.protobuf.Duration within = 9 [json_name = "within", (.buf.validate.priv.field) = {
    {PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.within_), _Internal::kHasBitsOffset + 1, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
    {::_pbi::TcParser::GetTable<::google::protobuf::Duration>()},
  }}, {{
  }},
};

::uint8_t* TimestampRules::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:buf.validate.TimestampRules)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .google.protobuf.Timestamp const = 2 [json_name = "const", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::const_(this),
        _Internal::const_(this).GetCachedSize(), target, stream);
  }

  switch (less_than_case()) {
    case kLt: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(3, _Internal::lt(this),
          _Internal::lt(this).GetCachedSize(), target, stream);
      break;
    }
    case kLte: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(4, _Internal::lte(this),
          _Internal::lte(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  switch (greater_than_case()) {
    case kGt: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(5, _Internal::gt(this),
          _Internal::gt(this).GetCachedSize(), target, stream);
      break;
    }
    case kGte: {
      target = ::google::protobuf::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::gte(this),
          _Internal::gte(this).GetCachedSize(), target, stream);
      break;
    }
    default:
      break;
  }
  // bool lt_now = 7 [json_name = "ltNow", (.buf.validate.priv.field) = {
  if (less_than_case() == kLtNow) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        7, this->_internal_lt_now(), target);
  }

  // bool gt_now = 8 [json_name = "gtNow", (.buf.validate.priv.field) = {
  if (greater_than_case() == kGtNow) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        8, this->_internal_gt_now(), target);
  }

  // optional .google.protobuf.Duration within = 9 [json_name = "within", (.buf.validate.priv.field) = {
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::within(this),
        _Internal::within(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:buf.validate.TimestampRules)
  return target;
}

::size_t TimestampRules::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:buf.validate.TimestampRules)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .google.protobuf.Timestamp const = 2 [json_name = "const", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.const__);
    }

    // optional .google.protobuf.Duration within = 9 [json_name = "within", (.buf.validate.priv.field) = {
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.within_);
    }

  }
  switch (less_than_case()) {
    // .google.protobuf.Timestamp lt = 3 [json_name = "lt", (.buf.validate.priv.field) = {
    case kLt: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.less_than_.lt_);
      break;
    }
    // .google.protobuf.Timestamp lte = 4 [json_name = "lte", (.buf.validate.priv.field) = {
    case kLte: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.less_than_.lte_);
      break;
    }
    // bool lt_now = 7 [json_name = "ltNow", (.buf.validate.priv.field) = {
    case kLtNow: {
      total_size += 2;
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (greater_than_case()) {
    // .google.protobuf.Timestamp gt = 5 [json_name = "gt", (.buf.validate.priv.field) = {
    case kGt: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.greater_than_.gt_);
      break;
    }
    // .google.protobuf.Timestamp gte = 6 [json_name = "gte", (.buf.validate.priv.field) = {
    case kGte: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.greater_than_.gte_);
      break;
    }
    // bool gt_now = 8 [json_name = "gtNow", (.buf.validate.priv.field) = {
    case kGtNow: {
      total_size += 2;
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData TimestampRules::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    TimestampRules::MergeImpl
};
const ::google::protobuf::Message::ClassData*TimestampRules::GetClassData() const { return &_class_data_; }


void TimestampRules::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<TimestampRules*>(&to_msg);
  auto& from = static_cast<const TimestampRules&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:buf.validate.TimestampRules)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_const_()->::google::protobuf::Timestamp::MergeFrom(
          from._internal_const_());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_within()->::google::protobuf::Duration::MergeFrom(
          from._internal_within());
    }
  }
  switch (from.less_than_case()) {
    case kLt: {
      _this->_internal_mutable_lt()->::google::protobuf::Timestamp::MergeFrom(
          from._internal_lt());
      break;
    }
    case kLte: {
      _this->_internal_mutable_lte()->::google::protobuf::Timestamp::MergeFrom(
          from._internal_lte());
      break;
    }
    case kLtNow: {
      _this->_internal_set_lt_now(from._internal_lt_now());
      break;
    }
    case LESS_THAN_NOT_SET: {
      break;
    }
  }
  switch (from.greater_than_case()) {
    case kGt: {
      _this->_internal_mutable_gt()->::google::protobuf::Timestamp::MergeFrom(
          from._internal_gt());
      break;
    }
    case kGte: {
      _this->_internal_mutable_gte()->::google::protobuf::Timestamp::MergeFrom(
          from._internal_gte());
      break;
    }
    case kGtNow: {
      _this->_internal_set_gt_now(from._internal_gt_now());
      break;
    }
    case GREATER_THAN_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void TimestampRules::CopyFrom(const TimestampRules& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:buf.validate.TimestampRules)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool TimestampRules::IsInitialized() const {
  return true;
}

void TimestampRules::InternalSwap(TimestampRules* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.within_)
      + sizeof(TimestampRules::_impl_.within_)
      - PROTOBUF_FIELD_OFFSET(TimestampRules, _impl_.const__)>(
          reinterpret_cast<char*>(&_impl_.const__),
          reinterpret_cast<char*>(&other->_impl_.const__));
  swap(_impl_.less_than_, other->_impl_.less_than_);
  swap(_impl_.greater_than_, other->_impl_.greater_than_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
  swap(_impl_._oneof_case_[1], other->_impl_._oneof_case_[1]);
}

::google::protobuf::Metadata TimestampRules::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_getter, &descriptor_table_buf_2fvalidate_2fvalidate_2eproto_once,
      file_level_metadata_buf_2fvalidate_2fvalidate_2eproto[23]);
}
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::buf::validate::MessageConstraints >, 11, false>
  message(kMessageFieldNumber, ::buf::validate::MessageConstraints::default_instance(), nullptr);
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::OneofOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::buf::validate::OneofConstraints >, 11, false>
  oneof(kOneofFieldNumber, ::buf::validate::OneofConstraints::default_instance(), nullptr);
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::buf::validate::FieldConstraints >, 11, false>
  field(kFieldFieldNumber, ::buf::validate::FieldConstraints::default_instance(), nullptr);
// @@protoc_insertion_point(namespace_scope)
}  // namespace validate
}  // namespace buf
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
